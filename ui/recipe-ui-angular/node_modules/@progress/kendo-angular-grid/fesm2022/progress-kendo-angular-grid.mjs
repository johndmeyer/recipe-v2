/**-----------------------------------------------------------------------------------------
* Copyright © 2024 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as i0 from '@angular/core';
import { EventEmitter, Injectable, SecurityContext, InjectionToken, Optional, Inject, Directive, SkipSelf, Input, Host, Output, HostBinding, isDevMode, QueryList, Component, ContentChildren, ContentChild, forwardRef, Pipe, TemplateRef, ChangeDetectionStrategy, ViewChildren, ViewChild, Self, NgZone, HostListener, ViewEncapsulation, NgModule } from '@angular/core';
import { merge, of, Subject, from, Subscription, interval, fromEvent, Observable, zip as zip$1, BehaviorSubject } from 'rxjs';
import * as i1$3 from '@progress/kendo-angular-common';
import { isDocumentAvailable, Keys, isPresent as isPresent$1, anyChanged, TemplateContextDirective, DraggableDirective, EventsOutsideAngularDirective, isChanged as isChanged$1, KendoInput, guid, hasObservers, ResizeSensorComponent, closest as closest$1, isFocusable as isFocusable$1, shouldShowValidationUI, WatermarkOverlayComponent, ResizeBatchService } from '@progress/kendo-angular-common';
import * as i1 from '@angular/platform-browser';
import * as i1$1 from '@progress/kendo-angular-icons';
import { IconWrapperComponent, IconsService, KENDO_ICONS } from '@progress/kendo-angular-icons';
import { plusIcon, cancelIcon, lockIcon, unlockIcon, caretAltDownIcon, caretAltRightIcon, caretAltLeftIcon, arrowLeftIcon, arrowRightIcon, sortDescSmallIcon, sortAscSmallIcon, filterClearIcon, filterIcon, columnsIcon, chevronUpIcon, chevronDownIcon, displayInlineFlexIcon, maxWidthIcon, stickIcon, unstickIcon, setColumnPositionIcon, slidersIcon, moreVerticalIcon, reorderIcon, minusIcon, insertMiddleIcon, filePdfIcon, fileExcelIcon } from '@progress/kendo-svg-icons';
import { switchMap, take, map, filter, takeUntil, switchMapTo, delay, tap, throttleTime, debounceTime, distinctUntilChanged, skip, auditTime, bufferCount } from 'rxjs/operators';
import * as i1$2 from '@progress/kendo-angular-l10n';
import { ComponentMessages, LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import * as i42 from '@progress/kendo-angular-pager';
import { PagerContextService, PagerNavigationService, PagerTemplateDirective, KENDO_PAGER } from '@progress/kendo-angular-pager';
import { orderBy, isCompositeFilterDescriptor, groupBy, process, filterBy } from '@progress/kendo-data-query';
import { NgFor, NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, NgClass, NgStyle, NgSwitchDefault } from '@angular/common';
import { getter } from '@progress/kendo-common';
import * as i1$4 from '@progress/kendo-angular-intl';
import * as i5 from '@progress/kendo-angular-popup';
import { PopupService } from '@progress/kendo-angular-popup';
import { ChipListComponent, ChipComponent, ButtonComponent, Button } from '@progress/kendo-angular-buttons';
import * as i1$5 from '@progress/kendo-angular-dropdowns';
import { DropDownListComponent, AutoCompleteComponent } from '@progress/kendo-angular-dropdowns';
import * as i4 from '@angular/forms';
import { NG_VALUE_ACCESSOR, FormsModule, ReactiveFormsModule, FormControl, FormGroup } from '@angular/forms';
import * as i3 from '@progress/kendo-angular-inputs';
import { TextBoxComponent, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, RadioButtonComponent, CheckBoxComponent } from '@progress/kendo-angular-inputs';
import { DatePickerComponent, DatePickerCustomMessagesComponent, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, NavigationService as NavigationService$1 } from '@progress/kendo-angular-dateinputs';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { TabStripComponent, TabStripTabComponent, TabTitleDirective, TabContentDirective } from '@progress/kendo-angular-layout';
import { saveAs } from '@progress/kendo-file-saver';
import * as i5$1 from '@progress/kendo-angular-excel-export';
import { workbookOptions, toDataURL, ColumnBase as ColumnBase$1, KENDO_EXCELEXPORT } from '@progress/kendo-angular-excel-export';
import { PDFExportMarginComponent, PDFExportTemplateDirective, PDFExportComponent } from '@progress/kendo-angular-pdf-export';
import { validatePackage } from '@progress/kendo-licensing';
import { DragTargetContainerDirective, DropTargetContainerDirective } from '@progress/kendo-angular-utils';
import * as i43 from '@progress/kendo-angular-toolbar';
import { KENDO_TOOLBAR } from '@progress/kendo-angular-toolbar';
import { DialogContainerService, DialogService, WindowService, WindowContainerService } from '@progress/kendo-angular-dialog';

/* eslint-disable  no-bitwise */
/**
 * @hidden
 */
const append = (element) => {
    if (!isDocumentAvailable()) {
        return;
    }
    let appended = false;
    return () => {
        if (!appended) {
            document.body.appendChild(element);
            appended = true;
        }
        return element;
    };
};
/**
 * @hidden
 */
const getDocument$1 = element => element.ownerDocument.documentElement;
/**
 * @hidden
 */
const getWindow$1 = element => element.ownerDocument.defaultView;
/**
 * @hidden
 */
const offset = element => {
    const { clientTop, clientLeft } = getDocument$1(element);
    const { pageYOffset, pageXOffset } = getWindow$1(element);
    const { top, left } = element.getBoundingClientRect();
    return {
        top: top + pageYOffset - clientTop,
        left: left + pageXOffset - clientLeft
    };
};
/**
 * @hidden
 * If the target is before the draggable element, returns `true`.
 *
 * DOCUMENT_POSITION_FOLLOWING = 4
 */
const isTargetBefore = (draggable, target) => (target.compareDocumentPosition(draggable) & 4) !== 0;
/**
 * @hidden
 * If the container and the element are the same
 * or if the container holds (contains) the element, returns `true`.
 *
 * DOCUMENT_POSITION_CONTAINED_BY = 16
 */
const contains$2 = (element, container) => element === container ||
    (container.compareDocumentPosition(element) & 16) !== 0;
/**
 * @hidden
 */
const position = (target, before) => {
    const targetRect = offset(target);
    const { offsetWidth, offsetHeight } = target;
    const left = targetRect.left + (before ? 0 : offsetWidth);
    const top = targetRect.top;
    const height = offsetHeight;
    return { left, top, height };
};

/**
 * @hidden
 */
class DragAndDropService {
    changes = new EventEmitter();
    register = [];
    lastTarget = null;
    add(target) {
        this.register.push(target);
    }
    remove(target) {
        this.register = this.register.filter(current => current !== target);
    }
    notifyDrag(draggable, element, mouseEvent) {
        const target = this.targetFor(element);
        if (this.lastTarget === target) {
            return;
        }
        this.changes.next({
            draggable,
            mouseEvent,
            target: this.lastTarget,
            type: 'leave'
        });
        if (target) {
            this.changes.next({
                draggable,
                mouseEvent,
                target,
                type: 'enter'
            });
        }
        this.lastTarget = target;
    }
    notifyDrop(draggable, mouseEvent) {
        this.changes.next({
            draggable,
            mouseEvent,
            target: this.lastTarget,
            type: 'drop'
        });
        this.lastTarget = null;
    }
    targetFor(element) {
        const comparer = contains$2.bind(null, element);
        return this.register.find(({ element: { nativeElement } }) => comparer(nativeElement));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragAndDropService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragAndDropService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragAndDropService, decorators: [{
            type: Injectable
        }] });

const updateClass = (element, valid, svg) => {
    const icon = element.querySelector('.k-icon');
    if (svg) {
        const svg = icon.firstElementChild;
        svg.removeChild(svg.firstElementChild);
        const path = valid ? plusIcon.content : cancelIcon.content;
        icon.firstElementChild.innerHTML = path + icon.firstElementChild.innerHTML;
    }
    icon.setAttribute('class', icon.getAttribute('class').replace(/(plus|cancel)/, valid ? 'plus' : 'cancel'));
};
const updateLock = (element, locked = null, svg) => {
    const icon = element.querySelectorAll('.k-icon')[1];
    const value = locked === null ? '' : (locked ? `k${svg ? '-svg' : ''}-i-lock` : `k${svg ? '-svg' : ''}-i-unlock`);
    if (svg) {
        icon.setAttribute('class', icon.getAttribute('class').replace(/(k-svg-i-unlock|k-svg-i-lock)/, '').trim() + ` ${value}`);
        icon.firstElementChild.innerHTML = locked ? lockIcon.content : unlockIcon.content;
    }
    else {
        icon.setAttribute('class', icon.getAttribute('class').replace(/(k-i-unlock|k-i-lock)/, '').trim() + ` ${value}`);
    }
};
const decorate = (element) => {
    element.className = 'k-header k-drag-clue';
    element.style.position = 'absolute';
    element.style.zIndex = '20000';
};
const svgIconsMarkup = (viewBox, content, safeTitle) => `
    <span class="k-icon k-svg-icon k-drag-status k-svg-i-cancel">
        <svg 
            xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            viewBox="${viewBox}"
            aria-hidden="true">
            ${content}
        </svg>
        <span class="k-icon k-svg-icon k-icon-modifier">
            <svg
                xmlns="http://www.w3.org/2000/svg"
                xmlns:xlink="http://www.w3.org/1999/xlink"
                viewBox="${viewBox}"
                aria-hidden="true">
            </svg>
        </span>
    </span>
    ${safeTitle}`;
const fontIconsMarkup = (safeTitle) => `
    <span class="k-icon k-font-icon k-drag-status k-i-cancel">
        <span class="k-icon k-font-icon k-icon-modifier"></span>
    </span>
    ${safeTitle}`;
/**
 * @hidden
 */
class DragHintService {
    santizer;
    iconsService;
    dom;
    cancelIcon = cancelIcon;
    constructor(santizer, iconsService) {
        this.santizer = santizer;
        this.iconsService = iconsService;
    }
    create(title) {
        if (!isDocumentAvailable()) {
            return;
        }
        this.dom = document.createElement("div");
        decorate(this.dom);
        const safeTitle = this.santizer.sanitize(SecurityContext.HTML, title);
        const innerHtml = this.isSVG ?
            svgIconsMarkup(this.cancelIcon.viewBox, this.cancelIcon.content, safeTitle) :
            fontIconsMarkup(safeTitle);
        this.dom.innerHTML = innerHtml;
    }
    attach() {
        return append(this.dom);
    }
    remove() {
        if (this.dom && this.dom.parentNode) {
            (function (el) {
                setTimeout(() => document.body.removeChild(el));
            })(this.dom); // hack for IE + pointer events!
            this.dom = null;
        }
    }
    show() {
        this.dom.style.display = "";
    }
    hide() {
        this.dom.style.display = "none";
    }
    enable() {
        updateClass(this.dom, true, this.isSVG);
    }
    disable() {
        updateClass(this.dom, false, this.isSVG);
    }
    removeLock() {
        updateLock(this.dom, false, this.isSVG);
    }
    toggleLock(locked) {
        updateLock(this.dom, locked, this.isSVG);
    }
    move(move) {
        this.dom.style.top = move.pageY + 'px';
        this.dom.style.left = move.pageX + 'px';
    }
    get isSVG() {
        return (this.iconsService.iconSettings?.type || this.iconsService.changes.value.type) === 'svg';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragHintService, deps: [{ token: i1.DomSanitizer }, { token: i1$1.IconsService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragHintService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragHintService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.DomSanitizer }, { type: i1$1.IconsService }]; } });

/**
 * @hidden
 */
class DropCueService {
    dom;
    create() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.dom = document.createElement("div");
        this.dom.className = 'k-grouping-dropclue';
        this.hide();
    }
    attach() {
        return append(this.dom);
    }
    remove() {
        if (this.dom && this.dom.parentElement) {
            document.body.removeChild(this.dom);
            this.dom = null;
        }
    }
    hide() {
        this.dom.style.display = "none";
    }
    position({ left, top, height }) {
        this.dom.style.display = 'block';
        this.dom.style.height = height + 'px';
        this.dom.style.top = top + 'px';
        const width = this.dom.offsetWidth / 2;
        this.dom.style.left = left - width + 'px';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DropCueService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DropCueService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DropCueService, decorators: [{
            type: Injectable
        }] });

const EMPTY_REGEX = /^\s*$/;
/**
 * @hidden
 */
const isPresent = (value) => value !== null && value !== undefined;
/**
 * @hidden
 */
const isBlank = (value) => value === null || value === undefined;
/**
 * @hidden
 */
const isArray = (value) => Array.isArray(value);
/**
 * @hidden
 */
const isTruthy = (value) => !!value;
/**
 * @hidden
 */
const isNullOrEmptyString = (value) => isBlank(value) || EMPTY_REGEX.test(value);
/**
 * @hidden
 */
const observe = (list) => merge(of(list), list.changes);
/**
 * @hidden
 */
const isUniversal = () => typeof document === 'undefined';
/**
 * @hidden
 */
const isString = (value) => typeof value === 'string';
/**
 * @hidden
 */
const isNumber = (value) => typeof value === "number" && !isNaN(value);
/**
 * @hidden
 */
const extractFormat = (format) => {
    if (isString(format) && !isNullOrEmptyString(format) && format.startsWith('{0:')) {
        return format.slice(3, format.length - 1);
    }
    return format;
};
/**
 * @hidden
 */
const not = (fn) => (...args) => !fn(...args);
/**
 * @hidden
 */
const or = (...conditions) => (value) => conditions.reduce((acc, x) => acc || x(value), false);
/**
 * @hidden
 */
const and = (...conditions) => (value) => conditions.reduce((acc, x) => acc && x(value), true);
/**
 * @hidden
 */
const Skip = new InjectionToken("Skip");
/**
 * @hidden
 */
const createPromise = () => {
    let resolveFn, rejectFn;
    const promise = new Promise((resolve, reject) => {
        resolveFn = (data) => {
            resolve(data);
            return promise;
        };
        rejectFn = (data) => {
            reject(data);
            return promise;
        };
    });
    promise.resolve = resolveFn;
    promise.reject = rejectFn;
    return promise;
};
/** @hidden */
const iterator = getIterator$1();
// TODO: Move to kendo-common
function getIterator$1() {
    if (typeof Symbol === 'function' && Symbol.iterator) {
        return Symbol.iterator;
    }
    const keys = Object.getOwnPropertyNames(Map.prototype);
    const proto = Map.prototype;
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key !== 'entries' && key !== 'size' && proto[key] === proto.entries) {
            return key;
        }
    }
}
const FRAME_DURATION = 1000 / 60;
const wnd = typeof window !== 'undefined' ? window : {};
/** @hidden */
const requestAnimationFrame = wnd.requestAnimationFrame || wnd.msRequestAnimationFrame || (callback => setTimeout(callback, FRAME_DURATION));
/** @hidden */
const cancelAnimationFrame = wnd.cancelAnimationFrame || wnd.msCancelRequestAnimationFrame || clearTimeout;
/**
 * @hidden
 */
const detectIE = () => {
    if (!isDocumentAvailable()) {
        return;
    }
    const ua = window.navigator.userAgent;
    const msie = ua.indexOf('MSIE ');
    const trident = ua.indexOf('Trident/');
    return msie > 0 || trident > 0;
};
/**
 * @hidden
 */
const nodesToArray = (nodes) => [].slice.call(nodes);
/**
 * @hidden
 */
const replaceMessagePlaceholder = (message, name, value) => message.replace(new RegExp(`\{\\s*${name}\\s*\}`, 'g'), value);
/**
 * @hidden
 */
const recursiveFlatMap = (item) => isGroupResult(item) ? item.items.flatMap(recursiveFlatMap) : [{ ...item }];
/**
 * @hidden
 */
const isGroupResult = (obj) => {
    return 'aggregates' in obj && 'items' in obj && 'field' in obj && 'value' in obj;
};

/**
 * @hidden
 */
const FOCUS_ROOT_ACTIVE = new InjectionToken('focus-root-initial-active-state');
/**
 * @hidden
 */
class FocusRoot {
    active;
    groups = new Set();
    constructor(active = false) {
        this.active = active;
    }
    registerGroup(group) {
        if (this.active) {
            this.groups.add(group);
        }
    }
    unregisterGroup(group) {
        if (this.active) {
            this.groups.delete(group);
        }
    }
    activate() {
        if (this.active) {
            this.groups.forEach(f => f.activate());
        }
    }
    deactivate() {
        if (this.active) {
            this.groups.forEach(f => f.deactivate());
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FocusRoot, deps: [{ token: FOCUS_ROOT_ACTIVE, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FocusRoot });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FocusRoot, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [FOCUS_ROOT_ACTIVE]
                }] }]; } });

const focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
const NODE_NAME_PREDICATES = {};
const toClassList = (classNames) => String(classNames).trim().split(' ');
/**
 * @hidden
 */
const hasClasses = (element, classNames) => {
    const namesList = toClassList(classNames);
    return Boolean(toClassList(element.className).find((className) => namesList.indexOf(className) >= 0));
};
/**
 * @hidden
 */
const matchesClasses = (classNames) => (element) => hasClasses(element, classNames);
/**
 * @hidden
 */
const matchesNodeName = (nodeName) => {
    if (!NODE_NAME_PREDICATES[nodeName]) {
        NODE_NAME_PREDICATES[nodeName] = (element) => String(element.nodeName).toLowerCase() === nodeName.toLowerCase();
    }
    return NODE_NAME_PREDICATES[nodeName];
};
/**
 * @hidden
 */
const closest = (node, predicate) => {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
const closestInScope = (node, predicate, scope) => {
    while (node && node !== scope && !predicate(node)) {
        node = node.parentNode;
    }
    if (node !== scope) {
        return node;
    }
};
/**
 * @hidden
 */
const contains$1 = (parent, node, matchSelf = false) => {
    const outside = !closest(node, (child) => child === parent);
    if (outside) {
        return false;
    }
    const el = closest(node, (child) => child === node);
    return el && (matchSelf || el !== parent);
};
/**
 * @hidden
 */
const isVisible = (element) => {
    if (!isDocumentAvailable()) {
        return;
    }
    const rect = element.getBoundingClientRect();
    const hasSize = rect.width > 0 && rect.height > 0;
    const hasPosition = rect.x !== 0 && rect.y !== 0;
    // Elements can have zero size due to styling, but they will still count as visible.
    // For example, the selection checkbox has no size, but is made visible through styling.
    return (hasSize || hasPosition) && window.getComputedStyle(element).visibility !== 'hidden';
};
/**
 * @hidden
 */
const isFocusable = (element) => {
    if (!element.tagName) {
        return false;
    }
    const tagName = element.tagName.toLowerCase();
    const hasTabIndex = Boolean(element.getAttribute('tabIndex'));
    const focusable = !element.disabled && focusableRegex.test(tagName);
    return focusable || hasTabIndex;
};
/**
 * @hidden
 */
const isFocusableWithTabKey = (element, checkVisibility = true) => {
    if (!isFocusable(element)) {
        return false;
    }
    const visible = !checkVisibility || isVisible(element);
    const ariaHidden = element.getAttribute('aria-hidden') === 'true';
    const tabIndex = element.getAttribute('tabIndex');
    return visible && !ariaHidden && tabIndex !== '-1';
};
/**
 * @hidden
 */
const findElement = (node, predicate, matchSelf = true) => {
    if (!node) {
        return;
    }
    if (matchSelf && predicate(node)) {
        return node;
    }
    node = node.firstChild;
    while (node) {
        if (node.nodeType === 1) {
            const element = findElement(node, predicate);
            if (element) {
                return element;
            }
        }
        node = node.nextSibling;
    }
};
/**
 * @hidden
 */
const findLastElement = (node, predicate, matchSelf = true) => {
    let last = null;
    findElement(node, (node) => {
        if (predicate(node)) {
            last = node;
        }
        return false;
    }, matchSelf);
    return last;
};
/**
 * @hidden
 */
const findFocusable = (element, checkVisibility = true) => {
    return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility));
};
/**
 * @hidden
 */
const findFocusableChild = (element, checkVisibility = true) => {
    return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility), false);
};
/**
 * @hidden
 */
const findLastFocusableChild = (element, checkVisibility = true) => {
    return findLastElement(element, (node) => isFocusableWithTabKey(node, checkVisibility), false);
};
/**
 * @hidden
 */
function rtlScrollPosition(position, element, initial) {
    let result = position;
    if (initial < 0) {
        result = -position;
    }
    else if (initial > 0) {
        result = element.scrollWidth - element.offsetWidth - position;
    }
    return result;
}

const isButton = matchesNodeName('button');
const isInputTag = matchesNodeName('input');
const isKendoInputTag = matchesNodeName('kendo-checkbox') || matchesNodeName('kendo-textbox');
const navigableRegex = /(button|checkbox|color|file|radio|reset|submit)/i;
const isNavigableInput = element => isInputTag(element) && navigableRegex.test(element.type);
const isNavigable = element => !element.disabled && (isButton(element) || isNavigableInput(element) || isKendoInputTag(element));
/**
 * @hidden
 */
class DefaultFocusableElement {
    renderer;
    get enabled() {
        return this.focusable && !this.focusable.disabled;
    }
    get visible() {
        return this.focusable && isVisible(this.focusable);
    }
    element;
    focusable;
    constructor(host, renderer) {
        this.renderer = renderer;
        this.element = host.nativeElement;
        this.focusable = findFocusable(this.element, false) || this.element;
    }
    isNavigable() {
        return this.canFocus() && isNavigable(this.element);
    }
    toggle(active) {
        this.renderer.setAttribute(this.focusable, 'tabIndex', active ? '0' : '-1');
    }
    focus() {
        if (this.focusable) {
            this.focusable.focus();
        }
    }
    canFocus() {
        return this.visible && this.enabled;
    }
    hasFocus() {
        return isDocumentAvailable() && document.activeElement !== this.element && closest(document.activeElement, e => e === this.element);
    }
}

/**
 * @hidden
 */
const CELL_CONTEXT = new InjectionToken('grid-cell-context');
/**
 * @hidden
 */
const EMPTY_CELL_CONTEXT = {};

/**
 * @hidden
 */
class GridToolbarNavigationService {
    renderer;
    navigableElements = [];
    currentActiveIndex = 0;
    defaultFocusableSelector = `
        [kendogridtoolbarfocusable],
        [kendogridaddcommand],
        [kendogridcancelcommand],
        [kendogrideditcommand],
        [kendogridremovecommand],
        [kendogridsavecommand],
        [kendogridexcelcommand],
        [kendogridpdfcommand]
    `;
    constructor(renderer) {
        this.renderer = renderer;
    }
    notify() {
        // ensure focusable elements are in the same order as in the DOM
        this.navigableElements = this.navigableElements.length && Array.from(this.navigableElements[0].parentElement.querySelectorAll(this.defaultFocusableSelector)) || [];
        this.currentActiveIndex = 0;
        this.updateFocus();
    }
    focus() {
        this.navigableElements[this.currentActiveIndex]?.focus();
    }
    updateFocus() {
        if (!this.navigableElements.length) {
            return;
        }
        this.navigableElements.forEach(el => {
            this.renderer.setAttribute(el, 'tabindex', '-1');
        });
        this.renderer.setAttribute(this.navigableElements[this.currentActiveIndex], 'tabindex', '0');
        if (isDocumentAvailable() && document.activeElement.closest('.k-toolbar')) {
            this.navigableElements[this.currentActiveIndex].focus();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridToolbarNavigationService, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridToolbarNavigationService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridToolbarNavigationService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; } });

/**
 * @hidden
 *
 * The Context service is used to provide common
 * services and DI tokens for a Grid instance.
 *
 * This keeps the constructor parameters stable
 * and a avoids dependency cycles between components.
 */
class ContextService {
    renderer;
    localization;
    grid;
    topToolbarNavigation;
    bottomToolbarNavigation;
    navigable;
    groupBindingDirective;
    constructor(renderer, localization) {
        this.renderer = renderer;
        this.localization = localization;
        this.topToolbarNavigation = new GridToolbarNavigationService(this.renderer);
        this.bottomToolbarNavigation = new GridToolbarNavigationService(this.renderer);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ContextService, deps: [{ token: i0.Renderer2 }, { token: i1$2.LocalizationService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ContextService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ContextService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i1$2.LocalizationService }]; } });

/**
 * A directive that controls the way focusable elements receive
 * [focus in a navigable Grid]({% slug keyboard_navigation_grid %}).
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" [navigable]="true">
 *    <kendo-grid-column>
 *       <ng-template kendoGridCellTemplate let-dataItem>
 *          <!-- The first focusable element will be focused when pressing Enter on the cell -->
 *          <input type="text" kendoGridFocusable [value]="dataItem.ProductName" style="margin-right: 8px;" />
 *          <button kendoGridFocusable>Update</button>
 *       </ng-template>
 *    </kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class FocusableDirective {
    cellContext;
    hostElement;
    renderer;
    ctx;
    active = true;
    group;
    element;
    _enabled = true;
    /**
     * @hidden
     */
    set enabled(value) {
        if (value === '') {
            value = true;
        }
        else {
            value = Boolean(value);
        }
        if (value !== this.enabled) {
            this._enabled = value;
            if (this.element) {
                this.element.toggle(this.active && value);
            }
        }
    }
    get enabled() {
        return this._enabled;
    }
    constructor(cellContext, hostElement, renderer, ctx) {
        this.cellContext = cellContext;
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.ctx = ctx;
        if (this.cellContext) {
            this.group = this.cellContext.focusGroup;
        }
        if (this.group) {
            this.group.registerElement(this);
        }
    }
    ngAfterViewInit() {
        if (!this.element && this.ctx.navigable) {
            this.element = new DefaultFocusableElement(this.hostElement, this.renderer);
        }
        if (this.group && this.element) {
            this.toggle(this.group.isActive);
        }
    }
    ngOnDestroy() {
        if (this.group) {
            this.group.unregisterElement(this);
        }
    }
    /**
     * @hidden
     */
    toggle(active) {
        if (this.element && active !== this.active) {
            this.element.toggle(this.enabled && active);
            this.active = active;
        }
    }
    /**
     * @hidden
     */
    canFocus() {
        return this.enabled && this.element && this.element.canFocus();
    }
    /**
     * @hidden
     */
    isNavigable() {
        return this.enabled && this.element && this.element.isNavigable();
    }
    /**
     * @hidden
     */
    focus() {
        if (this.enabled && this.element) {
            this.element.focus();
        }
    }
    /**
     * @hidden
     */
    hasFocus() {
        return this.enabled && this.element && this.element.hasFocus();
    }
    /**
     * @hidden
     */
    registerElement(element) {
        this.element = element;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FocusableDirective, deps: [{ token: CELL_CONTEXT, optional: true, skipSelf: true }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: FocusableDirective, isStandalone: true, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: { enabled: ["kendoGridFocusable", "enabled"] }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FocusableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridFocusable]' + `,
        [kendoGridEditCommand],
        [kendoGridRemoveCommand],
        [kendoGridSaveCommand],
        [kendoGridCancelCommand],
        [kendoGridSelectionCheckbox]
    `,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [CELL_CONTEXT]
                }, {
                    type: SkipSelf
                }] }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ContextService }]; }, propDecorators: { enabled: [{
                type: Input,
                args: ['kendoGridFocusable']
            }] } });

/**
 * @hidden
 */
class GridFocusableElement {
    navigationService;
    constructor(navigationService) {
        this.navigationService = navigationService;
    }
    focus() {
        this.navigationService.focusCell();
    }
    toggle(active) {
        this.navigationService.toggle(active);
    }
    canFocus() {
        return true;
    }
    hasFocus() {
        return this.navigationService.hasFocus();
    }
    isNavigable() {
        return false;
    }
}

/**
 * @hidden
 */
class NavigationCursor {
    model;
    changes = new Subject();
    set metadata(value) {
        this._metadata = value;
        if (isPresent(value)) {
            const newActiveCol = value.hasDetailTemplate ? 1 : 0;
            const shouldChange = this.activeRow < value.headerRows && this.activeCol === 0;
            if (shouldChange && newActiveCol !== this.activeCol) {
                this.activeCol = newActiveCol;
                this.reset();
            }
        }
    }
    get metadata() {
        return this._metadata;
    }
    activeRow = 0;
    activeCol = 0;
    virtualCol = 0;
    virtualRow = 0;
    _metadata;
    get row() {
        return this.model.findRow(this.activeRow);
    }
    get cell() {
        const row = this.row;
        if (row) {
            return this.model.findCell(this.activeCol, row);
        }
    }
    get dataRowIndex() {
        const row = this.row;
        if (row) {
            return row.dataRowIndex;
        }
        return -1;
    }
    constructor(model) {
        this.model = model;
    }
    /**
     * Assumes and announces a new cursor position.
     */
    reset(rowIndex = this.activeRow, colIndex = this.activeCol, force = true) {
        if (this.activate(rowIndex, colIndex, force)) {
            this.virtualRow = rowIndex;
            this.virtualCol = colIndex;
        }
    }
    activate(rowIndex, colIndex, force) {
        if (!force && this.isActiveRange(rowIndex, colIndex)) {
            return false;
        }
        const prevColIndex = this.activeCol;
        const prevRowIndex = this.activeRow;
        this.activeCol = colIndex;
        this.activeRow = rowIndex;
        this.changes.next({
            colIndex,
            prevColIndex,
            prevRowIndex,
            rowIndex
        });
        return true;
    }
    isActiveRange(rowIndex, colIndex) {
        if (this.activeRow !== rowIndex) {
            return false;
        }
        const cell = this.cell;
        const { start, end } = this.model.cellRange(cell);
        return !cell || (start <= colIndex && colIndex <= end);
    }
    /**
     * Assumes a new cursor position without announcing it.
     */
    assume(rowIndex = this.activeRow, colIndex = this.activeCol) {
        this.virtualRow = rowIndex;
        this.virtualCol = colIndex;
        this.activeCol = colIndex;
        this.activeRow = rowIndex;
    }
    /**
     * Announces a current cursor position to subscribers.
     */
    announce() {
        this.changes.next({
            colIndex: this.activeCol,
            prevColIndex: this.activeCol,
            prevRowIndex: this.activeRow,
            rowIndex: this.activeRow
        });
    }
    activateVirtualCell(cell) {
        const rowRange = this.model.rowRange(cell);
        const cellRange = this.model.cellRange(cell);
        const activeCol = this.activeCol;
        const activeRow = this.activeRow;
        if (rowRange.start <= activeRow && activeRow <= rowRange.end &&
            cellRange.start <= activeCol && activeCol <= cellRange.end) {
            this.activeRow = cell.rowIndex;
            this.activeCol = cell.colIndex;
            return true;
        }
    }
    isActive(rowIndex, colIndex) {
        return this.activeCol === colIndex && this.activeRow === rowIndex;
    }
    moveUp(offset = 1) {
        return this.offsetRow(-offset);
    }
    moveDown(offset = 1) {
        return this.offsetRow(offset);
    }
    moveLeft(offset = 1) {
        return this.offsetCol(-offset);
    }
    moveRight(offset = 1) {
        return this.offsetCol(offset);
    }
    lastCellIndex(row) {
        return this.metadata.columns.leafColumnsToRender.length - 1 +
            (this.metadata.hasDetailTemplate && (!row || !row.groupItem) ? 1 : 0);
    }
    offsetCol(offset) {
        const prevRow = this.model.findRow(this.virtualRow);
        const lastIndex = this.lastCellIndex(prevRow);
        const virtualCol = this.virtualCol;
        this.virtualCol = Math.max(0, Math.min(virtualCol + offset, lastIndex));
        let nextColIndex = this.virtualCol;
        const nextRowIndex = this.virtualRow;
        let cell = this.model.findCell(this.virtualCol, prevRow);
        if (!cell && this.metadata.virtualColumns) {
            return this.activate(nextRowIndex, nextColIndex);
        }
        if (!cell && this.metadata.hasDetailTemplate) {
            this.virtualCol += 1;
            return false;
        }
        if (cell.colSpan > 1 && cell.colIndex <= virtualCol && virtualCol < cell.colIndex + cell.colSpan) {
            nextColIndex = offset > 0 ? Math.min(cell.colIndex + cell.colSpan, lastIndex) : Math.max(0, cell.colIndex + offset);
            const nextCell = this.model.findCell(nextColIndex, prevRow);
            if (!nextCell) {
                this.virtualCol = nextColIndex;
                return this.activate(cell.rowIndex, nextColIndex);
            }
            if (cell !== nextCell) {
                cell = nextCell;
                this.virtualCol = cell.colIndex;
            }
            else {
                this.virtualCol = virtualCol;
            }
            return this.activate(cell.rowIndex, this.virtualCol);
        }
        this.virtualCol = cell.colIndex;
        return this.activate(cell.rowIndex, cell.colIndex);
    }
    offsetRow(offset) {
        let nextColIndex = this.virtualCol;
        if (this.metadata && this.metadata.isVirtual) {
            const maxIndex = this.metadata.maxLogicalRowIndex;
            let nextIndex = Math.max(0, Math.min(this.activeRow + offset, maxIndex));
            if (this.metadata.hasDetailTemplate && !this.model.findRow(nextIndex)) {
                nextIndex = offset > 0 ? nextIndex + 1 : nextIndex - 1;
                nextIndex = Math.max(0, Math.min(nextIndex, maxIndex));
            }
            if (this.metadata.hasDetailTemplate && nextIndex === maxIndex) {
                if (this.model.lastRow.index !== maxIndex) {
                    // Don't attempt to navigate past the last collapsed row.
                    nextIndex--;
                }
            }
            const nextRow = this.model.findRow(nextIndex);
            if (nextRow) {
                // remove duplication
                let cell = this.model.findCell(this.virtualCol, nextRow);
                if (!cell) {
                    return;
                }
                if (cell.rowIndex <= this.virtualRow && offset > 0 && cell.rowSpan > 1) {
                    cell = this.model.findCell(this.virtualCol, this.model.findRow(cell.rowIndex + cell.rowSpan - 1 + offset));
                    if (!cell) {
                        return;
                    }
                }
                nextIndex = cell.rowIndex;
                nextColIndex = cell.colIndex;
            }
            this.virtualRow = nextIndex;
            return this.activate(nextIndex, nextColIndex);
        }
        const nextRow = this.model.findRow(this.virtualRow + offset) || this.model.nextRow(this.virtualRow, offset);
        if (!nextRow) {
            return false;
        }
        let cell = this.model.findCell(this.virtualCol, nextRow);
        if (cell && cell.rowIndex <= this.virtualRow && offset > 0 && cell.rowSpan > 1) { // spanned cell go to next
            const nextPos = cell.rowIndex + cell.rowSpan - 1 + offset;
            cell = this.model.findCell(this.virtualCol, this.model.findRow(nextPos));
        }
        if (!cell && (this.metadata.virtualColumns || this.metadata.hasDetailTemplate)) {
            return this.activate(this.virtualRow + offset, this.virtualCol);
        }
        this.virtualRow = cell.rowIndex;
        return this.activate(this.virtualRow, cell.colIndex);
    }
}

/**
 * @hidden
 */
class ItemMap {
    count = 0;
    items = {};
    get first() {
        if (this.count > 0) {
            let result;
            this.forEach(item => {
                result = item;
                return true;
            });
            return result;
        }
    }
    get last() {
        if (this.count > 0) {
            const keys = Object.keys(this.items);
            return this.items[keys[keys.length - 1]];
        }
    }
    removeItem(key) {
        if (this.items[key]) {
            delete this.items[key];
            this.count--;
        }
    }
    setItem(key, item) {
        if (!this.items[key]) {
            this.count++;
        }
        this.items[key] = item;
    }
    getItem(key) {
        return this.items[key];
    }
    toArray() {
        const result = [];
        this.forEach(item => {
            result.push(item);
        });
        return result;
    }
    forEach(callback) {
        for (const key in this.items) {
            if (this.items.hasOwnProperty(key) && callback(this.items[key])) {
                return this.items[key];
            }
        }
    }
    find(callback) {
        return this.forEach(callback);
    }
}

/**
 * @hidden
 *
 * Contains information for the currently rendered rows and cells.
 */
class NavigationModel {
    rows = new ItemMap();
    get firstRow() {
        return this.rows.first;
    }
    get lastRow() {
        return this.rows.last;
    }
    registerCell(cell) {
        const row = this.rows.getItem(cell.logicalRowIndex);
        if (!row) {
            return;
        }
        const colIndex = cell.logicalColIndex;
        const modelCell = {
            uid: cell.uid,
            colIndex,
            rowIndex: row.index,
            colSpan: cell.colSpan,
            rowSpan: cell.rowSpan,
            detailExpandCell: cell.detailExpandCell,
            dataItem: row.dataItem,
            dataRowIndex: row.dataRowIndex,
            focusGroup: cell.focusGroup
        };
        row.cells.setItem(colIndex, modelCell);
        if (cell.groupItem) {
            row.groupItem = cell.groupItem;
        }
        return modelCell;
    }
    unregisterCell(index, rowIndex, cell) {
        const row = this.rows.getItem(rowIndex);
        if (row) {
            const match = row.cells.getItem(index);
            if (match && match.uid === cell.uid) {
                row.cells.removeItem(index);
            }
        }
    }
    registerRow(row) {
        const modelRow = {
            uid: row.uid,
            index: row.logicalRowIndex,
            dataItem: row.dataItem,
            dataRowIndex: row.dataRowIndex,
            cells: new ItemMap()
        };
        this.rows.setItem(row.logicalRowIndex, modelRow);
    }
    updateRow(row) {
        const current = this.rows.getItem(row.logicalRowIndex);
        if (current) {
            Object.assign(current, {
                dataItem: row.dataItem,
                dataRowIndex: row.dataRowIndex
            });
        }
    }
    unregisterRow(index, row) {
        const match = this.rows.getItem(index);
        if (match && match.uid === row.uid) {
            this.rows.removeItem(index);
        }
    }
    cellRange(cell) {
        if (cell) {
            const start = cell.colIndex;
            const end = cell.colIndex + (cell.colSpan || 1) - 1;
            return {
                start,
                end
            };
        }
        return {};
    }
    rowRange(cell) {
        if (cell) {
            const start = cell.rowIndex;
            const end = cell.rowIndex + (cell.rowSpan || 1) - 1;
            return {
                start,
                end
            };
        }
        return {};
    }
    nextRow(rowIndex, offset) {
        const rows = this.rows.toArray();
        const row = this.rows.getItem(rowIndex);
        const position = rows.indexOf(row);
        const next = rows[position + offset];
        return next;
    }
    findRow(index) {
        return this.rows.getItem(index);
    }
    findCell(index, row) {
        if (!row) {
            return;
        }
        const rowIndex = row.index;
        let cell = row.cells.getItem(index);
        let currentIndex = rowIndex;
        while (!cell && row) {
            row = this.rows.getItem(currentIndex);
            cell = this.rowCell(index, row);
            currentIndex--;
        }
        if (cell && rowIndex <= row.index + (cell.rowSpan || 1) - 1) {
            return cell;
        }
    }
    rowCell(index, row) {
        if (!row || !row.cells.count) {
            return;
        }
        const firstCell = row.cells.first;
        let cell, currentIndex = index;
        while (!cell && currentIndex >= firstCell.colIndex) {
            cell = row.cells.getItem(currentIndex);
            currentIndex--;
        }
        if (cell && index <= cell.colIndex + (cell.colSpan || 1) - 1) {
            return cell;
        }
    }
}

/**
 * @hidden
 */
class DomEventsService {
    cellClick = new EventEmitter();
    cellMousedown = new EventEmitter();
    cellMouseup = new EventEmitter();
    click = new EventEmitter();
    keydown = new EventEmitter();
    focus = new EventEmitter();
    focusIn = new EventEmitter();
    focusOut = new EventEmitter();
    windowBlur = new EventEmitter();
    paste = new EventEmitter();
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DomEventsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DomEventsService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DomEventsService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
class PreventableEvent {
    prevented = false;
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses
     * the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * Returns a respective boolean if the event was prevented
     * by any of its subscribers.
     *
     * @returns `true` if the default action was prevented.
     * Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Arguments for the `cellClose` event.
 */
class CellCloseEvent extends PreventableEvent {
    isNew;
    dataItem;
    rowIndex;
    sender;
    /**
     * @hidden
     */
    action = 'cellClose';
    /**
     * The Grid column that will be closed.
     */
    column;
    /**
     * The [FormGroup](link:site.data.urls.angular['formgroupapi']) that is used to edit the cell which will be closed.
     */
    formGroup;
    /**
     * The DOM event that caused the `cellClose` event.
     * May not be present if `cellClose` was caused by an API call.
     */
    originalEvent;
    constructor(options) {
        super();
        Object.assign(this, options);
    }
}

/**
 * @hidden
 */
const isEqual = (index) => (item) => item.index === index;
/**
 * @hidden
 */
const isNotEqual = (index) => (item) => item.index !== index;
/**
 * @hidden
 */
const isNewRow = (index) => index === -1 || index === undefined;
/**
 * @hidden
 */
class EditService {
    ngZone;
    changes = new EventEmitter();
    changed;
    editedIndices = [];
    newItemGroup;
    keepEditCell = false;
    keepCellTimeout;
    column;
    closingCell = false;
    changedSource = new Subject();
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.changed = this.changedSource.asObservable().pipe(switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1))));
    }
    editRow(index, group = undefined) {
        this.editedIndices.push({ index, group });
        this.onChanged();
    }
    addRow(group) {
        this.newItemGroup = { group };
        this.onChanged();
    }
    editCell(rowIndex, column, group) {
        if (isNewRow(rowIndex) || column.editable === false || !(column.editTemplate || column.field)) {
            return;
        }
        this.preventCellClose();
        if (!this.closeCell()) {
            this.editRow(rowIndex, group);
            this.column = column;
            this.onChanged();
        }
    }
    isEditing() {
        return this.editedIndices.length > 0;
    }
    isEditingCell() {
        return this.isEditing() && this.column !== undefined;
    }
    get hasNewItem() {
        return isPresent(this.newItemGroup);
    }
    get newDataItem() {
        if (this.hasNewItem) {
            return this.newItemGroup.group.value;
        }
        return {};
    }
    close(index) {
        if (isNewRow(index)) {
            this.newItemGroup = undefined;
            return;
        }
        this.editedIndices = this.editedIndices.filter(isNotEqual(index));
        delete this.column;
        this.onChanged();
    }
    closeCell(originalEvent) {
        if (this.column && !this.closingCell) {
            return this.ngZone.run(() => {
                const { index, group } = this.editedIndices[0];
                const args = new CellCloseEvent({
                    column: this.column,
                    formGroup: group,
                    originalEvent: originalEvent,
                    rowIndex: index
                });
                this.closingCell = true;
                this.changes.emit(args);
                this.closingCell = false;
                if (!args.isDefaultPrevented()) {
                    this.cancelCell();
                }
                return args.isDefaultPrevented();
            });
        }
    }
    cancelCell() {
        if (this.column) {
            this.editedIndices = [];
            delete this.column;
            this.onChanged();
        }
    }
    shouldCloseCell() {
        return this.column && !this.keepEditCell;
    }
    preventCellClose() {
        this.ngZone.runOutsideAngular(() => {
            window.clearTimeout(this.keepCellTimeout);
            this.keepEditCell = true;
            this.keepCellTimeout = window.setTimeout(() => {
                this.keepEditCell = false;
            }, 0);
        });
    }
    context(index) {
        if (isNewRow(index)) {
            return this.newItemGroup;
        }
        return this.findByIndex(index);
    }
    columnContext(index, column) {
        if (isNewRow(index)) {
            return this.newItemGroup;
        }
        if (!this.column || column === this.column) {
            return this.findByIndex(index);
        }
    }
    isEdited(index) {
        if (isNewRow(index) && isPresent(this.newItemGroup)) {
            return true;
        }
        return !this.column && isPresent(this.findByIndex(index));
    }
    hasEdited(index) {
        return isPresent(this.context(index));
    }
    isEditedColumn(index, column) {
        if (this.column && this.column === column) {
            return isPresent(this.findByIndex(index));
        }
        return false;
    }
    beginEdit(rowIndex) {
        this.changes.emit({ action: 'edit', rowIndex });
    }
    beginAdd() {
        this.changes.emit({ action: 'add' });
    }
    endEdit(rowIndex) {
        const { group: formGroup } = this.context(rowIndex);
        this.changes.emit({ action: 'cancel', rowIndex, formGroup, isNew: isNewRow(rowIndex) });
    }
    save(rowIndex) {
        const { group: formGroup } = this.context(rowIndex);
        this.changes.emit({ action: 'save', rowIndex, formGroup, isNew: isNewRow(rowIndex) });
    }
    remove(rowIndex) {
        this.changes.emit({ action: 'remove', rowIndex });
    }
    findByIndex(index) {
        return this.editedIndices.find(isEqual(index));
    }
    onChanged() {
        this.ngZone.runOutsideAngular(() => {
            this.changedSource.next();
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EditService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EditService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EditService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });

/**
 * @hidden
 */
const getGroupRowArgs = (groupItem) => {
    if (!isPresent(groupItem)) {
        return null;
    }
    return { group: groupItem.data, groupIndex: groupItem.index, parentGroup: getGroupRowArgs(groupItem.parentGroup) };
};

const isChildIndex = (targetIndex, parentIndex) => {
    const sameIndex = parentIndex === targetIndex;
    const lastSeparatorIndex = targetIndex.lastIndexOf('_');
    const sameSubGroupIndex = targetIndex.substring(0, lastSeparatorIndex) === parentIndex;
    return !sameIndex && sameSubGroupIndex;
};
/**
 * @hidden
 */
class GroupsService {
    changes = new Subject();
    userCallback;
    rowState = new Set();
    reset() {
        this.rowState.clear();
    }
    ngOnDestroy() {
        this.reset();
    }
    isExpanded(groupArgs) {
        if (this.userCallback) {
            return this.userCallback(groupArgs);
        }
        return !this.rowState.has(groupArgs.groupIndex);
    }
    isInExpandedGroup(groupItem) {
        let expanded = true;
        while (groupItem && expanded) {
            expanded = this.isExpanded({
                group: groupItem.data,
                groupIndex: groupItem.index,
                parentGroup: getGroupRowArgs(groupItem.parentGroup)
            });
            groupItem = groupItem.parentGroup;
        }
        return expanded;
    }
    toggleRow(groupItem, emit = true) {
        const parentGroup = getGroupRowArgs(groupItem.parentGroup);
        const expand = !this.isExpanded({ group: groupItem.data, groupIndex: groupItem.index, parentGroup });
        this.changes.next({ group: groupItem.data, expand, groupIndex: groupItem.index, parentGroup, emit });
        // if usercallback is given, the rowState should be ignored
        if (this.userCallback) {
            return;
        }
        if (expand) {
            this.rowState.delete(groupItem.index);
        }
        else {
            this.rowState.add(groupItem.index);
        }
    }
    expandChildren(parentIndex) {
        this.rowState.forEach(index => isChildIndex(index, parentIndex) && this.rowState.delete(index));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GroupsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GroupsService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GroupsService, decorators: [{
            type: Injectable
        }] });

/**
 * Arguments for the `detailCollapse` event.
 */
class DetailCollapseEvent extends PreventableEvent {
    /**
     * The collapsed row `dataItem`.
     */
    dataItem;
    /**
     * The collapsed row index.
     */
    index;
    constructor(args) {
        super();
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `detailExpand` event.
 */
class DetailExpandEvent extends PreventableEvent {
    /**
     * The expanded row `dataItem`.
     */
    dataItem;
    /**
     * The expanded row index.
     */
    index;
    constructor(args) {
        super();
        Object.assign(this, args);
    }
}

/**
 * @hidden
 */
class DetailsService {
    userCallback;
    changes = new Subject();
    rowState = new Set();
    ngOnDestroy() {
        this.rowState.clear();
    }
    isExpanded(index, dataItem) {
        if (this.userCallback) {
            return this.userCallback({ index, dataItem });
        }
        return this.rowState.has(index);
    }
    toggleRow(index, dataItem) {
        if (this.isExpanded(index, dataItem)) {
            this.collapseRow(index, dataItem);
        }
        else {
            this.expandRow(index, dataItem);
        }
    }
    expandRow(index, dataItem) {
        const prevented = this.emitEvent({ dataItem, index, expand: true });
        if (!prevented && !this.userCallback) {
            this.rowState.add(index);
        }
    }
    collapseRow(index, dataItem) {
        const prevented = this.emitEvent({ dataItem, index, expand: false });
        if (!prevented && !this.userCallback) {
            this.rowState.delete(index);
        }
    }
    emitEvent(args) {
        const eventArg = new (args.expand ? DetailExpandEvent : DetailCollapseEvent)(args);
        this.changes.next(eventArg);
        return eventArg.isDefaultPrevented();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DetailsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DetailsService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DetailsService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
class ScrollRequestService {
    requests = new Subject();
    scrollTo(request, adjustIndex = true) {
        this.requests.next({ request, adjustIndex });
    }
    scrollToItem(request) {
        this.requests.next({ request });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ScrollRequestService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ScrollRequestService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ScrollRequestService, decorators: [{
            type: Injectable
        }] });

const isInSameGrid = (element, gridElement) => closest(element, matchesNodeName('kendo-grid')) === gridElement;
const matchHeaderCell = matchesNodeName('th');
const matchDataCell = matchesNodeName('td');
const matchFooterCell = matchesNodeName('.k-grid-footer td');
const matchCell = (element) => matchDataCell(element) || matchHeaderCell(element) || matchFooterCell(element);
const gridCell = (element, gridElement) => {
    let target = closest(element, matchCell);
    while (target && !isInSameGrid(target, gridElement)) {
        target = closest(target.parentElement, matchCell);
    }
    return target;
};
const targetCell = (target, gridElement) => {
    const cell = gridCell(target, gridElement);
    const row = closest(cell, matchesNodeName('tr'));
    if (cell && row) {
        let rowIndex = row.getAttribute('aria-rowindex') || row.getAttribute('data-kendo-grid-row-index');
        rowIndex = rowIndex ? parseInt(rowIndex, 10) - 1 : null;
        let colIndex = cell.getAttribute('aria-colindex');
        colIndex = colIndex ? parseInt(colIndex, 10) - 1 : null;
        if (rowIndex !== null && colIndex !== null) {
            return { colIndex, rowIndex, element: cell };
        }
    }
};
const isArrowKey = keyCode => keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight ||
    keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown;
const isNavigationKey = keyCode => isArrowKey(keyCode) ||
    keyCode === Keys.PageUp || keyCode === Keys.PageDown ||
    keyCode === Keys.Home || keyCode === Keys.End;
const isInput = matchesNodeName('input');
const isTextInput = element => element && isInput(element) && element.type.toLowerCase() === 'text';
const isPrintableCharacter = (str) => str.length === 1 && str.match(/\S/);
/**
 * @hidden
 */
class NavigationViewport {
    firstItemIndex;
    lastItemIndex;
    constructor(firstItemIndex, lastItemIndex) {
        this.firstItemIndex = firstItemIndex;
        this.lastItemIndex = lastItemIndex;
    }
    containsRow(dataRowIndex) {
        const headerRow = dataRowIndex < 0;
        return headerRow || (dataRowIndex >= this.firstItemIndex && dataRowIndex <= this.lastItemIndex);
    }
    intersects(start, end) {
        return (start <= this.firstItemIndex && this.lastItemIndex <= end) ||
            (this.firstItemIndex <= start && start <= this.lastItemIndex) ||
            (this.firstItemIndex <= end && end <= this.lastItemIndex);
    }
}
/**
 * @hidden
 */
class NavigationService {
    zone;
    domEvents;
    pagerContextService;
    scrollRequestService;
    groupsService;
    detailsService;
    focusRoot;
    editService;
    cd;
    ctx;
    focusableParent;
    changes;
    cellKeydown = new EventEmitter();
    set metadata(value) {
        this.meta = value;
        this.cursor.metadata = value;
    }
    get metadata() {
        return this.meta;
    }
    get enabled() {
        return this.alive;
    }
    get pagerEnabled() {
        return this.alive && this.pagerIsNavigable;
    }
    get tableEnabled() {
        return this.alive && this.tableIsNavigable;
    }
    get toolbarEnabled() {
        return this.alive && this.toolbarIsNavigable;
    }
    get activeCell() {
        if (this.mode !== 0 /* NavigationMode.Standby */) {
            return this.cursor.cell;
        }
    }
    get activeRow() {
        if (this.mode !== 0 /* NavigationMode.Standby */) {
            return Object.assign({}, this.cursor.row, {
                cells: this.cursor.row?.cells.toArray()
            });
        }
    }
    viewport;
    columnViewport;
    activeRowIndex = 0;
    alive = false;
    active = true;
    mode = 0 /* NavigationMode.Standby */;
    model = new NavigationModel();
    cursor = new NavigationCursor(this.model);
    meta;
    subs;
    pendingRowIndex;
    virtualCell;
    pagerIsNavigable = false;
    tableIsNavigable = false;
    toolbarIsNavigable = false;
    get activeDataRow() {
        return Math.max(0, this.activeRowIndex - this.meta.headerRows);
    }
    constructor(zone, domEvents, pagerContextService, scrollRequestService, groupsService, detailsService, focusRoot, editService, cd, ctx, focusableParent) {
        this.zone = zone;
        this.domEvents = domEvents;
        this.pagerContextService = pagerContextService;
        this.scrollRequestService = scrollRequestService;
        this.groupsService = groupsService;
        this.detailsService = detailsService;
        this.focusRoot = focusRoot;
        this.editService = editService;
        this.cd = cd;
        this.ctx = ctx;
        this.focusableParent = focusableParent;
        this.changes = this.cursor.changes;
    }
    init(meta, navigableOptions) {
        this.setActiveSections(navigableOptions);
        this.alive = true;
        this.focusRoot.active = true;
        this.metadata = meta;
        const onStableSubscriber = (...operators) => (args) => this.zone.isStable ?
            from([true]).pipe(map(() => args)) :
            this.zone.onStable.pipe(take(1), map(() => args), ...operators);
        const onStable = onStableSubscriber();
        this.subs = new Subscription();
        this.subs.add(this.cursor.changes.subscribe(args => this.onCursorChanges(args)));
        this.subs.add(this.domEvents.focus.pipe(switchMap(onStable))
            .subscribe((args) => this.navigateTo(args.target)));
        this.subs.add(this.domEvents.focusOut.pipe(filter(() => this.mode !== 0 /* NavigationMode.Standby */), switchMap(onStableSubscriber(takeUntil(this.domEvents.focus))))
            .subscribe(args => this.onFocusOut(args)));
        this.subs.add(this.domEvents.windowBlur.pipe(filter(() => this.mode !== 0 /* NavigationMode.Standby */))
            .subscribe(() => this.onWindowBlur()));
        this.subs.add(
        // Closing the editor will not always trigger focusout in Firefox.
        // To get around this, we ensure that the cell is closed after editing.
        this.editService.changes.pipe(filter(e => e.action !== 'edit' && this.mode === 2 /* NavigationMode.Content */), filter((e) => e.action === 'cellClose' && !e.prevented), switchMap(onStable))
            .subscribe(() => this.leaveCell()));
        this.subs.add(this.pagerContextService.pageChange
            .subscribe(() => this.cursor.reset(0, 0)));
        this.subs.add(this.domEvents.keydown
            .subscribe(args => this.onKeydown(args)));
        this.subs.add(this.domEvents.keydown.pipe(filter(args => args.keyCode === Keys.Tab && this.mode === 2 /* NavigationMode.Content */), switchMapTo(this.domEvents.focusOut.pipe(takeUntil(
        // Timeout if focusOut doesn't fire very soon
        interval(0).pipe(take(1))))))
            .subscribe(() => this.onTabout()));
        if (this.focusableParent) {
            const element = new GridFocusableElement(this);
            this.focusableParent.registerElement(element);
        }
        this.deactivateElements();
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
        this.alive = false;
    }
    registerCell(cell) {
        if (cell.logicalRowIndex !== this.pendingRowIndex) {
            const modelCell = this.model.registerCell(cell);
            if (this.virtualCell && this.cursor.activateVirtualCell(modelCell)) {
                this.virtualCell = false;
            }
        }
    }
    registerCellOnCurrentRow(cell) {
        if (cell.logicalRowIndex === this.pendingRowIndex) {
            this.model.registerCell(cell);
        }
    }
    unregisterCell(index, rowIndex, cell) {
        this.model.unregisterCell(index, rowIndex, cell);
    }
    registerRow(row) {
        this.model.registerRow(row);
        this.pendingRowIndex = row.logicalRowIndex;
    }
    updateRow(row) {
        this.model.updateRow(row);
    }
    unregisterRow(index, row) {
        this.model.unregisterRow(index, row);
        const lastRow = this.model.lastRow;
        if (lastRow && this.mode === 0 /* NavigationMode.Standby */) {
            const maxIndex = (this.needsViewport() && this.viewport) ? this.viewport.lastItemIndex : lastRow.index;
            if (this.activeRowIndex > maxIndex) {
                this.cursor.reset(0, 0);
            }
        }
    }
    isCellFocusable(cell) {
        return this.alive &&
            this.active &&
            this.mode !== 2 /* NavigationMode.Content */ &&
            this.cursor.isActive(cell.logicalRowIndex, cell.logicalColIndex);
    }
    isCellFocused(cell) {
        return this.mode === 1 /* NavigationMode.Cursor */ && this.isCellFocusable(cell);
    }
    navigateTo(el) {
        if (!this.alive || !isDocumentAvailable()) {
            return;
        }
        const cell = targetCell(el, this.meta.gridElement.nativeElement);
        if (!cell) {
            return;
        }
        const oldMode = this.mode;
        const focusInCell = contains$1(cell.element, document.activeElement);
        const focusInActiveRowContent = this.mode === 2 /* NavigationMode.Content */ &&
            this.activeRowIndex === cell.rowIndex &&
            el !== cell.element;
        if (focusInCell) {
            this.mode = 2 /* NavigationMode.Content */;
            this.cursor.reset(cell.rowIndex, cell.colIndex);
            this.activateRow();
        }
        else if (!focusInActiveRowContent) {
            this.mode = 1 /* NavigationMode.Cursor */;
            this.deactivateElements();
            const alreadyActive = this.cursor.isActive(cell.rowIndex, cell.colIndex);
            const isCursor = oldMode === 1 /* NavigationMode.Cursor */ && alreadyActive;
            if (!isCursor) {
                this.cursor.reset(cell.rowIndex, cell.colIndex);
            }
        }
    }
    tryFocus(el) {
        this.activateElements();
        const focusable = findFocusableChild(el);
        if (focusable) {
            const cell = targetCell(focusable, this.meta.gridElement.nativeElement);
            if (cell) {
                this.cursor.reset(cell.rowIndex, cell.colIndex);
                this.deactivateElements();
                this.enterCell();
            }
            focusable.focus();
        }
        else {
            this.deactivateElements();
        }
        return !!focusable;
    }
    needsViewport() {
        return this.meta && this.meta.isVirtual;
    }
    setViewport(firstItemIndex, lastItemIndex) {
        this.viewport = new NavigationViewport(firstItemIndex, lastItemIndex);
        if (this.meta && this.meta.isVirtual && this.activeDataRow > -1) {
            const dataRowIndex = this.activeDataRow;
            const ahead = firstItemIndex - dataRowIndex;
            const behind = dataRowIndex - lastItemIndex;
            if (ahead > 0) {
                this.cursor.reset(firstItemIndex + this.meta.headerRows);
            }
            else if (behind > 0) {
                this.cursor.reset(lastItemIndex - this.meta.headerRows);
            }
        }
    }
    setColumnViewport(firstItemIndex, lastItemIndex) {
        this.columnViewport = new NavigationViewport(firstItemIndex, lastItemIndex);
        if (this.meta && this.meta.isVirtual && this.activeDataRow > -1) {
            const activeColumnIndex = this.cursor.cell ? this.cursor.cell.colIndex : 0;
            const ahead = firstItemIndex - activeColumnIndex;
            const behind = activeColumnIndex - lastItemIndex;
            if (ahead > 0) {
                this.cursor.reset(undefined, firstItemIndex, false);
            }
            else if (behind > 0) {
                this.cursor.reset(undefined, lastItemIndex, false);
            }
        }
    }
    focusCell(rowIndex = undefined, colIndex = undefined) {
        this.mode = 1 /* NavigationMode.Cursor */;
        this.cursor.reset(rowIndex, colIndex);
        return this.activeCell;
    }
    focusCellByElement(el) {
        const cell = targetCell(el, this.meta.gridElement.nativeElement);
        if (cell) {
            return this.focusCell(cell.rowIndex, cell.colIndex);
        }
    }
    focusNextCell(wrap = true) {
        return this.focusAdjacentCell(true, wrap);
    }
    focusPrevCell(wrap = true) {
        return this.focusAdjacentCell(false, wrap);
    }
    toggle(active) {
        this.active = active;
        this.cursor.announce();
    }
    hasFocus() {
        return this.mode === 1 /* NavigationMode.Cursor */ || this.mode === 2 /* NavigationMode.Content */;
    }
    autoFocusCell(start, end) {
        return !this.meta.virtualColumns || end < this.meta.columns.lockedLeafColumns.length || this.columnViewport.intersects(start, end);
    }
    setActiveSections(navigableOptions) {
        this.pagerIsNavigable = navigableOptions.includes('pager');
        this.tableIsNavigable = navigableOptions.includes('table');
        this.toolbarIsNavigable = navigableOptions.includes('toolbar');
    }
    focusAdjacentCell(fwd, wrap) {
        this.focusCell();
        let success = fwd ? this.moveCursorFwd() : this.moveCursorBwd();
        if (wrap && !success) {
            success = fwd ? this.cursor.moveDown(1) : this.cursor.moveUp(1);
            if (success) {
                const row = this.cursor.row;
                const colIdx = fwd ? 0 : this.cursor.lastCellIndex(row);
                this.cursor.reset(row.index, colIdx);
            }
        }
        if (success) {
            return this.activeCell;
        }
        else {
            this.mode = 0 /* NavigationMode.Standby */;
            this.cursor.announce();
        }
        return null;
    }
    enterCell() {
        const cell = this.cursor.cell;
        if (!cell) {
            return;
        }
        const group = cell.focusGroup;
        const focusable = group && group.canFocus();
        this.mode = focusable ? 2 /* NavigationMode.Content */ : 1 /* NavigationMode.Cursor */;
        this.cursor.announce();
        if (focusable) {
            this.activateRow();
            group.focus();
        }
    }
    leaveCell() {
        const cell = this.cursor.cell;
        if (!cell) {
            return;
        }
        const group = cell.focusGroup;
        const focusable = group && group.canFocus();
        if (!focusable) {
            this.deactivateElements();
        }
        this.mode = 1 /* NavigationMode.Cursor */;
        this.cursor.announce();
    }
    activateElements() {
        this.focusRoot.activate();
    }
    deactivateElements() {
        this.focusRoot.deactivate();
    }
    activateRow() {
        this.cursor.row.cells
            .forEach(cell => cell.focusGroup && cell.focusGroup.activate());
    }
    moveCursorFwd() {
        return this.ctx.localization.rtl ? this.cursor.moveLeft() : this.cursor.moveRight();
    }
    moveCursorBwd() {
        return this.ctx.localization.rtl ? this.cursor.moveRight() : this.cursor.moveLeft();
    }
    onCursorKeydown(args) {
        let preventDefault = false;
        const modifier = args.ctrlKey || args.metaKey;
        const step = modifier ? 5 : 1;
        if (!this.onCellKeydown(args)) {
            return;
        }
        const row = this.cursor.row;
        switch (args.keyCode) {
            case Keys.ArrowDown:
                if (args.shiftKey) {
                    if (this.ctx.grid.blockArrowSelection) {
                        return;
                    }
                    preventDefault = this.cursor.moveDown(step);
                    if (this.activeRow?.dataItem) {
                        this.handleVerticalArrowSelection(step);
                    }
                }
                else {
                    preventDefault = this.cursor.moveDown(step);
                }
                break;
            case Keys.ArrowUp:
                if (args.shiftKey) {
                    if (this.ctx.grid.blockArrowSelection) {
                        return;
                    }
                    preventDefault = this.cursor.moveUp(step);
                    if (this.activeRow?.dataItem) {
                        this.handleVerticalArrowSelection(-step);
                    }
                }
                else {
                    preventDefault = this.cursor.moveUp(step);
                }
                break;
            case Keys.ArrowRight:
                if (args.shiftKey) {
                    if (this.ctx.grid.blockArrowSelection) {
                        return;
                    }
                    preventDefault = this.moveCursorFwd();
                    this.handleHorizontalArrowSelection(args);
                }
                else {
                    preventDefault = this.moveCursorFwd();
                }
                break;
            case Keys.ArrowLeft:
                if (args.shiftKey) {
                    if (this.ctx.grid.blockArrowSelection) {
                        return;
                    }
                    preventDefault = this.moveCursorBwd();
                    this.handleHorizontalArrowSelection(args);
                }
                else {
                    preventDefault = this.moveCursorBwd();
                }
                break;
            case Keys.PageDown:
                if (this.metadata.isVirtual && this.viewport) {
                    let nextItemIndex = this.meta.headerRows + this.viewport.lastItemIndex + 1;
                    if (this.metadata.hasDetailTemplate) {
                        nextItemIndex++;
                    }
                    nextItemIndex = Math.min(this.meta.maxLogicalRowIndex, nextItemIndex);
                    this.cursor.reset(nextItemIndex);
                    preventDefault = true;
                }
                else if (this.metadata.hasPager) {
                    this.zone.run(() => this.pagerContextService.nextPage());
                    preventDefault = true;
                }
                break;
            case Keys.PageUp:
                if (this.metadata.isVirtual && this.viewport) {
                    const viewportSize = this.viewport.lastItemIndex - this.viewport.firstItemIndex;
                    const firstItemIndex = this.viewport.firstItemIndex;
                    const nextItemIndex = Math.max(this.meta.headerRows, firstItemIndex - viewportSize - 1);
                    this.cursor.reset(nextItemIndex);
                    preventDefault = true;
                }
                else if (this.metadata.hasPager) {
                    this.zone.run(() => this.pagerContextService.prevPage());
                    preventDefault = true;
                }
                break;
            case Keys.Home:
                if (modifier) {
                    if (this.meta.isVirtual) {
                        this.cursor.reset(this.meta.headerRows, 0, false);
                    }
                    else {
                        this.cursor.reset(this.model.firstRow.index, 0, false);
                    }
                }
                else {
                    let firstColumnIndex = 0;
                    if (this.meta.hasDetailTemplate && row.index < this.meta.headerRows) {
                        firstColumnIndex = 1;
                    }
                    this.cursor.reset(row.index, firstColumnIndex, false);
                }
                preventDefault = true;
                break;
            case Keys.End:
                if (modifier) {
                    if (this.meta.isVirtual) {
                        let lastRowIndex = this.meta.maxLogicalRowIndex;
                        if (this.meta.hasDetailTemplate) {
                            lastRowIndex--;
                        }
                        this.cursor.reset(lastRowIndex, this.cursor.lastCellIndex(), false);
                    }
                    else {
                        this.cursor.reset(this.model.lastRow.index, this.cursor.lastCellIndex(this.model.lastRow), false);
                    }
                }
                else {
                    const lastIndex = this.cursor.lastCellIndex(row);
                    const cell = this.model.findCell(lastIndex, row);
                    if (cell) {
                        this.cursor.reset(cell.rowIndex, cell.colIndex);
                    }
                    else {
                        this.cursor.reset(row.index, lastIndex);
                    }
                }
                preventDefault = true;
                break;
            case Keys.Enter:
            case Keys.F2: {
                const groupItem = row.groupItem;
                if (groupItem) {
                    this.zone.run(() => this.groupsService.toggleRow(groupItem));
                }
                else if (this.cursor.cell.detailExpandCell) {
                    this.zone.run(() => this.detailsService.toggleRow(row.dataRowIndex, row.dataItem));
                }
                else {
                    this.enterCell();
                    if (!this.cursor.cell.focusGroup.isNavigable()) {
                        preventDefault = true;
                    }
                }
                break;
            }
            default:
                if (!args.ctrlKey && !args.altKey && isPrintableCharacter(args.key)) {
                    this.enterCell();
                }
        }
        if (preventDefault) {
            args.preventDefault();
        }
    }
    onContentKeydown(args) {
        if (!this.onCellKeydown(args)) {
            return;
        }
        const confirm = !args.defaultPrevented && args.keyCode === Keys.Enter && isTextInput(args.srcElement);
        if (args.keyCode === Keys.Escape || args.keyCode === Keys.F2 || confirm) {
            this.leaveCell();
            this.cursor.reset();
            args.stopPropagation();
        }
        else if (isNavigationKey(args.keyCode) && this.cursor.cell.focusGroup.isNavigable()) {
            this.onCursorKeydown(args);
            if (args.defaultPrevented) {
                this.leaveCell();
            }
        }
    }
    onCellKeydown(args) {
        if (this.editService.isEditingCell()) {
            const confirm = args.keyCode === Keys.Enter;
            const cancel = args.keyCode === Keys.Escape;
            const navigate = isNavigationKey(args.keyCode);
            if (confirm) {
                this.editService.closeCell(args);
            }
            else if (cancel) {
                this.editService.closeCell(args);
                this.cd.detectChanges();
            }
            else if (navigate) {
                return false;
            }
        }
        this.cellKeydown.emit(args);
        return true;
    }
    onCursorChanges(args) {
        this.activeRowIndex = args.rowIndex;
        const dataRowIndex = this.activeDataRow;
        if (this.meta && (this.meta.isVirtual &&
            args.rowIndex >= this.meta.headerRows &&
            this.viewport &&
            !this.viewport.containsRow(dataRowIndex) && dataRowIndex > -1)) {
            this.scrollRequestService.scrollTo({ row: dataRowIndex });
        }
        if (this.meta.virtualColumns && args.colIndex >= this.meta.columns.lockedLeafColumns.length) {
            const cell = this.activeCell;
            const { start, end } = this.model.cellRange(cell);
            if (!cell) {
                this.virtualCell = true;
            }
            if ((!cell && this.mode !== 0 /* NavigationMode.Standby */) || (cell && !this.columnViewport.intersects(start, end))) {
                this.scrollRequestService.scrollTo({ column: args.colIndex - (this.metadata.hasDetailTemplate ? 1 : 0) });
            }
        }
    }
    onFocusOut(args) {
        if (isVisible(args.target)) {
            this.mode = 0 /* NavigationMode.Standby */;
        }
        else {
            // Focused target is no longer visible,
            // reset to cursor mode and recapture focus.
            this.mode = 1 /* NavigationMode.Cursor */;
        }
        this.deactivateElements();
        this.cursor.announce();
    }
    onWindowBlur() {
        this.mode = 0 /* NavigationMode.Standby */;
        this.deactivateElements();
        this.cursor.announce();
    }
    onKeydown(args) {
        if (this.mode === 1 /* NavigationMode.Cursor */) {
            this.onCursorKeydown(args);
        }
        else if (this.mode === 2 /* NavigationMode.Content */) {
            this.onContentKeydown(args);
        }
    }
    onTabout() {
        // Tabbed out of the last focusable content element
        // reset to cursor mode and recapture focus.
        if (this.cursor.cell.focusGroup.isNavigable()) {
            // Unless the cell has a single focusable element,
            // otherwise we'd return to Content mode and enter an endless loop
            return;
        }
        this.leaveCell();
        this.cursor.reset();
    }
    handleVerticalArrowSelection(args) {
        const cellSelectionEnabled = this.ctx.grid.cellSelectionService.active;
        const rowSelectionEnabled = this.ctx.grid.selectionService.active && !this.ctx.grid.selectableSettings.checkboxOnly;
        if (cellSelectionEnabled || rowSelectionEnabled) {
            const selectionService = this.ctx.grid[cellSelectionEnabled ? 'cellSelectionService' : 'selectionService'];
            const colIdx = this.cursor.cell ? this.cursor.cell.colIndex : 0;
            const rowIdx = this.activeRow.dataRowIndex - this.ctx.grid.skip;
            const dataItem = selectionService.settings.view.at(rowIdx);
            const item = { index: this.activeRow.dataRowIndex, data: dataItem, column: this.ctx.grid.columnsContainer.leafColumnsToRender[colIdx] };
            if (selectionService.options.mode === 'multiple') {
                cellSelectionEnabled ? this.handleMultipleArrowCellSelection(item) : this.handleMultipleArrowRowSelection(item);
            }
            else {
                selectionService.handleClick(item, args);
            }
        }
    }
    handleHorizontalArrowSelection(args) {
        const cellSelectionEnabled = this.ctx.grid.cellSelectionService.active;
        if (cellSelectionEnabled) {
            const selectionService = this.ctx.grid[cellSelectionEnabled ? 'cellSelectionService' : 'selectionService'];
            const row = this.activeRow;
            const colIdx = this.cursor.cell ? this.cursor.cell.colIndex : 0;
            const dataItem = selectionService.settings.view.at(row.dataRowIndex - this.ctx.grid.skip);
            const item = { index: row.dataRowIndex, data: dataItem, column: this.ctx.grid.columnsContainer.leafColumnsToRender[colIdx] };
            if (!isPresent$1(dataItem) || !isPresent$1(item.column)) {
                return;
            }
            if (selectionService.options.mode === 'multiple') {
                this.handleMultipleArrowCellSelection(item);
            }
            else {
                selectionService.handleClick(item, args);
            }
        }
    }
    handleMultipleArrowCellSelection(item) {
        const cellSelectionService = this.ctx.grid.cellSelectionService;
        const startRowIndex = Math.min(cellSelectionService.lastSelectionItemRowIndex, item.index);
        const startColIndex = Math.min(cellSelectionService.lastSelectionItemColIndex, item.column.leafIndex);
        const endRowIndex = Math.max(cellSelectionService.lastSelectionItemRowIndex, item.index);
        const endColIndex = Math.max(cellSelectionService.lastSelectionItemColIndex, item.column.leafIndex);
        const ev = cellSelectionService.selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex);
        cellSelectionService.changes.emit(ev);
    }
    handleMultipleArrowRowSelection(item) {
        const rowSelectionService = this.ctx.grid.selectionService;
        const startRowIndex = Math.min(rowSelectionService.lastSelectionStartIndex, item.index);
        const endRowIndex = Math.max(rowSelectionService.lastSelectionStartIndex, item.index);
        const ev = rowSelectionService.selectRange(startRowIndex, endRowIndex);
        rowSelectionService.changes.emit(ev);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NavigationService, deps: [{ token: i0.NgZone }, { token: DomEventsService }, { token: i42.PagerContextService }, { token: ScrollRequestService }, { token: GroupsService }, { token: DetailsService }, { token: FocusRoot }, { token: EditService }, { token: i0.ChangeDetectorRef }, { token: ContextService }, { token: FocusableDirective, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NavigationService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NavigationService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: DomEventsService }, { type: i42.PagerContextService }, { type: ScrollRequestService }, { type: GroupsService }, { type: DetailsService }, { type: FocusRoot }, { type: EditService }, { type: i0.ChangeDetectorRef }, { type: ContextService }, { type: FocusableDirective, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * @hidden
 */
const preventOnDblClick$1 = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));
const hasClass = className => el => new RegExp(`(^| )${className}( |$)`).test(el.className);
const isDeleteButton = or(hasClass('k-i-x'), hasClass('k-svg-i-x'), hasClass('k-icon-button'));
const isSortIcon = or(hasClass('k-i-sort-asc-small'), hasClass('k-i-sort-desc-small'), hasClass('k-svg-i-sort-asc-small'), hasClass('k-svg-i-sort-desc-small'));
const skipButtons = and(not(isDeleteButton), not(isSortIcon), not(isFocusableWithTabKey), not(matchesNodeName('label')));
const elementUnderCursor = ({ clientX, clientY }) => isDocumentAvailable() && document.elementFromPoint(clientX, clientY);
const hideThenShow = (element, cont) => {
    element.style.display = 'none';
    const result = cont();
    element.style.display = 'block';
    return result;
};
/**
 * @hidden
 */
class DraggableColumnDirective {
    draggable;
    element;
    zone;
    service;
    hint;
    cue;
    nav;
    renderer;
    context = {};
    set enableDrag(enabled) {
        this.enabled = enabled;
        this.updateTouchAction();
    }
    drag = new EventEmitter();
    get hostClass() {
        return this.enabled;
    }
    subscriptions = new Subscription();
    enabled;
    constructor(draggable, element, zone, service, hint, cue, nav, renderer) {
        this.draggable = draggable;
        this.element = element;
        this.zone = zone;
        this.service = service;
        this.hint = hint;
        this.cue = cue;
        this.nav = nav;
        this.renderer = renderer;
    }
    ngOnInit() {
        this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(filter(_ => this.enabled), filter(({ originalEvent: { target } }) => target === this.element.nativeElement || skipButtons(target)), tap((e) => {
            const originalEvent = e.originalEvent;
            if (!e.isTouch) {
                originalEvent.preventDefault();
            }
            this.nav.navigateTo(originalEvent.target);
        }), switchMap(preventOnDblClick$1(this.draggable.kendoRelease)), tap((_) => {
            this.hint.create(this.context.hint);
            this.cue.create();
        }), switchMap(down => this.draggable.kendoDrag.pipe(tap((e) => {
            if (e.isTouch) {
                e.originalEvent.preventDefault();
            }
        }), tap(this.hint.attach()), tap(this.cue.attach()), takeUntil(this.draggable.kendoRelease), map(move => ({ move, down })))), tap(this.performDrag.bind(this)), switchMapTo(this.draggable.kendoRelease)).subscribe(this.drop.bind(this))));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    drop(upEvent) {
        this.hint.remove();
        this.cue.remove();
        this.service.notifyDrop(this, upEvent);
    }
    performDrag({ move }) {
        this.hint.move(move);
        const cursorElement = this.elementUnderCursor(move);
        if (cursorElement) {
            this.service.notifyDrag(this, cursorElement, move);
        }
        this.drag.emit({
            draggable: this,
            mouseEvent: move
        });
    }
    elementUnderCursor(mouseEvent) {
        this.hint.hide();
        let target = elementUnderCursor(mouseEvent);
        if (target && /k-grouping-dropclue/.test(target.className)) {
            target = hideThenShow(target, elementUnderCursor.bind(this, mouseEvent));
        }
        this.hint.show();
        return target;
    }
    updateTouchAction() {
        if (!this.element) {
            return;
        }
        // eslint-disable-next-line no-unused-expressions
        this.enabled ? this.renderer.addClass(this.element.nativeElement, 'k-touch-action-none') :
            this.renderer.removeClass(this.element.nativeElement, 'k-touch-action-none');
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DraggableColumnDirective, deps: [{ token: i1$3.DraggableDirective, host: true }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: DragAndDropService }, { token: DragHintService }, { token: DropCueService }, { token: NavigationService }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: DraggableColumnDirective, isStandalone: true, selector: "[kendoDraggableColumn]", inputs: { context: "context", enableDrag: "enableDrag" }, outputs: { drag: "drag" }, host: { properties: { "class.k-grid-draggable-header": "this.hostClass" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DraggableColumnDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoDraggableColumn]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i1$3.DraggableDirective, decorators: [{
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: DragAndDropService }, { type: DragHintService }, { type: DropCueService }, { type: NavigationService }, { type: i0.Renderer2 }]; }, propDecorators: { context: [{
                type: Input
            }], enableDrag: [{
                type: Input
            }], drag: [{
                type: Output
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-grid-draggable-header']
            }] } });

/**
 * @hidden
 */
class DropTargetDirective {
    element;
    service;
    context = {};
    enter = new EventEmitter();
    leave = new EventEmitter();
    drop = new EventEmitter();
    subscriptions = new Subscription();
    constructor(element, service) {
        this.element = element;
        this.service = service;
    }
    ngOnInit() {
        this.service.add(this);
        const changes = this.service.changes.pipe(filter(({ target }) => target === this));
        this.subscriptions.add(changes.pipe(filter(({ type }) => type === 'leave'))
            .subscribe(e => {
            this.leave.next(this.eventArgs(e));
        }));
        this.subscriptions.add(changes.pipe(filter(({ type }) => type === 'enter'))
            .subscribe(e => {
            this.enter.next(this.eventArgs(e));
        }));
        this.subscriptions.add(changes.pipe(filter(({ type }) => type === 'drop'))
            .subscribe(e => {
            this.drop.next(this.eventArgs(e));
        }));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    eventArgs(e) {
        return {
            target: this,
            mouseEvent: e.mouseEvent,
            draggable: e.draggable
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DropTargetDirective, deps: [{ token: i0.ElementRef }, { token: DragAndDropService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: DropTargetDirective, isStandalone: true, selector: "[kendoDropTarget]", inputs: { context: "context" }, outputs: { enter: "enter", leave: "leave", drop: "drop" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DropTargetDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoDropTarget]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: DragAndDropService }]; }, propDecorators: { context: [{
                type: Input
            }], enter: [{
                type: Output
            }], leave: [{
                type: Output
            }], drop: [{
                type: Output
            }] } });

/**
 * Represents the column cell template of the Grid.
 * Helps to customize the content of the cells. To define the cell template, nest an `<ng-template>` tag with the
 * `kendoGridCellTemplate` directive inside a `<kendo-grid-column>` tag [see example](slug:templates_columns_grid#toc-cell-template).
 *
 * The template context is set to the current data item and the following additional fields are passed:
 * - `columnIndex`&mdash;The current column index. Use it as an alias for a template variable by utilizing the `let-columnIndex="columnIndex"` syntax.
 * - `rowIndex`&mdash;The current data row index. Use it as an alias for a template variable by utilizing the `let-rowIndex="rowIndex"` syntax.
 * - `dataItem`&mdash;The current data item. Represents the default context that will be assigned to any template variable which utilizes the `let-x` syntax&mdash;for example, `let-dataItem`.
 * - `column`&mdash;The current column instance. Use it as an alias for a template variable by utilizing the `let-column="column"` syntax.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData" ...>
 *   <kendo-grid-column field="ProductName">
 *     <ng-template kendoGridCellTemplate let-dataItem let-rowIndex="rowIndex" let-column="column">
 *       Data Row: {{rowIndex}}
 *     </ng-template>
 *   </kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class CellTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CellTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: CellTemplateDirective, isStandalone: true, selector: "[kendoGridCellTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CellTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridCellTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the group-header cell template of the Grid which helps to customize the content of the group header item.
 * To define the group header template, nest an `<ng-template>` tag with the `kendoGridGroupHeaderTemplate`
 * directive inside `<kendo-grid-column>`. ([See example](slug:grouping_grid_templates#toc-header-template)).
 *
 * The template context is set to the current data item and the following additional fields are passed:
 * - `group`&mdash;The current group item.
 * - `field`&mdash;The name of the field by which data is grouped.
 * - `value`&mdash;The current group value.
 * - `aggregates`&mdash;All aggregate values for the current group.
 * - `index`&mdash;The index of the current group.
 * - `expanded`&mdash;A boolean value indicating if the group is currently expanded.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData" [group]="groups">
 *    <kendo-grid-column field="ProductName">
 *       <ng-template kendoGridGroupHeaderTemplate let-group let-field="field" let-value="value">
 *          <strong>{{field}}</strong>: {{value}}
 *       </ng-template>
 *    </kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class GroupHeaderTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GroupHeaderTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: GroupHeaderTemplateDirective, isStandalone: true, selector: "[kendoGridGroupHeaderTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GroupHeaderTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridGroupHeaderTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the group-header column template of the Grid which helps to customize the content of the group headers.
 * To define the group header template, nest an `<ng-template>` tag with the `kendoGridGroupHeaderColumnTemplate`
 * directive inside `<kendo-grid-column>`. ([See example](slug:grouping_grid_templates#toc-header-column-template)).
 *
 * The template context is set to the current data item and the following additional fields are passed:
 * - `group`&mdash;The current group item.
 * - `field`&mdash;The name of the field by which data is grouped.
 * - `value`&mdash;The current group value.
 * - `aggregates`&mdash;All aggregate values for the current group.
 *
 * @example
 * ```html
 * <kendo-grid-column field="ProductName" title="Product Name">
 *     <ng-template kendoGridGroupHeaderColumnTemplate let-group="group" let-aggregates="aggregates">
 *         <span title="Group Header Column Template for ProductName">
 *             Count: {{ aggregates.Discontinued.count }}
 *         </span>
 *     </ng-template>
 * </kendo-grid-column>
 * ```
 */
class GroupHeaderColumnTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GroupHeaderColumnTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: GroupHeaderColumnTemplateDirective, isStandalone: true, selector: "[kendoGridGroupHeaderColumnTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GroupHeaderColumnTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridGroupHeaderColumnTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the column edit-cell template of the Grid ([see example](slug:custom_reactive_editing_grid#toc-setting-up-custom-inputs)).
 * Helps to customize the content of the edited cells. To define the cell template, nest an `<ng-template>`
 * tag with the `kendoGridEditTemplate` directive inside a `<kendo-grid-column>` tag.
 *
 * The template context is set to the current form group and the following additional fields are passed:
 * - `formGroup`&mdash;The current [FormGroup](link:site.data.urls.angular['formgroupapi']). Represents the default context that will be assigned to any template variable which utilizes the `let-x` syntax, for example, `let-formGroup`. If you use the Grid inside [Template-Driven Forms](link:site.data.urls.angular['forms']), it will be `undefined`.
 * - `rowIndex`&mdash;The current data row index. If inside a new item row, `rowIndex` is `-1`. Use it as an alias for a template variable by utilizing the `let-rowIndex="rowIndex"` syntax.
 * - `dataItem`&mdash;The current data item. Use it as an alias for a template variable by utilizing the `let-dataItem="dataItem"` syntax.
 * - `column`&mdash;The current column instance. Use it as an alias for a template variable by utilizing the `let-column="column"` syntax.
 * - `isNew`&mdash;The state of the current item. Use it as an alias for a template variable by utilizing the `let-isNew="isNew"` syntax.
 */
class EditTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EditTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: EditTemplateDirective, isStandalone: true, selector: "[kendoGridEditTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EditTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridEditTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the column group footer cell template of the Grid which helps to customize the group footer cell for the column.
 * To define the group footer template, nest an `<ng-template>` tag with the `kendoGridGroupFooterTemplate` directive
 * inside `<kendo-grid-column>`.
 *
 * The template context is set to the current data item and the following additional fields are passed:
 * - `column`&mdash;Defines an instance of the `ColumnComponent` option.
 * - `field`&mdash;The current column field name.
 * - `group`&mdash;The current group data item.
 * - `aggregates`&mdash;All aggregate values for the current group.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData" [group]="groups">
 *    <kendo-grid-column field="ProductName">
 *       <ng-template kendoGridGroupFooterTemplate let-aggregates let-field="field">
 *          Count: {{aggregates[field].count}}
 *       </ng-template>
 *    </kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class GroupFooterTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GroupFooterTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: GroupFooterTemplateDirective, isStandalone: true, selector: "[kendoGridGroupFooterTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GroupFooterTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridGroupFooterTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the column header cell template of the Grid
 * ([more information and example]({% slug templates_columns_grid %}#toc-header-template)).
 * Helps to customize the table header cell for the column.
 * To define a header template, nest an `<ng-template>` tag with the
 * `kendoGridHeaderTemplate` directive inside the `<kendo-grid-column>` tag.
 *
 *  The template context is set to the current column and then the following additional fields are passed:
 * * `column`&mdash;Defines an instance of the [ColumnComponent]({% slug api_grid_columncomponent %}) option.
 * * `columnIndex`&mdash;Defines the current column index.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData">
 *    <kendo-grid-column field="ProductName">
 *       <ng-template kendoGridHeaderTemplate let-column let-columnIndex="columnIndex">
 *          {{column.field}}({{columnIndex}})
 *       </ng-template>
 *    </kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class HeaderTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: HeaderTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: HeaderTemplateDirective, isStandalone: true, selector: "[kendoGridHeaderTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: HeaderTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridHeaderTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the column footer cell template of the Grid
 * ([more information and example]({% slug templates_columns_grid %}#toc-footer-template)).
 * Helps to customize the table footer cell for the column.
 * To define a footer template, nest an `<ng-template>` tag with the
 * [kendoGridFooterTemplate]({% slug api_grid_footertemplatedirective %}) directive inside the `<kendo-grid-column>` tag.
 *
 * The template context is set to the current column and the following additional fields are passed:
 * * `column`&mdash;Defines an instance of the [ColumnComponent]({% slug api_grid_columncomponent %}) option.
 * * `columnIndex`&mdash;Defines the current column index.
 *
 * For more information on how to display aggregates in the footer of the Grid,
 * refer to the article on [aggregates]({% slug groupable_grid_with_aggregates %}).
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData" scrollable="none">
 *    <kendo-grid-column field="ProductName">
 *       <ng-template kendoGridFooterTemplate let-column let-columnIndex="columnIndex">
 *          {{column.field}}({{columnIndex}})
 *       </ng-template>
 *    </kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class FooterTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FooterTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: FooterTemplateDirective, isStandalone: true, selector: "[kendoGridFooterTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FooterTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridFooterTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the template for the column menu in the Grid. Provides an option for
 * customizing the content of the column menu for all or for specific columns.
 * To define the content template, nest an `<ng-template>` tag with the
 * `kendoGridColumnMenuTemplate` directive inside the `<kendo-grid>` or the `<kendo-grid-column>` component.
 *
 * The template context is passes through the following fields:
 * - `service`&mdash;Represents the [ColumnMenuService]({% slug api_grid_columnmenuservice %}).
 * - `column`&mdash;Represents the Grid column.
 *
 * @example
 * ```html
 * <kendo-grid [kendoGridBinding]="data" [sortable]="true" [columnMenu]="true">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-sort [service]="service"></kendo-grid-columnmenu-sort>
 *   </ng-template>
 *   <kendo-grid-column field="Field1">
 *     <ng-template kendoGridColumnMenuTemplate let-service="service">
 *       <kendo-grid-columnmenu-lock [service]="service"></kendo-grid-columnmenu-lock>
 *       <kendo-grid-columnmenu-sort [service]="service"></kendo-grid-columnmenu-sort>
 *     </ng-template>
 *   </kendo-grid-column>
 *   <kendo-grid-column field="Field2"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class ColumnMenuTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: ColumnMenuTemplateDirective, isStandalone: true, selector: "[kendoGridColumnMenuTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridColumnMenuTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

// Incremented each time the service is instantiated.
let sequence = 0;
/**
 * @hidden
 */
class IdService {
    prefix;
    constructor() {
        this.prefix = `k-grid${sequence++}`;
    }
    gridId() {
        return this.prefix;
    }
    cellId(rowIndex, colIndex) {
        return `${this.prefix}-r${rowIndex}c${colIndex}`;
    }
    selectionCheckboxId(itemIndex) {
        return `${this.prefix}-checkbox${itemIndex}`;
    }
    selectAllCheckboxId() {
        return `${this.prefix}-select-all`;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IdService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IdService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IdService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });

/**
 * @hidden
 */
const ColumnMenuErrorMessages = {
    autoSizeColumn: `The auto size column does not work with enabled virtual columns.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-autosize-column-item.`,
    autoSizeAllColumns: `The auto size all columns does not work with enabled virtual columns.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-autosize-all-columns-item.`,
    serviceInput: `The service input of the predefined column menu components is mandatory.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-customizing-the-content.`
};
/**
 * @hidden
 */
const ClipboardErrorMessages = {
    activeCellNavigable: `Grid must be navigable to use "activeCell" as clipboard target type.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/clipboard/#toc-active-cell.`,
    selectionSelectable: `Grid must be selectable to use "selection" as clipboard target type.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/clipboard/#toc-current-selection.`
};
/**
 * @hidden
 */
const ColumnConfigurationErrorMessages = {
    fieldName: (field) => `Grid column field name '${field}' does not look like a valid JavaScript identifier.
        Identifiers can contain only alphanumeric characters (including "$" or "_"), and may not start with a digit.
        Please use only valid identifier names to ensure error-free operation.`,
    width: (value, parsedValue) => `Expected numeric value for column width, but got a string "${value}". Treating as ${parsedValue}px.`,
    invalidColumn: (column) => `Invalid column ${column}.`,
    requiredWidth: (columnType) => `${columnType} columns feature requires all columns to have set width.
    See https://www.telerik.com/kendo-angular-ui/components/grid/columns/${columnType.toLowerCase()}.`,
    requiredScroll: (columnType) => `${columnType} columns are only supported when scrolling is enabled.
    See https://www.telerik.com/kendo-angular-ui/components/grid/columns/${columnType.toLowerCase()}/`,
    groupColumnContent: 'ColumnGroupComponent should contain ColumnComponent or CommandColumnComponent.',
    lockedParent: 'Locked child columns require their parent columns to be locked.',
    columnNested: 'Columns can be nested only inside ColumnGroupComponent',
    nestedInside: (nestedColumnNameType, parentColumnType) => `${nestedColumnNameType} cannot be nested inside ${parentColumnType}.`
};
/**
 * @hidden
 */
const GridConfigurationErrorMessages = {
    functionType: (propName, fn) => `${propName} must be a function, but received ${JSON.stringify(fn)}.`,
    incompatibleFeatures: (feat1Name, feat2Name) => `'Having both ${feat1Name} and ${feat2Name} is not supported.'`,
    nonLockedColumnPresent: 'There should be at least one non-locked column. See https://www.telerik.com/kendo-angular-ui/components/grid/columns/locked/#toc-known-limitations',
    rowHeightVirtual: `The virtual scrolling functionality requires setting the rowHeight (and detailRowHeight when there are detail rows).
        Row height and detail row height settings should be set only when virtual scrolling mode is enabled.
        See https://www.telerik.com/kendo-angular-ui/components/grid/scroll-modes/virtual/#toc-getting-started.`,
    focusNavigable: 'The Grid should be configured as navigable to control focus. See https://www.telerik.com/kendo-angular-ui/components/grid/keyboard-navigation/.',
    expandCollapseMethods: (expandMethodName, collapseMethodName, directiveName, callbackName) => `The ${expandMethodName} and ${collapseMethodName} methods should not be called
        when using the ${directiveName} directive or the ${callbackName} callback.
        These methods are provided only for backwards compatibility with legacy versions.`,
    requiredEditService: `The default edit service of the editing directives works only when binding to plain array.
        Please provide an editService. See https://www.telerik.com/kendo-angular-ui/components/grid/editing/editing-directives/#toc-custom-editing-service.`,
    requiredModule: (exportedType, moduleName, componentSelector) => `Creating ${exportedType} requires including the ${moduleName} and adding the ${componentSelector} component.`,
    groupBindingDirectives: `Using the "kendoGridGroupBinding" directive in combination with the "kendoGridExpandGroupBy" directive
        or the "isGroupExpanded" callback is not supported. To use grouping with the "kendoGridGroupBinding" directive,
        set the Grid "groupable" property to "true".`,
    unsupportedMethod: (methodName, suggestedMethodName) => `Using ${methodName} in this context is not supported. Use ${suggestedMethodName} instead.`,
    unsupportedToolbarConfig: `
        Defining both a toolbar template and a ToolBarComponent within the Grid is not supported.
        Please use either the ToolBarComponent or a custom template.`
};

/**
 * @hidden
 */
const isSpanColumn = column => column.isSpanColumn;
/**
 * @hidden
 */
const isCheckboxColumn = column => column.isCheckboxColumn;
/**
 * @hidden
 */
const isRowReorderColumn = column => column.isRowReorderColumn;
const isColumnContainer = column => column.isColumnGroup || isSpanColumn(column);
/**
 * The base class for the column components of the Grid.
 */
class ColumnBase {
    parent;
    /**
     * @hidden
     */
    matchesMedia = true;
    /**
     * The column index after reordering. The `orderIndex` is a read-only property. Setting this field does not affect column order.
     *
     * @default 0
     */
    orderIndex = 0;
    /**
     * @hidden
     */
    set leafIndex(value) {
        this._leafIndex = value;
    }
    /**
     * @hidden
     */
    get leafIndex() {
        return this._leafIndex;
    }
    _leafIndex;
    /**
     * @hidden
     */
    isColumnGroup = false;
    /**
     * @hidden
     */
    isSpanColumn = false;
    /**
     * Indicates whether the column is resizable.
     * @default true
     */
    resizable = true;
    /**
     * Indicates whether the column is reorderable.
     * @default true
     */
    reorderable = true;
    /**
     * The width (in pixels) below which the user is not able to resize the column by using the UI ([see example]({% slug resizing_columns_grid %}#toc-limiting-the-resizing)).
     * The `autoFitColumn` and `autoFitColumns` methods have higher priority.
     * @default 10
     */
    minResizableWidth = 10;
    /**
     * The width (in pixels) above which the user is not able to resize the column by using the UI ([see example]({% slug resizing_columns_grid %}#toc-limiting-the-resizing)).
     * By default, the maximum width is not restricted.
     * The `autoFitColumn` and `autoFitColumns` methods have higher priority.
     */
    maxResizableWidth;
    /**
     * The title of the column.
     */
    title;
    /**
     * The width of the column (in pixels).
     */
    set width(value) {
        if (typeof value === 'string') {
            const parsedValue = this._width = parseInt(value, 10);
            if (isDevMode()) {
                console.warn(ColumnConfigurationErrorMessages.width(value, parsedValue));
            }
        }
        else {
            this._width = value;
        }
    }
    get width() { return this._width; }
    /**
     * Indicates whether the column will be resized during initialization so that it fits its header and row content.
     */
    autoSize;
    /**
     * Toggles the locked (frozen) state of the columns ([more information and example]({% slug locked_columns_grid %})).
     *
     * @default false
     *
     */
    set locked(value) {
        this._locked = value;
    }
    get locked() {
        return this._locked;
    }
    _locked = false;
    /**
     * Determines whether the column will be always visible when scrolling the Grid horizontally.
     *
     * @default false
     */
    sticky = false;
    /**
     * Sets the visibility of the column ([see example](slug:hidden_columns_grid#toc-using-the-built-in-options)).
     *
     * @default false
     */
    hidden;
    /**
     * Sets the condition that needs to be satisfied for a column to remain visible ([see example]({% slug styling_responsive_grid %}#toc-columns)).
     * If you set the `hidden` property, the behavior of `media` is overridden.
     *
     * Accepts the device identifiers that are [available in Bootstrap 4](https://v4-alpha.getbootstrap.com/layout/grid/#grid-options)
     * ([see example](slug:styling_responsive_grid)):
     */
    media;
    /**
     * Specifies if the column can be locked or unlocked from the column menu or by reordering the columns.
     * @default true
     */
    lockable = true;
    /**
     * Specifies if the column can be stuck or unstuck from the column menu.
     * @default true
     */
    stickable = true;
    /**
     * Specifies if the column menu will be shown for the column.
     * @default true
     */
    columnMenu = true;
    /**
     * Specifies if the column will be included in the column-chooser list.
     * @default true
     */
    includeInChooser = true;
    /**
     * Allows setting the `role` attribute for the table cells (excluding the footer and header ones) of the column.
     * @default "gridcell"
     */
    tableCellsRole = 'gridcell';
    /**
     * Sets the custom styles for the table cells (excluding the footer and header ones) of the column. Under the hood,
     * to apply the property, the `style` option uses the
     * [NgStyle](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-cells).
     *
     */
    style;
    /**
     * Sets the custom styles for the header cell of the column. Under the hood, to apply the property,
     * the `headerStyle` option uses the
     * [NgStyle](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-header).
     *
     */
    headerStyle;
    /**
     * Sets the custom styles for the filter row cell. Under the hood, to apply the property,
     * the `filterStyle` option uses the
     * [NgStyle](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-filter-row-cells).
     *
     */
    filterStyle;
    /**
     * Sets the custom styles for the footer cell of the column. Under the hood, to apply the property,
     * the `footerStyle` option uses the
     * [NgStyle](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-footer).
     *
     */
    footerStyle;
    /**
     * Sets the custom CSS classes to the column cells. Under the hood, to apply the property, the `class` option uses the
     * [NgClass](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-cells).
     * To customize header and footer column cells, use the [headerClass]({% slug api_grid_columncomponent %}#toc-headerclass)
     * and [footerClass]({% slug api_grid_columncomponent %}#toc-footerclass) inputs.
     *
     */
    cssClass;
    /**
     * Sets the custom CSS classes to the column header cell. Under the hood, to apply the property,
     * the `headerClass` option uses the
     * [NgClass](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-header).
     *
     */
    headerClass;
    /**
     * Sets the custom CSS classes to the filter row cell. Under the hood, to apply the property,
     * the `filterClass` option uses the
     * [NgClass](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-filter-row-cells).
     *
     */
    filterClass;
    /**
     * Sets the custom CSS classes to the column footer cell. Under the hood, to apply the property,
     * the `footerClass` option uses the
     * [NgClass](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-footer).
     *
     */
    footerClass;
    /**
     * @hidden
     */
    headerTemplates = new QueryList();
    /**
     * @hidden
     */
    footerTemplate;
    /**
     * @hidden
     */
    columnMenuTemplates = new QueryList();
    /**
     * @hidden
     */
    resizeStartWidth;
    /**
     * @hidden
     */
    idService;
    /**
     * @hidden
     */
    implicitWidth;
    /**
     * @hidden
     */
    get level() {
        if (this.parent && isSpanColumn(this.parent)) {
            return this.parent.level;
        }
        return this.parent ? this.parent.level + 1 : 0;
    }
    /**
     * @hidden
     */
    get isLocked() {
        return this.parent ? this.parent.isLocked : this.locked;
    }
    _width;
    /**
     * @hidden
     */
    get colspan() {
        return 1;
    }
    /**
     * @hidden
     */
    rowspan(totalColumnLevels) {
        return this.level < totalColumnLevels ? (totalColumnLevels - this.level) + 1 : 1;
    }
    /**
     * @hidden
     */
    get headerTemplateRef() {
        const template = this.headerTemplates.first;
        return template ? template.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get footerTemplateRef() {
        return this.footerTemplate ? this.footerTemplate.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get columnMenuTemplateRef() {
        const template = this.columnMenuTemplates.first;
        return template ? template.templateRef : null;
    }
    /**
     * @hidden
     */
    get displayTitle() {
        return this.title;
    }
    /**
     * @hidden
     */
    get isVisible() {
        return !this.hidden && this.matchesMedia;
    }
    /**
     * @hidden
     */
    constructor(parent, idService) {
        this.parent = parent;
        this.idService = idService;
        if (parent && idService && parent.idService.gridId() === idService.gridId() && !isColumnContainer(parent)) {
            throw new Error(ColumnConfigurationErrorMessages.columnNested);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnBase, deps: [{ token: ColumnBase }, { token: IdService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnBase, selector: "kendo-grid-column-base", inputs: { resizable: "resizable", reorderable: "reorderable", minResizableWidth: "minResizableWidth", maxResizableWidth: "maxResizableWidth", title: "title", width: "width", autoSize: "autoSize", locked: "locked", sticky: "sticky", hidden: "hidden", media: "media", lockable: "lockable", stickable: "stickable", columnMenu: "columnMenu", includeInChooser: "includeInChooser", tableCellsRole: "tableCellsRole", style: "style", headerStyle: "headerStyle", filterStyle: "filterStyle", footerStyle: "footerStyle", cssClass: ["class", "cssClass"], headerClass: "headerClass", filterClass: "filterClass", footerClass: "footerClass" }, queries: [{ propertyName: "footerTemplate", first: true, predicate: FooterTemplateDirective, descendants: true }, { propertyName: "headerTemplates", predicate: HeaderTemplateDirective }, { propertyName: "columnMenuTemplates", predicate: ColumnMenuTemplateDirective }], ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnBase, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-column-base',
                    template: ``
                }]
        }], ctorParameters: function () { return [{ type: ColumnBase }, { type: IdService }]; }, propDecorators: { resizable: [{
                type: Input
            }], reorderable: [{
                type: Input
            }], minResizableWidth: [{
                type: Input
            }], maxResizableWidth: [{
                type: Input
            }], title: [{
                type: Input
            }], width: [{
                type: Input
            }], autoSize: [{
                type: Input
            }], locked: [{
                type: Input
            }], sticky: [{
                type: Input
            }], hidden: [{
                type: Input
            }], media: [{
                type: Input
            }], lockable: [{
                type: Input
            }], stickable: [{
                type: Input
            }], columnMenu: [{
                type: Input
            }], includeInChooser: [{
                type: Input
            }], tableCellsRole: [{
                type: Input
            }], style: [{
                type: Input
            }], headerStyle: [{
                type: Input
            }], filterStyle: [{
                type: Input
            }], footerStyle: [{
                type: Input
            }], cssClass: [{
                type: Input,
                args: ['class']
            }], headerClass: [{
                type: Input
            }], filterClass: [{
                type: Input
            }], footerClass: [{
                type: Input
            }], headerTemplates: [{
                type: ContentChildren,
                args: [HeaderTemplateDirective, { descendants: false }]
            }], footerTemplate: [{
                type: ContentChild,
                args: [FooterTemplateDirective, { static: false }]
            }], columnMenuTemplates: [{
                type: ContentChildren,
                args: [ColumnMenuTemplateDirective]
            }] } });

/**
 * Represents the filter-cell template.
 * Helps to customize the content of the filter cell. To define the filter cell template, nest an `<ng-template>` tag with the
 * `kendoGridFilterCellTemplate` directive inside a `<kendo-grid-column>` tag ([see example]({% slug filter_row %}#toc-custom-filters)).
 *
 * The template context is set to the current data item and the following additional fields are passed:
 * - `column`&mdash;Defines an instance of the [`ColumnComponent`]({% slug api_grid_columncomponent %}) option. Use it as an alias for a template variable by utilizing the `let-column="column"` syntax.
 * - `filter`&mdash;The provided filter descriptors. Use it as an alias for a template variable by utilizing the `let-filter="filter"` syntax.
 *
 * ```html
 * <kendo-grid-column field="CategoryID" title="Category">
 *     <ng-template kendoGridFilterCellTemplate
 *         let-column="column"
 *         let-filter="filter"
 *         >
 *         ...
 *    </ng-template>
 *    ...
 * </kendo-grid-column>
 * ```
 */
class FilterCellTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterCellTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: FilterCellTemplateDirective, isStandalone: true, selector: "[kendoGridFilterCellTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterCellTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridFilterCellTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the filter-menu template.
 * Helps to customize the content of the filter menu. To define the filter menu template, nest an `<ng-template>` tag with the
 * `kendoGridFilterMenuTemplate` directive inside a `<kendo-grid-column>` tag
 * ([see example]({% slug filter_menu %}#toc-custom-filters)).
 *
 * The template context is set to the current data item and the following additional fields are passed:
 * - `column`&mdash;Defines an instance of the [`ColumnComponent`]({% slug api_grid_columncomponent %}) option. Use it as an alias for a template variable by utilizing the `let-column="column"` syntax.
 * - `filter`&mdash;The provided filter descriptors. Use it as an alias for a template variable by utilizing the `let-filter="filter"` syntax.
 * - `filterService`&mdash;Represents the [`FilterService`]({% slug api_grid_filterservice %}). Use it as an alias for a template variable by utilizing the `let-filterService="filterService"` syntax.
 *
 * ```html
 * <kendo-grid-column field="CategoryID" title="Category">
 *     <ng-template kendoGridFilterMenuTemplate
 *         let-column="column"
 *         let-filter="filter"
 *         let-filterService="filterService"
 *         >
 *         ...
 *    </ng-template>
 * </kendo-grid-column>
 * ```
 */
class FilterMenuTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterMenuTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: FilterMenuTemplateDirective, isStandalone: true, selector: "[kendoGridFilterMenuTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterMenuTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridFilterMenuTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * @hidden
 */
function isColumnComponent(column) {
    return isPresent(column.field);
}
/**
 * Represents the column of the Grid. [See example](slug:columns_config#toc-using-the-column-component)
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData">
 *   <kendo-grid-column field="ProductID" title="Product ID"></kendo-grid-column>
 *   <kendo-grid-column field="ProductName" title="Product Name"></kendo-grid-column>
 *   <kendo-grid-column field="UnitPrice" title="Unit Price"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class ColumnComponent extends ColumnBase {
    /**
     * The field to which the column is bound.
     */
    field;
    /**
     * The format that is applied to the value before it is displayed. For more information on the supported date and number formats,
     * refer to the [Column Formats](slug:formats_columns_grid) documentation article.
     */
    format;
    /**
     * Allows the user to click the column headers and emits the `sortChange` event. [See example](slug:sorting_grid).
     *
     * @default true
     */
    sortable = true;
    /**
     * Determines if the column can be dragged to the group panel.
     * If set to `false`, you can group the columns by the column field by using the API of the Grid.
     *
     * @default true
     */
    groupable = true;
    /**
     * Defines the editor type. [See example](slug:inline_editing_grid#toc-using-reactive-forms).
     * Used when the column enters the edit mode.
     *
     * @default 'text'
     */
    editor = 'text';
    /**
     * Defines the filter type that is displayed inside the filter row. [See example](slug:filtering_grid#toc-filter-data-types).
     *
     * @default 'text'
     */
    filter = 'text';
    /**
     * Defines if a filter UI will be displayed for this column. [See example](slug:filtering_grid).
     *
     * @default true
     */
    filterable = true;
    /**
     * Defines whether the column is editable. [See example](slug:make_fields_uneditable_grid).
     *
     * @default true
     */
    editable = true;
    template;
    groupHeaderTemplate;
    groupHeaderColumnTemplate;
    groupFooterTemplate;
    editTemplate;
    filterCellTemplate;
    filterMenuTemplate;
    constructor(parent, idService) {
        super(parent, idService);
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
    get groupHeaderTemplateRef() {
        return this.groupHeaderTemplate ? this.groupHeaderTemplate.templateRef : undefined;
    }
    get groupHeaderColumnTemplateRef() {
        return this.groupHeaderColumnTemplate ? this.groupHeaderColumnTemplate.templateRef : undefined;
    }
    get groupFooterTemplateRef() {
        return this.groupFooterTemplate ? this.groupFooterTemplate.templateRef : undefined;
    }
    get editTemplateRef() {
        return this.editTemplate ? this.editTemplate.templateRef : undefined;
    }
    get filterCellTemplateRef() {
        return this.filterCellTemplate ? this.filterCellTemplate.templateRef : undefined;
    }
    get filterMenuTemplateRef() {
        return this.filterMenuTemplate ? this.filterMenuTemplate.templateRef : undefined;
    }
    get displayTitle() {
        return this.title === undefined ? this.field : this.title;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnComponent, deps: [{ token: ColumnBase, host: true, optional: true, skipSelf: true }, { token: IdService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnComponent, isStandalone: true, selector: "kendo-grid-column", inputs: { field: "field", format: "format", sortable: "sortable", groupable: "groupable", editor: "editor", filter: "filter", filterable: "filterable", editable: "editable" }, providers: [
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => ColumnComponent)
            }
        ], queries: [{ propertyName: "template", first: true, predicate: CellTemplateDirective, descendants: true }, { propertyName: "groupHeaderTemplate", first: true, predicate: GroupHeaderTemplateDirective, descendants: true }, { propertyName: "groupHeaderColumnTemplate", first: true, predicate: GroupHeaderColumnTemplateDirective, descendants: true }, { propertyName: "groupFooterTemplate", first: true, predicate: GroupFooterTemplateDirective, descendants: true }, { propertyName: "editTemplate", first: true, predicate: EditTemplateDirective, descendants: true }, { propertyName: "filterCellTemplate", first: true, predicate: FilterCellTemplateDirective, descendants: true }, { propertyName: "filterMenuTemplate", first: true, predicate: FilterMenuTemplateDirective, descendants: true }], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: ColumnBase,
                            useExisting: forwardRef(() => ColumnComponent)
                        }
                    ],
                    selector: 'kendo-grid-column',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ColumnBase, decorators: [{
                    type: SkipSelf
                }, {
                    type: Host
                }, {
                    type: Optional
                }] }, { type: IdService, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { field: [{
                type: Input
            }], format: [{
                type: Input
            }], sortable: [{
                type: Input
            }], groupable: [{
                type: Input
            }], editor: [{
                type: Input
            }], filter: [{
                type: Input
            }], filterable: [{
                type: Input
            }], editable: [{
                type: Input
            }], template: [{
                type: ContentChild,
                args: [CellTemplateDirective, { static: false }]
            }], groupHeaderTemplate: [{
                type: ContentChild,
                args: [GroupHeaderTemplateDirective, { static: false }]
            }], groupHeaderColumnTemplate: [{
                type: ContentChild,
                args: [GroupHeaderColumnTemplateDirective, { static: false }]
            }], groupFooterTemplate: [{
                type: ContentChild,
                args: [GroupFooterTemplateDirective, { static: false }]
            }], editTemplate: [{
                type: ContentChild,
                args: [EditTemplateDirective, { static: false }]
            }], filterCellTemplate: [{
                type: ContentChild,
                args: [FilterCellTemplateDirective, { static: false }]
            }], filterMenuTemplate: [{
                type: ContentChild,
                args: [FilterMenuTemplateDirective, { static: false }]
            }] } });

/**
 * @hidden
 */
function isSpanColumnComponent(column) {
    return column.isSpanColumn;
}
/**
 * Represents a column which can be spanned over multiple data cells while the individual
 * header and footer cells are retained ([see example]({% slug spanned_columns_grid %})).
 * Enables you to achieve more flexible layout while keeping the built-in UI element for
 * [sorting]({% slug sorting_grid %}), [filtering]({% slug filtering_grid %}), and
 * [grouping]({% slug grouping_grid %}). Wrap the columns that will be
 * merged inside the `<kendo-grid-span-column>` tag.
 *
 * ```html
 * <kendo-grid-span-column>
 *   <kendo-grid-column field="field1"></kendo-grid-column>
 *   <kendo-grid-column field="field2"></kendo-grid-column>
 *   <ng-template kendoGridCellTemplate let-dataItem>
 *     <h5>{{ dataItem.field1 }}</h5>
 *     <p>{{ dataItem.field2 }}</p>
 *   </ng-template>
 * </kendo-grid-span-column>
 * ```
 */
class SpanColumnComponent extends ColumnBase {
    /*
     * @hidden
     */
    isSpanColumn = true;
    template = new QueryList();
    editTemplate = new QueryList();
    /**
     * @hidden
     */
    childColumns = new QueryList();
    /**
     * @hidden
     */
    title;
    /**
     * @hidden
     */
    headerStyle;
    /**
     * @hidden
     */
    footerStyle;
    /**
     * @hidden
     */
    headerClass;
    /**
     * @hidden
     */
    footerClass;
    /**
     * @hidden
     */
    includeInChooser = false;
    /**
     * Defines whether the edit template of the column will be rendered.
     * To enable the editing functionality for a spanned column, set an edit template for it ([see example](slug:custom_reactive_editing_grid)).
     * @default false
     */
    set editable(value) {
        this._editable = value;
    }
    get editable() {
        return isPresent(this.editTemplateRef) && this._editable;
    }
    /**
     * @hidden
     * added for backwards compitability
     */
    set width(_value) {
    }
    get width() {
        return this.childColumns.reduce((total, column) => total + column.width, 0);
    }
    /**
     * @hidden
     */
    get leafIndex() {
        return this.childColumns.first.leafIndex;
    }
    _editable = true;
    constructor(parent, idService) {
        super(parent, idService);
        if (parent && parent.isSpanColumn) {
            throw new Error(ColumnConfigurationErrorMessages.nestedInside('SpanColumnComponent', 'SpanColumnComponent'));
        }
    }
    /**
     * @hidden
     */
    get templateRef() {
        const template = this.template.first;
        return template ? template.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get editTemplateRef() {
        const editTemplate = this.editTemplate.first;
        return editTemplate ? editTemplate.templateRef : undefined;
    }
    /**
     * @hidden
     */
    get colspan() {
        return this.childColumns.filter(c => c.isVisible).length;
    }
    /**
     * Toggles the locked (frozen) state of the columns ([see example](slug:locked_columns_grid)).
     * @default false
     */
    set locked(value) {
        this._locked = value;
    }
    get locked() {
        return this._locked || this.childColumns.some(c => c.locked);
    }
    get childrenArray() {
        return this.childColumns.toArray();
    }
    get hasChildren() {
        return this.childColumns.length > 0;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SpanColumnComponent, deps: [{ token: ColumnBase, host: true, optional: true, skipSelf: true }, { token: IdService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SpanColumnComponent, isStandalone: true, selector: "kendo-grid-span-column", inputs: { editable: "editable", locked: "locked" }, providers: [
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => SpanColumnComponent)
            }
        ], queries: [{ propertyName: "template", predicate: CellTemplateDirective }, { propertyName: "editTemplate", predicate: EditTemplateDirective }, { propertyName: "childColumns", predicate: ColumnComponent }], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SpanColumnComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: ColumnBase,
                            useExisting: forwardRef(() => SpanColumnComponent)
                        }
                    ],
                    selector: 'kendo-grid-span-column',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ColumnBase, decorators: [{
                    type: SkipSelf
                }, {
                    type: Host
                }, {
                    type: Optional
                }] }, { type: IdService, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { template: [{
                type: ContentChildren,
                args: [CellTemplateDirective, { descendants: false }]
            }], editTemplate: [{
                type: ContentChildren,
                args: [EditTemplateDirective, { descendants: false }]
            }], childColumns: [{
                type: ContentChildren,
                args: [ColumnComponent]
            }], editable: [{
                type: Input
            }], locked: [{
                type: Input
            }] } });

/**
 * @hidden
 */
const expandColumns = (columns) => (columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ? column.childrenArray : [column]), []));
/**
 * @hidden
 */
const expandColumnsWithSpan = (columns) => (columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ?
    [column].concat(column.childrenArray) :
    [column]), []));
/**
 * @hidden
 */
const columnsToRender = (columns) => (expandColumns(columns).filter(x => x.isVisible));
const sumProp = (prop) => (array) => (array || []).reduce((prev, curr) => prev + (curr[prop] || 0), 0);
/**
 * @hidden
 */
const sumColumnWidths = sumProp('width');
/**
 * @hidden
 */
const columnsSpan = sumProp('colspan');
const validField = new RegExp(`^[$A-Z\_a-z][$A-Z\_a-z0-9\\.]*$`);
/**
 * @hidden
 */
const isValidFieldName = (fieldName) => !isNullOrEmptyString(fieldName) && validField.test(fieldName) &&
    fieldName[0] !== "." && fieldName[fieldName.length - 1] !== ".";
/**
 * @hidden
 */
const children = column => column.children.filter(child => child !== column);
/**
 * @hidden
 */
const leafColumns = columns => {
    return columns.reduce((acc, column) => {
        if (column.isColumnGroup) {
            acc = acc.concat(leafColumns(children(column)));
        }
        else if (column.isSpanColumn) {
            acc = acc.concat(column.childrenArray);
        }
        else {
            acc.push(column);
        }
        return acc;
    }, []).filter(x => x.isVisible);
};
/**
 * @hidden
 */
const someLeafColumn = (callback, ...columns) => leafColumns(columns).some(callback);
/**
 * @hidden
 */
const resizableColumns = columns => columns.filter(column => isTruthy(column.resizable) && column.isVisible);
/**
 * @hidden
 */
const sortColumns = (columns) => orderBy(columns, [{ field: 'orderIndex', dir: 'asc' }]);
/**
 * @hidden
 */
const isInSpanColumn$1 = (column) => isTruthy(column.parent) && isSpanColumnComponent(column.parent);

/**
 * @hidden
 */
function isColumnGroupComponent(column) {
    return column.isColumnGroup;
}
/**
 * Represents the column group header of the Grid
 * ([more information and examples](slug:multicolumnheaders_columns_grid)).
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData">
 *   <kendo-grid-column-group title="Product Info">
 *     <kendo-grid-column field="ProductID"></kendo-grid-column>
 *     <kendo-grid-column field="ProductName"></kendo-grid-column>
 *   </kendo-grid-column-group>
 *   <kendo-grid-column field="UnitPrice"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class ColumnGroupComponent extends ColumnBase {
    parent;
    /**
     * @hidden
     */
    includeInChooser = false;
    /**
     * @hidden
     */
    isColumnGroup = true;
    /**
     * @hidden
     */
    minResizableWidth = 10;
    /**
     * @hidden
     */
    maxResizableWidth;
    /**
     * @hidden
     */
    children;
    constructor(parent, idService) {
        super(parent, idService);
        this.parent = parent;
        if (parent && parent.isSpanColumn) {
            throw new Error(ColumnConfigurationErrorMessages.nestedInside('ColumnGroupComponent', 'SpanColumnComponent'));
        }
    }
    /**
     * @hidden
     */
    rowspan() {
        return 1;
    }
    /**
     * @hidden
     */
    get colspan() {
        if (!this.children) {
            return 1;
        }
        return columnsSpan(this.children
            .filter(child => child !== this && child.isVisible));
    }
    /**
     * @hidden
     */
    get leafIndex() {
        return this.children ? (this.firstChild || {}).leafIndex : -1;
    }
    get childrenArray() {
        return this.children.filter(c => c !== this);
    }
    get hasChildren() {
        return Boolean(this.firstChild);
    }
    get firstChild() {
        return this.children.find(column => column !== this);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnGroupComponent, deps: [{ token: ColumnBase, host: true, optional: true, skipSelf: true }, { token: IdService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnGroupComponent, isStandalone: true, selector: "kendo-grid-column-group", providers: [
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => ColumnGroupComponent)
            }
        ], queries: [{ propertyName: "children", predicate: ColumnBase }], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnGroupComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: ColumnBase,
                            useExisting: forwardRef(() => ColumnGroupComponent)
                        }
                    ],
                    selector: 'kendo-grid-column-group',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ColumnBase, decorators: [{
                    type: SkipSelf
                }, {
                    type: Host
                }, {
                    type: Optional
                }] }, { type: IdService, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { children: [{
                type: ContentChildren,
                args: [ColumnBase]
            }] } });

/**
 * Represents the detail template of the Grid ([more information and examples]({% slug detailrowtemplate_grid %})).
 * To define the detail template, nest an `<ng-template>` tag with the `kendoGridDetailTemplate` directive inside a `<kendo-grid>` tag.
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" selectable="true" style="height: 160px">
 *    <kendo-grid-column field="ProductName"></kendo-grid-column>
 *    <ng-template kendoGridDetailTemplate let-dataItem>
 *       <div *ngIf="dataItem.Category">
 *          <header>{{dataItem.Category?.CategoryName}}</header>
 *          span>{{dataItem.Category?.Description}}</span>
 *       </div>
 *    </ng-template>
 * </kendo-grid>
 * ```
 *
 */
class DetailTemplateDirective {
    templateRef;
    /**
     * Defines the function that indicates if a given detail row and the associated **Expand** or **Collapse** button will be displayed.
     */
    set showIf(fn) {
        if (typeof fn !== 'function') {
            throw new Error(GridConfigurationErrorMessages.functionType('showIf', fn));
        }
        this._condition = fn;
    }
    get showIf() {
        return this._condition;
    }
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    _condition = () => true;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DetailTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: DetailTemplateDirective, isStandalone: true, selector: "[kendoGridDetailTemplate]", inputs: { showIf: ["kendoGridDetailTemplateShowIf", "showIf"] }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DetailTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridDetailTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { showIf: [{
                type: Input,
                args: ["kendoGridDetailTemplateShowIf"]
            }] } });

/**
 * @hidden
 */
class ColGroupComponent {
    columns = [];
    groups = [];
    detailTemplate;
    sort = new Array();
    get columnsToRender() {
        return columnsToRender(this.columns);
    }
    trackBy(index, _item) {
        return index;
    }
    isSorted(column) {
        const state = this.sortDescriptor(column.field);
        return this.isSortable(column) && (state.dir === 'asc' || state.dir === 'desc');
    }
    getColumnComponent(column) {
        return column;
    }
    isSortable(column) {
        return !isNullOrEmptyString(column.field) && isTruthy(column.sortable);
    }
    sortDescriptor(field) {
        return this.sort.find(item => item.field === field) || { field };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColGroupComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColGroupComponent, isStandalone: true, selector: "[kendoGridColGroup]", inputs: { columns: "columns", groups: "groups", detailTemplate: "detailTemplate", sort: "sort" }, ngImport: i0, template: `
    <ng-container>
        <col [class.k-group-col]="true" *ngFor="let g of groups" />
        <col [class.k-hierarchy-col]="true" *ngIf="detailTemplate?.templateRef"/>
        <col *ngFor="let column of columnsToRender; trackBy: trackBy;"
        [style.width.px]="column.width"
        [class.k-sorted]="isSorted(getColumnComponent(column))"/>
    </ng-container>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridColGroup]',
                    template: `
    <ng-container>
        <col [class.k-group-col]="true" *ngFor="let g of groups" />
        <col [class.k-hierarchy-col]="true" *ngIf="detailTemplate?.templateRef"/>
        <col *ngFor="let column of columnsToRender; trackBy: trackBy;"
        [style.width.px]="column.width"
        [class.k-sorted]="isSorted(getColumnComponent(column))"/>
    </ng-container>
    `,
                    standalone: true,
                    imports: [NgFor, NgIf]
                }]
        }], propDecorators: { columns: [{
                type: Input
            }], groups: [{
                type: Input
            }], detailTemplate: [{
                type: Input
            }], sort: [{
                type: Input
            }] } });

/**
 * Creates a loading template that overrides the default loading indicator of the Grid Component.
 * To define a loading template, nest an `<ng-template>` tag with the `kendoGridLoadingTemplate` directive inside the `<kendo-grid>` tag
 * ([see example](slug:loadingtemplate_grid)).
 */
class LoadingTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LoadingTemplateDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: LoadingTemplateDirective, isStandalone: true, selector: "[kendoGridLoadingTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LoadingTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridLoadingTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }]; } });

/**
 * @hidden
 */
class LoadingComponent {
    ctx;
    hostClass = true;
    loadingTemplate;
    get loadingText() {
        return this.ctx.localization.get('loading');
    }
    constructor(ctx) {
        this.ctx = ctx;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LoadingComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: LoadingComponent, isStandalone: true, selector: "[kendoGridLoading]", inputs: { loadingTemplate: "loadingTemplate" }, host: { properties: { "class.k-loading-mask": "this.hostClass" } }, ngImport: i0, template: `
        <ng-container *ngIf="!loadingTemplate">
            <span class="k-loading-text">{{ loadingText }}</span>
            <div class="k-loading-image"></div>
            <div class="k-loading-color"></div>
        </ng-container>
        <ng-template *ngIf="loadingTemplate" [ngTemplateOutlet]="loadingTemplate?.templateRef">
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LoadingComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridLoading]',
                    template: `
        <ng-container *ngIf="!loadingTemplate">
            <span class="k-loading-text">{{ loadingText }}</span>
            <div class="k-loading-image"></div>
            <div class="k-loading-color"></div>
        </ng-container>
        <ng-template *ngIf="loadingTemplate" [ngTemplateOutlet]="loadingTemplate?.templateRef">
        </ng-template>
    `,
                    standalone: true,
                    imports: [NgIf, NgTemplateOutlet]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; }, propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-loading-mask']
            }], loadingTemplate: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class ResizeService {
    resizeSubscription = new Subscription(() => { });
    dispatcher = new Subject();
    changes = this.dispatcher.asObservable().pipe(throttleTime(100));
    connect(resizes) {
        this.resizeSubscription.add(resizes.subscribe(this.dispatcher));
    }
    destroy() {
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ResizeService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ResizeService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ResizeService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
class ResizableContainerDirective {
    el;
    renderer;
    resizeService;
    ctx;
    _lockedWidth;
    set lockedWidth(value) {
        this._lockedWidth = value;
        if (this.enabled) {
            this.attachResize();
            this.resize();
        }
    }
    set kendoGridResizableContainer(enabled) {
        const refresh = enabled !== this.enabled;
        this.enabled = enabled;
        if (refresh) {
            this.attachResize();
            this.resize();
        }
    }
    enabled = false;
    resizeSubscription;
    constructor(el, renderer, resizeService, ctx) {
        this.el = el;
        this.renderer = renderer;
        this.resizeService = resizeService;
        this.ctx = ctx;
    }
    ngOnDestroy() {
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    }
    attachResize() {
        if (this.resizeSubscription && !this.enabled) {
            this.resizeSubscription.unsubscribe();
            this.resizeSubscription = null;
        }
        if (!this.resizeSubscription && this.enabled) {
            this.resizeSubscription = this.resizeService.changes.subscribe(this.resize.bind(this));
        }
    }
    resize() {
        if (this.ctx.grid && this.ctx.grid.wrapper) {
            const containerElement = this.ctx.grid.wrapper.nativeElement;
            const width = Math.max(containerElement.clientWidth - this._lockedWidth, 0);
            if (this.enabled && width > 0) {
                this.renderer.setStyle(this.el.nativeElement, "width", width + "px");
            }
            else {
                this.renderer.setStyle(this.el.nativeElement, "width", "");
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ResizableContainerDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ResizeService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: ResizableContainerDirective, isStandalone: true, selector: "[kendoGridResizableContainer]", inputs: { lockedWidth: "lockedWidth", kendoGridResizableContainer: "kendoGridResizableContainer" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ResizableContainerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridResizableContainer]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ResizeService }, { type: ContextService }]; }, propDecorators: { lockedWidth: [{
                type: Input,
                args: ['lockedWidth']
            }], kendoGridResizableContainer: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class FocusGroup {
    root;
    active = true;
    children = [];
    get focusableChildren() {
        return this.children.filter(el => el.canFocus());
    }
    get isActive() {
        return this.active;
    }
    constructor(root) {
        this.root = root;
        this.root.registerGroup(this);
    }
    ngOnDestroy() {
        this.root.unregisterGroup(this);
        this.active = true;
    }
    registerElement(element) {
        this.unregisterElement(element);
        this.children.push(element);
    }
    unregisterElement(element) {
        this.children = this.children.filter(f => f !== element);
    }
    /**
     * Returns a Boolean value which indicates if the group will receive focus when the cell is focused.
     * Requires a single "simple" focusable element such as a button or a checkbox.
     */
    isNavigable() {
        const focusable = this.focusableChildren;
        return focusable.length === 1 && focusable[0].isNavigable();
    }
    canFocus() {
        return this.focusableChildren.length > 0;
    }
    focus() {
        if (this.canFocus() && !this.hasFocus()) {
            this.focusableChildren[0].focus();
        }
    }
    activate() {
        this.toggleState(true);
    }
    deactivate() {
        this.toggleState(false);
    }
    hasFocus() {
        return this.children.reduce((focused, element) => focused || element.hasFocus(), false);
    }
    toggleState(active) {
        if (this.active !== active) {
            this.active = active;
            this.children.forEach(f => f.toggle(active));
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FocusGroup, deps: [{ token: FocusRoot }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FocusGroup });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FocusGroup, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: FocusRoot }]; } });

const reset = (...lists) => {
    let diff = false;
    for (let idx = 0; idx < lists.length; idx++) {
        const [list, columns] = lists[idx];
        diff = diff || list.length !== columns.length;
        list.reset(columns);
    }
    return diff;
};
/**
 * @hidden
 */
class ColumnsContainer {
    columns;
    allColumns = new QueryList();
    leafColumns = new QueryList();
    lockedColumns = new QueryList();
    nonLockedColumns = new QueryList();
    lockedLeafColumns = new QueryList();
    nonLockedLeafColumns = new QueryList();
    totalLevels = 0;
    changes = new EventEmitter();
    leafColumnsToRender = [];
    lockedColumnsToRender = [];
    nonLockedColumnsToRender = [];
    hasGroupHeaderColumn = false;
    hasGroupFooter = false;
    hasFooter = false;
    unlockedWidth = 0;
    constructor(columns) {
        this.columns = columns;
    }
    refresh() {
        const currentLevels = this.totalLevels;
        const leafColumns = new Array();
        const lockedLeafColumns = new Array();
        const nonLockedLeafColumns = new Array();
        const lockedColumns = new Array();
        const nonLockedColumns = new Array();
        const allColumns = new Array();
        const leafColumnsToRender = new Array();
        const lockedColumnsToRender = new Array();
        const nonLockedColumnsToRender = new Array();
        let hasGroupHeaderColumn = false;
        let hasGroupFooter = false;
        let hasFooter = false;
        let unlockedWidth = 0;
        let leafIndex = 0;
        this.totalLevels = 0;
        this.columns().forEach(column => {
            const containerLeafColumns = column.isLocked === true ? lockedLeafColumns : nonLockedLeafColumns;
            const containerColumns = column.isLocked === true ? lockedColumns : nonLockedColumns;
            const toRenderContainer = column.isLocked === true ? lockedColumnsToRender : nonLockedColumnsToRender;
            if (!isColumnGroupComponent(column)) {
                containerLeafColumns.push(column);
                leafColumns.push(column);
                leafColumnsToRender.push(...columnsToRender([column]));
                toRenderContainer.push(...columnsToRender([column]));
                hasGroupHeaderColumn = hasGroupHeaderColumn || someLeafColumn(leaf => Boolean(leaf.groupHeaderColumnTemplateRef), column);
                hasGroupFooter = hasGroupFooter || someLeafColumn(leaf => Boolean(leaf.groupFooterTemplateRef), column);
                hasFooter = hasFooter || someLeafColumn(leaf => Boolean(leaf.footerTemplateRef), column);
                if (!column.isLocked) {
                    unlockedWidth += column.width || 0;
                }
                if (column.isSpanColumn) {
                    column.childColumns.forEach(c => {
                        c.leafIndex = leafIndex++;
                    });
                }
                else {
                    column.leafIndex = leafIndex++;
                }
            }
            containerColumns.push(column);
            allColumns.push(column);
            this.totalLevels = column.level > this.totalLevels ? column.level : this.totalLevels;
        });
        this.hasGroupHeaderColumn = hasGroupHeaderColumn;
        this.hasGroupFooter = hasGroupFooter;
        this.hasFooter = hasFooter;
        this.leafColumnsToRender = leafColumnsToRender;
        this.lockedColumnsToRender = lockedColumnsToRender;
        this.nonLockedColumnsToRender = nonLockedColumnsToRender;
        this.unlockedWidth = unlockedWidth;
        const changes = reset([this.leafColumns, leafColumns], [this.lockedLeafColumns, lockedLeafColumns], [this.nonLockedLeafColumns, nonLockedLeafColumns], [this.lockedColumns, lockedColumns], [this.allColumns, allColumns], [this.nonLockedColumns, nonLockedColumns]) || currentLevels !== this.totalLevels;
        if (changes) {
            this.changes.emit();
        }
        return changes;
    }
}

const NO_STICKY = { left: '0px', right: '0px' };
/**
 * @hidden
 */
class ColumnInfoService {
    visibilityChange = new EventEmitter();
    lockedChange = new EventEmitter();
    stickyChange = new EventEmitter();
    columnRangeChange = new EventEmitter();
    columnsContainer = new ColumnsContainer(() => []);
    list;
    stickyColumns;
    get lockedLeafColumns() {
        return this.columnsContainer.lockedLeafColumns;
    }
    get nonLockedLeafColumns() {
        return this.columnsContainer.nonLockedLeafColumns;
    }
    get isLocked() {
        return this.lockedLeafColumns.length > 0;
    }
    get totalLevels() {
        return this.columnsContainer.totalLevels;
    }
    get hiddenColumns() {
        if (!this.list) {
            return [];
        }
        return this.list().filter(column => !column.isVisible);
    }
    get leafNamedColumns() {
        const columns = expandColumns(this.list().filterSort(column => !column.isColumnGroup))
            .filter(column => column.matchesMedia && column.displayTitle);
        return orderBy(columns, [{ field: 'locked', dir: 'desc' }]);
    }
    get unlockedRootCount() {
        return this.list().rootColumns().filter(column => !column.locked && column.isVisible).length;
    }
    stickyColumnsStyles(column) {
        this.stickyColumns = this.list().rootColumns().filter(column => column.sticky && !column.locked && column.isVisible);
        if (this.stickyColumns.length === 0) {
            return NO_STICKY;
        }
        const result = this.stickyColumns.reduce((acc, curr) => {
            if (curr.leafIndex < column.leafIndex) {
                acc.left += curr.width;
            }
            else if (curr.leafIndex > column.leafIndex) {
                acc.right += curr.width;
            }
            return acc;
        }, { left: 0, right: 0 });
        return {
            left: `${result.left}px`,
            right: `${result.right}px`
        };
    }
    init(columns, list) {
        this.columnsContainer = columns;
        this.list = list;
        this.stickyColumns = null;
    }
    changeVisibility(columns) {
        this.stickyColumns = null;
        this.visibilityChange.emit(columns);
    }
    changeLocked(columns) {
        this.stickyColumns = null;
        this.lockedChange.emit(columns);
    }
    changeStuck(columns) {
        this.stickyColumns = null;
        this.stickyChange.emit(columns);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnInfoService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnInfoService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnInfoService, decorators: [{
            type: Injectable
        }] });

let id$3 = 0;
function nextId$1() {
    return id$3++;
}
/**
 * @hidden
 */
class LogicalCellDirective {
    focusGroup;
    element;
    columnInfoService;
    idService;
    navigationService;
    renderer;
    zone;
    cellContext;
    logicalColIndex;
    logicalRowIndex;
    logicalSlaveCell = false;
    colIndex;
    colSpan = 1;
    rowSpan = 1;
    groupItem;
    dataRowIndex = -1;
    dataItem;
    detailExpandCell = false;
    headerLabelText;
    uid = nextId$1();
    get id() {
        if (!this.logicalSlaveCell && this.columnInfoService.isLocked) {
            return this.idService.cellId(this.logicalRowIndex, this.logicalColIndex);
        }
    }
    get ariaColIndex() {
        if (this.logicalSlaveCell || this.logicalColIndex === -1) {
            return undefined;
        }
        return this.logicalColIndex + 1;
    }
    navigationChange;
    constructor(focusGroup, element, columnInfoService, idService, navigationService, renderer, zone, cellContext) {
        this.focusGroup = focusGroup;
        this.element = element;
        this.columnInfoService = columnInfoService;
        this.idService = idService;
        this.navigationService = navigationService;
        this.renderer = renderer;
        this.zone = zone;
        this.cellContext = cellContext;
    }
    ngOnInit() {
        if (!this.navigationService.tableEnabled) {
            return;
        }
        this.navigationChange = this.navigationService.changes.subscribe((e) => this.onNavigationChange(e));
    }
    ngDoCheck() {
        if (!this.navigationService.tableEnabled || this.logicalColIndex === -1) {
            return;
        }
        if (this.cellContext) {
            this.cellContext.focusGroup = this.focusGroup;
        }
        this.registerNoChanges();
    }
    ngOnChanges(changes) {
        if (!this.navigationService.tableEnabled) {
            return;
        }
        const keys = Object.keys(changes);
        if ((keys.length === 1 && keys[0] === 'groupItem') || this.logicalColIndex === -1) {
            // Ignore groupItem changes as the reference is not stable
            return;
        }
        const indexChange = changes['logicalColIndex'];
        const rowIndexChange = changes['logicalRowIndex'];
        const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalColIndex;
        const rowIndex = rowIndexChange && !rowIndexChange.isFirstChange() ? rowIndexChange.previousValue : this.logicalRowIndex;
        this.navigationService.unregisterCell(index, rowIndex, this);
        this.registerChanges();
        this.updateElement();
    }
    ngOnDestroy() {
        if (this.navigationChange) {
            this.navigationChange.unsubscribe();
        }
        this.navigationService.unregisterCell(this.logicalColIndex, this.logicalRowIndex, this);
    }
    onNavigationChange(e) {
        const active = this.logicalColIndex === e.colIndex && this.logicalRowIndex === e.rowIndex;
        const wasActive = this.logicalColIndex === e.prevColIndex && this.logicalRowIndex === e.prevRowIndex;
        if (active || wasActive) {
            this.updateElement();
        }
    }
    updateElement() {
        const el = this.element.nativeElement;
        this.renderer.setAttribute(el, 'tabIndex', this.isFocusable() && !this.logicalSlaveCell ? '0' : '-1');
        if (this.isFocused()) {
            if (this.focusGroup.isNavigable()) {
                this.focusGroup.focus();
            }
            else {
                if (!this.logicalSlaveCell && this.navigationService.autoFocusCell(this.logicalColIndex, this.logicalColIndex + this.colSpan - 1)) {
                    this.microtask(() => this.isFocused() && el.focus());
                }
                this.renderer.addClass(el, 'k-focus');
            }
            if (this.headerLabelText) {
                el.removeAttribute('aria-label');
            }
        }
        else {
            this.renderer.removeClass(el, 'k-focus');
            if (this.headerLabelText) {
                el.setAttribute('aria-label', this.headerLabelText);
            }
        }
    }
    microtask(callback) {
        this.zone.runOutsideAngular(() => Promise.resolve(null).then(callback));
    }
    registerChanges() {
        if (!this.logicalSlaveCell) {
            this.navigationService.registerCell(this);
        }
    }
    registerNoChanges() {
        if (!this.logicalSlaveCell) {
            this.navigationService.registerCellOnCurrentRow(this);
        }
    }
    isFocusable() {
        return this.navigationService.isCellFocusable(this);
    }
    isFocused() {
        return this.navigationService.isCellFocused(this);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LogicalCellDirective, deps: [{ token: FocusGroup }, { token: i0.ElementRef }, { token: ColumnInfoService }, { token: IdService }, { token: NavigationService }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: CELL_CONTEXT, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: LogicalCellDirective, isStandalone: true, selector: "[kendoGridLogicalCell]", inputs: { logicalColIndex: "logicalColIndex", logicalRowIndex: "logicalRowIndex", logicalSlaveCell: "logicalSlaveCell", colIndex: "colIndex", colSpan: "colSpan", rowSpan: "rowSpan", groupItem: "groupItem", dataRowIndex: "dataRowIndex", dataItem: "dataItem", detailExpandCell: "detailExpandCell", headerLabelText: "headerLabelText" }, host: { properties: { "attr.id": "this.id", "attr.aria-colindex": "this.ariaColIndex" } }, providers: [{
                provide: FocusGroup,
                deps: [FocusRoot],
                useClass: FocusGroup
            }], usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LogicalCellDirective, decorators: [{
            type: Directive,
            args: [{
                    providers: [{
                            provide: FocusGroup,
                            deps: [FocusRoot],
                            useClass: FocusGroup
                        }],
                    selector: '[kendoGridLogicalCell]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: FocusGroup }, { type: i0.ElementRef }, { type: ColumnInfoService }, { type: IdService }, { type: NavigationService }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [CELL_CONTEXT]
                }] }]; }, propDecorators: { logicalColIndex: [{
                type: Input
            }], logicalRowIndex: [{
                type: Input
            }], logicalSlaveCell: [{
                type: Input
            }], colIndex: [{
                type: Input
            }], colSpan: [{
                type: Input
            }], rowSpan: [{
                type: Input
            }], groupItem: [{
                type: Input
            }], dataRowIndex: [{
                type: Input
            }], dataItem: [{
                type: Input
            }], detailExpandCell: [{
                type: Input
            }], headerLabelText: [{
                type: Input
            }], id: [{
                type: HostBinding,
                args: ['attr.id']
            }], ariaColIndex: [{
                type: HostBinding,
                args: ['attr.aria-colindex']
            }] } });

let id$2 = 0;
function nextId() {
    return id$2++;
}
/**
 * @hidden
 */
class LogicalRowDirective {
    idService;
    navigation;
    logicalRowIndex;
    logicalSlaveRow = false;
    logicalCellsCount;
    logicalSlaveCellsCount = 0;
    dataRowIndex = -1;
    dataItem;
    totalColumns;
    uid = nextId();
    get hostRole() {
        return this.logicalSlaveRow ? 'presentation' : 'row';
    }
    get ariaRowIndex() {
        return this.logicalSlaveRow ? null : this.logicalRowIndex + 1;
    }
    get rowIndex() {
        return this.logicalSlaveRow ? this.logicalRowIndex + 1 : null;
    }
    tableRowClass = true;
    get ariaOwns() {
        if (this.logicalSlaveRow || this.logicalSlaveCellsCount === 0) {
            return undefined;
        }
        const ids = [];
        if (this.dataRowIndex < 0) {
            let total = this.logicalCellsCount + this.logicalSlaveCellsCount;
            this.columnsArray.forEach(column => {
                if (column.isSpanColumn) {
                    total += column.colspan - 1;
                }
            });
            for (let cellIndex = this.logicalCellsCount; cellIndex < total; cellIndex++) {
                ids.push(this.idService.cellId(this.logicalRowIndex, cellIndex));
            }
        }
        else {
            let columnIndex = 0;
            this.columnsArray.forEach(column => {
                if (!column.isLocked) {
                    ids.push(this.idService.cellId(this.logicalRowIndex, columnIndex));
                }
                columnIndex += column.isSpanColumn ? column.colspan : 1;
            });
        }
        return ids.join(' ');
    }
    constructor(idService, navigation) {
        this.idService = idService;
        this.navigation = navigation;
    }
    ngOnChanges(changes) {
        if (!this.navigation.enabled || this.logicalSlaveRow) {
            return;
        }
        const indexChange = changes.logicalRowIndex;
        const logicalSlaveRowChange = changes.logicalSlaveRow;
        if (indexChange || logicalSlaveRowChange) {
            const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalRowIndex;
            this.navigation.unregisterRow(index, this);
            this.navigation.registerRow(this);
        }
        else if (anyChanged(['dataRowIndex', 'dataItem'], changes)) {
            this.navigation.updateRow(this);
        }
    }
    ngOnDestroy() {
        this.navigation.unregisterRow(this.logicalRowIndex, this);
    }
    get columnsArray() {
        return this.totalColumns?.allColumns.toArray() || [];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LogicalRowDirective, deps: [{ token: IdService }, { token: NavigationService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: LogicalRowDirective, isStandalone: true, selector: "[kendoGridLogicalRow]", inputs: { logicalRowIndex: "logicalRowIndex", logicalSlaveRow: "logicalSlaveRow", logicalCellsCount: "logicalCellsCount", logicalSlaveCellsCount: "logicalSlaveCellsCount", dataRowIndex: "dataRowIndex", dataItem: "dataItem", totalColumns: "totalColumns" }, host: { properties: { "attr.role": "this.hostRole", "attr.aria-rowindex": "this.ariaRowIndex", "attr.data-kendo-grid-row-index": "this.rowIndex", "class.k-table-row": "this.tableRowClass", "attr.aria-owns": "this.ariaOwns" } }, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LogicalRowDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridLogicalRow]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: IdService }, { type: NavigationService }]; }, propDecorators: { logicalRowIndex: [{
                type: Input
            }], logicalSlaveRow: [{
                type: Input
            }], logicalCellsCount: [{
                type: Input
            }], logicalSlaveCellsCount: [{
                type: Input
            }], dataRowIndex: [{
                type: Input
            }], dataItem: [{
                type: Input
            }], totalColumns: [{
                type: Input
            }], hostRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], ariaRowIndex: [{
                type: HostBinding,
                args: ['attr.aria-rowindex']
            }], rowIndex: [{
                type: HostBinding,
                args: ['attr.data-kendo-grid-row-index']
            }], tableRowClass: [{
                type: HostBinding,
                args: ['class.k-table-row']
            }], ariaOwns: [{
                type: HostBinding,
                args: ['attr.aria-owns']
            }] } });

const FORMAT_REGEX = /\{\d+:?/;
/**
 * @hidden
 */
class FieldAccessorPipe {
    intlService;
    constructor(intlService) {
        this.intlService = intlService;
    }
    transform(dataItem, fieldName, format) {
        if (!isNullOrEmptyString(fieldName)) {
            const value = getter(fieldName)(dataItem);
            if (!isNullOrEmptyString(format)) {
                return this.formatValue(format, value);
            }
            return value;
        }
        return dataItem;
    }
    formatValue(format, value) {
        const intl = this.intlService;
        if (isString(format) && format.match(FORMAT_REGEX)) {
            return intl.format(format, value);
        }
        return intl.toString(value, format);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FieldAccessorPipe, deps: [{ token: i1$4.IntlService }], target: i0.ɵɵFactoryTarget.Pipe });
    static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: FieldAccessorPipe, isStandalone: true, name: "valueOf", pure: false });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FieldAccessorPipe, decorators: [{
            type: Pipe,
            args: [{
                    // eslint-disable-next-line @angular-eslint/pipe-prefix
                    name: 'valueOf',
                    pure: false,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i1$4.IntlService }]; } });

/**
 * @hidden
 */
class GridTableDirective {
    wrapper;
    hostClass = true;
    get sizeSmallClass() {
        return this.size === 'small';
    }
    get sizeMediumClass() {
        return this.size === 'medium' || !this.size;
    }
    set size(size) {
        this._size = size;
        if (size === 'none') {
            this.wrapper.nativeElement.classList.remove('k-table-sm', 'k-table-md');
        }
    }
    get size() {
        return this._size;
    }
    _size = 'medium';
    constructor(wrapper) {
        this.wrapper = wrapper;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridTableDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: GridTableDirective, isStandalone: true, selector: "[kendoGridTable]", inputs: { size: "size" }, host: { properties: { "class.k-table": "this.hostClass", "class.k-table-sm": "this.sizeSmallClass", "class.k-table-md": "this.sizeMediumClass" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridTableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridTable]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-table']
            }], sizeSmallClass: [{
                type: HostBinding,
                args: ['class.k-table-sm']
            }], sizeMediumClass: [{
                type: HostBinding,
                args: ['class.k-table-md']
            }], size: [{
                type: Input
            }] } });

const forEachColumn = (list, callback) => {
    list.forEach((column) => {
        callback(column);
        if (column.isColumnGroup && column.hasChildren) {
            forEachColumn(column.childrenArray, callback);
        }
    });
};
const forEachLevel = (list, callback) => {
    sortColumns(list)
        .forEach((column) => {
        callback(column);
        if (column.isColumnGroup && column.hasChildren) {
            forEachLevel(column.childrenArray, callback);
        }
    });
};
const filterHierarchy = (list, predicate) => {
    const result = [];
    sortColumns(list)
        .forEach((column) => {
        if (predicate(column)) {
            if (column.isColumnGroup) {
                const children = filterHierarchy(column.childrenArray, predicate);
                if (children.length) {
                    result.push(column, ...children);
                }
            }
            else if (!column.isSpanColumn || filterHierarchy(column.childrenArray, predicate).length) {
                result.push(column);
            }
        }
    });
    return result.sort((a, b) => Number(b.locked) - Number(a.locked));
};
/**
 * @hidden
 */
class ColumnList {
    columns;
    static empty() {
        return new ColumnList(new QueryList());
    }
    constructor(columns) {
        this.columns = columns;
    }
    forEach(callback) {
        forEachColumn(this.columns, callback);
    }
    filter(callback) {
        const result = [];
        forEachColumn(this.columns, (column) => {
            if (callback(column)) {
                result.push(column);
            }
        });
        return result;
    }
    filterHierarchy(predicate) {
        return filterHierarchy(this.columns.toArray(), predicate);
    }
    filterSort(callback) {
        const result = [];
        forEachLevel(this.columns.toArray(), (column) => {
            if (callback(column)) {
                result.push(column);
            }
        });
        return result;
    }
    toArray() {
        const result = [];
        forEachColumn(this.columns, (column) => {
            result.push(column);
        });
        return result;
    }
    rootColumns() {
        return this.columns.toArray();
    }
    totalColumnLevels() {
        let totalLevels = 0;
        this.forEach(column => {
            totalLevels = Math.max(column.level, totalLevels);
        });
        return totalLevels;
    }
}

/**
 * @hidden
 */
class GroupInfoService {
    _columnList = ColumnList.empty;
    get columns() {
        return expandColumns(this._columnList().toArray()).filter(isColumnComponent);
    }
    registerColumnsContainer(columns) {
        this._columnList = columns;
    }
    formatForGroup(item) {
        const column = this.columnForGroup(item);
        return column ? column.format : "";
    }
    isGroupable(groupField) {
        const [column] = this.columns.filter(x => x.field === groupField);
        return column ? column.groupable : true;
    }
    groupTitle(item) {
        const column = this.columnForGroup(item);
        return column ? (column.title || column.field) : this.groupField(item);
    }
    groupHeaderTemplate(item) {
        const column = this.columnForGroup(item);
        return column ? column.groupHeaderTemplateRef || column.groupHeaderColumnTemplateRef : undefined;
    }
    groupField(group) {
        return group.data ? group.data.field : group.field;
    }
    columnForGroup(group) {
        const field = this.groupField(group);
        const [column] = this.columns.filter(x => x.field === field);
        return column;
    }
}

/**
 * @hidden
 */
class GroupHeaderComponent {
    groupsService;
    groupInfoService;
    ctx;
    rowIndex;
    logicalRowIndex;
    item;
    skipGroupDecoration = false;
    hasDetails = false;
    totalColumnsCount = 0;
    hasGroupHeaderColumn;
    groupHeaderColumns;
    columns;
    groups = [];
    groupItemClass = true;
    tableGroupRowClass = true;
    isExpanded = false;
    caretAltDownIcon = caretAltDownIcon;
    caretAltRightIcon = caretAltRightIcon;
    caretAltLeftIcon = caretAltLeftIcon;
    constructor(groupsService, groupInfoService, ctx) {
        this.groupsService = groupsService;
        this.groupInfoService = groupInfoService;
        this.ctx = ctx;
    }
    ngDoCheck() {
        const groupArgs = {
            group: this.item.data,
            groupIndex: this.item.index,
            parentGroup: getGroupRowArgs(this.item.parentGroup)
        };
        this.isExpanded = this.groupsService.isExpanded(groupArgs);
    }
    prefixGroupCell(item) {
        return new Array(item.level);
    }
    toggleGroup(item) {
        this.groupsService.toggleRow(item);
        return false;
    }
    groupSpan(item) {
        const groupCount = (this.groups || []).length;
        const detailOffset = this.hasDetails ? 1 : 0;
        if (this.hasGroupHeaderColumn) {
            return groupCount + 1 + detailOffset - item.level;
        }
        const columnCount = columnsSpan(this.columns);
        if (this.skipGroupDecoration) {
            return columnCount;
        }
        return groupCount + columnCount + detailOffset - item.level;
    }
    logicalColSpan() {
        return this.skipGroupDecoration ? 1 : this.totalColumnsCount;
    }
    ariaRole() {
        if (this.skipGroupDecoration) {
            return 'presentation';
        }
        return 'gridcell';
    }
    formatForGroup(item) {
        return this.groupInfoService.formatForGroup(item);
    }
    groupTitle(item) {
        return this.groupInfoService.groupTitle(item);
    }
    groupHeaderTemplate(item) {
        return this.groupInfoService.groupHeaderTemplate(item);
    }
    get groupButtonTitle() {
        const messageKey = this.isExpanded ? 'groupCollapse' : 'groupExpand';
        return this.ctx.localization.get(messageKey);
    }
    get arrowIcon() {
        const icon = !this.isExpanded ?
            !this.ctx.localization.rtl ?
                'caret-alt-right' :
                'caret-alt-left' :
            'caret-alt-down';
        return icon;
    }
    get arrowSVGIcon() {
        const icon = !this.isExpanded ?
            !this.ctx.localization.rtl ?
                this.caretAltRightIcon :
                this.caretAltLeftIcon :
            this.caretAltDownIcon;
        return icon;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GroupHeaderComponent, deps: [{ token: GroupsService }, { token: GroupInfoService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: GroupHeaderComponent, isStandalone: true, selector: "[kendoGridGroupHeader]", inputs: { rowIndex: "rowIndex", logicalRowIndex: "logicalRowIndex", item: "item", skipGroupDecoration: "skipGroupDecoration", hasDetails: "hasDetails", totalColumnsCount: "totalColumnsCount", hasGroupHeaderColumn: "hasGroupHeaderColumn", groupHeaderColumns: "groupHeaderColumns", columns: "columns", groups: "groups" }, host: { properties: { "class.k-grouping-row": "this.groupItemClass", "class.k-table-group-row": "this.tableGroupRowClass" } }, ngImport: i0, template: `
        <ng-container *ngIf="!skipGroupDecoration">
            <td class="k-group-cell k-table-td k-table-group-td"
                role="presentation"
                *ngFor="let g of prefixGroupCell(item)"></td>
        </ng-container>
        <td [attr.colspan]="groupSpan(item)" *ngIf="!(skipGroupDecoration && hasGroupHeaderColumn)"
            [attr.role]="ariaRole()"
            aria-selected="false"
            class="k-table-td"
            [attr.aria-expanded]="isExpanded"
            kendoGridLogicalCell
            [logicalRowIndex]="logicalRowIndex"
            [logicalColIndex]="0"
            [logicalSlaveCell]="skipGroupDecoration"
            [groupItem]="item"
            [colSpan]="logicalColSpan()">
            <p class="k-reset">
                <ng-container *ngIf="!skipGroupDecoration">
                    <a href="#" tabindex="-1" (click)="toggleGroup(item)"
                        role="presentation"
                        [attr.title]="groupButtonTitle"
                        [attr.aria-label]="groupButtonTitle">
                        <kendo-icon-wrapper
                            [name]="arrowIcon"
                            [svgIcon]="arrowSVGIcon"></kendo-icon-wrapper>
                    </a>
                    <ng-container *ngIf="!groupHeaderTemplate(item)">
                    {{groupTitle(item)}}: {{item.data | valueOf:"value": formatForGroup(item)}}
                    </ng-container>
                    <ng-template
                        [templateContext]="{
                            templateRef: groupHeaderTemplate(item),
                            group: item.data,
                            aggregates: item.data?.aggregates,
                            value: item.data?.value,
                            field: item.data?.field,
                            index: item.index,
                            expanded: isExpanded,
                            $implicit: item.data
                            }">
                    </ng-template>
                </ng-container>
            </p>
        </td>
        <ng-container *ngIf="hasGroupHeaderColumn">
            <td *ngFor="let column of groupHeaderColumns; let index = index"
                role="gridcell"
                class="k-table-td"
                aria-selected="false"
                kendoGridLogicalCell
                [logicalRowIndex]="logicalRowIndex"
                [logicalColIndex]="index + 1"
                [logicalSlaveCell]="false"
                [groupItem]="item"
                [colSpan]="1"
            >
                <ng-template *ngIf="column.groupHeaderColumnTemplateRef" [ngTemplateOutlet]="column.groupHeaderColumnTemplateRef"
                    [ngTemplateOutletContext]="{
                        group: item.data,
                        aggregates: item.data?.aggregates,
                        value: item.data?.value,
                        field: item.data?.field,
                        index: item.index,
                        $implicit: item.data
                        }">
                </ng-template>
            </td>
        </ng-container>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: LogicalCellDirective, selector: "[kendoGridLogicalCell]", inputs: ["logicalColIndex", "logicalRowIndex", "logicalSlaveCell", "colIndex", "colSpan", "rowSpan", "groupItem", "dataRowIndex", "dataItem", "detailExpandCell", "headerLabelText"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: TemplateContextDirective, selector: "[templateContext]", inputs: ["templateContext"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "pipe", type: FieldAccessorPipe, name: "valueOf" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GroupHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridGroupHeader]',
                    template: `
        <ng-container *ngIf="!skipGroupDecoration">
            <td class="k-group-cell k-table-td k-table-group-td"
                role="presentation"
                *ngFor="let g of prefixGroupCell(item)"></td>
        </ng-container>
        <td [attr.colspan]="groupSpan(item)" *ngIf="!(skipGroupDecoration && hasGroupHeaderColumn)"
            [attr.role]="ariaRole()"
            aria-selected="false"
            class="k-table-td"
            [attr.aria-expanded]="isExpanded"
            kendoGridLogicalCell
            [logicalRowIndex]="logicalRowIndex"
            [logicalColIndex]="0"
            [logicalSlaveCell]="skipGroupDecoration"
            [groupItem]="item"
            [colSpan]="logicalColSpan()">
            <p class="k-reset">
                <ng-container *ngIf="!skipGroupDecoration">
                    <a href="#" tabindex="-1" (click)="toggleGroup(item)"
                        role="presentation"
                        [attr.title]="groupButtonTitle"
                        [attr.aria-label]="groupButtonTitle">
                        <kendo-icon-wrapper
                            [name]="arrowIcon"
                            [svgIcon]="arrowSVGIcon"></kendo-icon-wrapper>
                    </a>
                    <ng-container *ngIf="!groupHeaderTemplate(item)">
                    {{groupTitle(item)}}: {{item.data | valueOf:"value": formatForGroup(item)}}
                    </ng-container>
                    <ng-template
                        [templateContext]="{
                            templateRef: groupHeaderTemplate(item),
                            group: item.data,
                            aggregates: item.data?.aggregates,
                            value: item.data?.value,
                            field: item.data?.field,
                            index: item.index,
                            expanded: isExpanded,
                            $implicit: item.data
                            }">
                    </ng-template>
                </ng-container>
            </p>
        </td>
        <ng-container *ngIf="hasGroupHeaderColumn">
            <td *ngFor="let column of groupHeaderColumns; let index = index"
                role="gridcell"
                class="k-table-td"
                aria-selected="false"
                kendoGridLogicalCell
                [logicalRowIndex]="logicalRowIndex"
                [logicalColIndex]="index + 1"
                [logicalSlaveCell]="false"
                [groupItem]="item"
                [colSpan]="1"
            >
                <ng-template *ngIf="column.groupHeaderColumnTemplateRef" [ngTemplateOutlet]="column.groupHeaderColumnTemplateRef"
                    [ngTemplateOutletContext]="{
                        group: item.data,
                        aggregates: item.data?.aggregates,
                        value: item.data?.value,
                        field: item.data?.field,
                        index: item.index,
                        $implicit: item.data
                        }">
                </ng-template>
            </td>
        </ng-container>
    `,
                    standalone: true,
                    imports: [NgIf, NgFor, LogicalCellDirective, IconWrapperComponent, TemplateContextDirective, NgTemplateOutlet, FieldAccessorPipe]
                }]
        }], ctorParameters: function () { return [{ type: GroupsService }, { type: GroupInfoService }, { type: ContextService }]; }, propDecorators: { rowIndex: [{
                type: Input
            }], logicalRowIndex: [{
                type: Input
            }], item: [{
                type: Input
            }], skipGroupDecoration: [{
                type: Input
            }], hasDetails: [{
                type: Input
            }], totalColumnsCount: [{
                type: Input
            }], hasGroupHeaderColumn: [{
                type: Input
            }], groupHeaderColumns: [{
                type: Input
            }], columns: [{
                type: Input
            }], groups: [{
                type: Input
            }], groupItemClass: [{
                type: HostBinding,
                args: ['class.k-grouping-row']
            }], tableGroupRowClass: [{
                type: HostBinding,
                args: ['class.k-table-group-row']
            }] } });

const withoutField = ({ field }) => isNullOrEmptyString(field);
const alreadyGrouped = ({ groups, field }) => groups.some(group => group.field === field);
const overSameTarget = ({ target, field }) => target.field === field;
const overLastTarget = ({ target }) => target.lastTarget;
const isLastGroup = ({ groups, field }) => groups.map(group => group.field).indexOf(field) === groups.length - 1;
const isNotGroupable = (groupsService) => ({ field }) => !groupsService.isGroupable(field);
const columnRules = (groupService) => or(withoutField, alreadyGrouped, isNotGroupable(groupService));
const indicatorRules = or(overSameTarget, and(overLastTarget, isLastGroup));
/**
 * @hidden
 */
class GroupPanelComponent {
    hint;
    cue;
    groupInfoService;
    ctx;
    cd;
    popupService;
    ngZone;
    renderer;
    change = new EventEmitter();
    get groupHeaderClass() {
        return true;
    }
    set text(value) {
        this.emptyText = value;
    }
    get text() {
        return this.emptyText ? this.emptyText : this.ctx.localization.get('groupPanelEmpty');
    }
    navigable;
    groups = [];
    dropTargets = new QueryList();
    defaultTemplate;
    groupTitles = [];
    isChipMenuOpen = false;
    get gridId() {
        return this.ctx.grid?.ariaRootId;
    }
    rtl = false;
    first;
    last;
    arrowLeftIcon = arrowLeftIcon;
    arrowRightIcon = arrowRightIcon;
    emptyText;
    subscription;
    targetSubscription;
    popupSubs;
    popupRef;
    activeItem;
    constructor(hint, cue, groupInfoService, ctx, cd, popupService, ngZone, renderer) {
        this.hint = hint;
        this.cue = cue;
        this.groupInfoService = groupInfoService;
        this.ctx = ctx;
        this.cd = cd;
        this.popupService = popupService;
        this.ngZone = ngZone;
        this.renderer = renderer;
    }
    ngAfterViewInit() {
        this.subscription = this.ctx.localization.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.cd.markForCheck();
        });
        this.subscription.add(observe(this.dropTargets)
            .subscribe(this.attachTargets.bind(this)));
    }
    ngDoCheck() {
        const currentTitles = this.groups.map(group => this.groupInfoService.groupTitle(group));
        if (currentTitles.length !== this.groupTitles.length || currentTitles.some((current, idx) => current !== this.groupTitles[idx])) {
            this.groupTitles = currentTitles;
            this.cd.markForCheck();
        }
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        if (this.targetSubscription) {
            this.targetSubscription.unsubscribe();
        }
        this.destroyMenu();
    }
    messageFor(token) {
        return this.ctx.localization.get(token);
    }
    getTitle(group) {
        return this.messageFor(group.dir === 'desc' ? 'sortedDescending' : 'sortedAscending');
    }
    getDirectionIcon(group) {
        return group.dir === 'desc' ? 'sort-desc-sm' : 'sort-asc-sm';
    }
    getDirectionSvgIcon(group) {
        return group.dir === 'desc' ? sortDescSmallIcon : sortAscSmallIcon;
    }
    directionChange(group) {
        group.dir = group.dir ? group.dir : "asc";
        group.dir = group.dir === 'asc' ? 'desc' : 'asc';
        const index = this.groups.findIndex(x => x.field === group.field);
        const groups = [...this.groups.slice(0, index), group, ...this.groups.slice(index + 1)];
        this.change.emit(groups);
    }
    insert(field, index) {
        const groups = this.groups.filter(x => x.field !== field);
        if (groups.length || this.groups.length === 0) {
            this.change.emit([...groups.slice(0, index), { field: field }, ...groups.slice(index)]);
        }
    }
    remove(group) {
        this.destroyMenu();
        this.change.emit(this.groups.filter(x => x.field !== group.field));
    }
    toggleMenu(chip, first, last, field) {
        const anchor = chip.element.nativeElement.querySelector('.k-chip-action');
        if (this.popupRef) {
            const popupAnchor = this.popupRef.popup.instance.anchor;
            this.destroyMenu();
            if (anchor === popupAnchor) {
                return;
            }
        }
        this.first = first;
        this.last = last;
        const direction = this.ctx.localization.rtl ? 'right' : 'left';
        this.popupRef = this.popupService.open({
            anchor: anchor,
            content: this.defaultTemplate,
            anchorAlign: { vertical: 'bottom', horizontal: direction },
            popupAlign: { vertical: 'top', horizontal: direction },
            positionMode: 'absolute'
        });
        this.activeItem = this.dropTargets.find(dt => dt.context.field === field);
        this.renderer.setAttribute(this.popupRef.popupElement, 'dir', this.ctx.localization.rtl ? 'rtl' : 'ltr');
        const menuItems = Array.from(this.popupRef.popupElement.querySelectorAll('.k-menu-item'));
        this.activateMenuItem(menuItems[1], 'previous');
        this.popupSubs = this.popupRef.popupAnchorViewportLeave.subscribe(() => {
            this.destroyMenu(true);
        });
        if (isUniversal()) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.popupSubs.add(fromEvent(document, 'click')
                .pipe(filter((event) => !closest(event.target, (node) => node === this.popupRef.popupElement || (node.matches && node.matches('.k-chip-action'))))).subscribe(() => {
                this.destroyMenu();
            }));
        });
    }
    handleKeyDown = (e) => {
        if (e.keyCode === Keys.ArrowDown || e.keyCode === Keys.ArrowUp) {
            e.preventDefault();
            const relatedItemType = e.target.matches(':first-child') ? 'next' : 'previous';
            this.activateMenuItem(e.target, relatedItemType);
        }
        else if (e.keyCode === Keys.Escape) {
            this.destroyMenu(true);
        }
        else if (e.keyCode === Keys.Tab) {
            this.destroyMenu(true);
        }
        else if (e.keyCode === Keys.Space || e.keyCode === Keys.Enter) {
            this.handleMenuClick(e);
        }
    };
    handleClick = (e) => {
        e.preventDefault();
        const menuItemEl = e.target.closest('.k-menu-item');
        if (!menuItemEl.matches('[aria-disabled="true"]')) {
            this.handleMenuClick(e);
            return;
        }
        if (menuItemEl.getAttribute('tabindex') === '0') {
            return;
        }
        const activeMenuItem = menuItemEl.closest('.k-menu-group').querySelector('[tabindex="0"]');
        const relatedItemType = activeMenuItem.matches(':first-child') ? 'next' : 'previous';
        this.activateMenuItem(activeMenuItem, relatedItemType);
    };
    canDrop(draggable, target) {
        const isIndicator = draggable.type === 'groupIndicator';
        const rules = isIndicator
            ? indicatorRules
            : columnRules(this.groupInfoService);
        return !rules({
            field: draggable.field,
            groups: this.groups,
            target
        });
    }
    attachTargets() {
        if (this.targetSubscription) {
            this.targetSubscription.unsubscribe();
        }
        this.targetSubscription = new Subscription();
        const enterStream = this.dropTargets
            .reduce((acc, target) => merge(acc, target.enter), from([]));
        const leaveStream = this.dropTargets
            .reduce((acc, target) => merge(acc, target.leave), from([]));
        const dropStream = this.dropTargets
            .reduce((acc, target) => merge(acc, target.drop), from([]));
        this.targetSubscription.add(enterStream.pipe(tap(_ => {
            this.hint.removeLock();
            this.destroyMenu();
        }), filter(({ draggable, target }) => this.canDrop(draggable.context, target.context)), tap(this.enter.bind(this)), switchMapTo(dropStream.pipe(takeUntil(leaveStream.pipe(tap(this.leave.bind(this))))))).subscribe(this.drop.bind(this)));
    }
    enter({ draggable, target }) {
        this.hint.enable();
        let before = target.context.lastTarget || isTargetBefore(draggable.element.nativeElement, target.element.nativeElement);
        if (this.ctx.localization.rtl) {
            before = !before;
        }
        this.cue.position(position(target.element.nativeElement, before));
    }
    leave() {
        this.hint.disable();
        this.cue.hide();
    }
    drop({ target, draggable }) {
        const field = draggable.context.field;
        const index = this.dropTargets.toArray().indexOf(target);
        this.insert(field, index);
    }
    destroyMenu(focusAnchor) {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
            this.popupSubs && this.popupSubs.unsubscribe();
            focusAnchor && this.activeItem.context.target.focus();
        }
    }
    activateMenuItem(item, relatedItemType) {
        this.renderer.setAttribute(item, 'tabindex', '-1');
        this.renderer.removeClass(item, 'k-focus');
        const relatedItem = item[`${relatedItemType}ElementSibling`];
        this.renderer.setAttribute(relatedItem, 'tabindex', '0');
        this.renderer.addClass(relatedItem, 'k-focus');
        this.ngZone.runOutsideAngular(() => setTimeout(() => relatedItem.focus()));
    }
    handleMenuClick(e) {
        e.preventDefault();
        if (e.target.getAttribute('aria-disabled') !== 'true') {
            const chips = this.dropTargets.toArray().slice(0, this.dropTargets.length - 1);
            let groupChip, groupChipIndex;
            for (let i = 0; i < chips.length; i++) {
                if (chips[i].element.nativeElement === this.popupRef.popup.instance.anchor.closest('.k-chip')) {
                    groupChip = chips[i];
                    groupChipIndex = i;
                    break;
                }
            }
            const isPrev = e.target.closest('.k-menu-item').matches(':first-child');
            if (isPrev && groupChipIndex > 0) {
                this.insert(groupChip.context.field, groupChipIndex - 1);
            }
            else if (!isPrev && groupChipIndex < chips.length - 1) {
                this.insert(groupChip.context.field, groupChipIndex + 1);
            }
            this.destroyMenu(true);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GroupPanelComponent, deps: [{ token: DragHintService }, { token: DropCueService }, { token: GroupInfoService }, { token: ContextService }, { token: i0.ChangeDetectorRef }, { token: i5.PopupService }, { token: i0.NgZone }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: GroupPanelComponent, isStandalone: true, selector: "kendo-grid-group-panel", inputs: { text: "text", navigable: "navigable", groups: "groups" }, outputs: { change: "change" }, host: { properties: { "class.k-grouping-header": "this.groupHeaderClass" } }, viewQueries: [{ propertyName: "defaultTemplate", first: true, predicate: ["defaultTemplate"], descendants: true, read: TemplateRef, static: true }, { propertyName: "dropTargets", predicate: DropTargetDirective, descendants: true }], ngImport: i0, template: `
        <div
            *ngIf="groups.length === 0"
            class="k-grouping-drop-container"
            [context]="{
                lastTarget: true
            }"
            kendoDropTarget
        >
            {{ text }}
        </div>

        <kendo-chiplist
            *ngIf="groups.length !== 0"
            [navigable]="navigable"
            role="none">
            <kendo-chip
                *ngFor="let group of groups; let index = index; let first = first; let last = last;"
                #chip
                kendoDropTarget
                kendoDraggableColumn
                kendoDraggable
                [title]="getTitle(group)"
                [enableDrag]="true"
                [context]="{
                    field: group.field,
                    type: 'groupIndicator',
                    hint:  groupTitles[index],
                    target: chip
                }"
                [label]="groupTitles[index]"
                [removable]="true"
                [hasMenu]="true"
                [icon]="getDirectionIcon(group)"
                [svgIcon]="getDirectionSvgIcon(group)"
                [attr.aria-haspopup]="'menu'"
                [attr.aria-expanded]="isChipMenuOpen"
                [attr.aria-controls]="gridId"
                (contentClick)="directionChange(group)"
                (remove)="remove(group)"
                (menuToggle)="toggleMenu(chip, first, last, group.field)"
                (keydown.alt.arrowdown)="$event.preventDefault(); toggleMenu(chip, first, last, group.field)"
            >
            </kendo-chip>
        </kendo-chiplist>

        <div
            *ngIf="groups.length !== 0"
            class="k-grouping-drop-container"
            [context]="{
                lastTarget: true
            }"
            kendoDropTarget
        >&nbsp;</div>

        <ng-template #defaultTemplate>
            <ul unselectable="on" role="menu" class="k-group k-menu-group k-reset k-menu-group-md" [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown,
                click: handleClick
            }">
                <li role="menuitem" unselectable="on" class="k-item k-menu-item" [attr.aria-disabled]="first">
                    <span class="k-link k-menu-link" [class.k-disabled]="first">
                        <kendo-icon-wrapper
                            [name]="rtl ? 'arrow-right' : 'arrow-left'"
                            [svgIcon]="rtl ? arrowRightIcon : arrowLeftIcon"></kendo-icon-wrapper>
                        <span class="k-menu-link-text">{{messageFor('groupChipMenuPrevious')}}</span>
                    </span>
                </li>
                <li role="menuitem" unselectable="on" class="k-item k-menu-item" [attr.aria-disabled]="last">
                    <span class="k-link k-menu-link" [class.k-disabled]="last">
                        <kendo-icon-wrapper
                            [name]="rtl ? 'arrow-left' : 'arrow-right'"
                            [svgIcon]="rtl ? arrowLeftIcon : arrowRightIcon"></kendo-icon-wrapper>
                        <span class="k-menu-link-text">{{messageFor('groupChipMenuNext')}}</span>
                    </span>
                </li>
            </ul>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: DropTargetDirective, selector: "[kendoDropTarget]", inputs: ["context"], outputs: ["enter", "leave", "drop"] }, { kind: "component", type: ChipListComponent, selector: "kendo-chiplist, kendo-chip-list", inputs: ["selection", "size", "role", "navigable"], outputs: ["selectedChange", "remove"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: ChipComponent, selector: "kendo-chip", inputs: ["label", "icon", "svgIcon", "iconClass", "avatarSettings", "selected", "removable", "removeIcon", "removeSvgIcon", "hasMenu", "menuIcon", "menuSvgIcon", "disabled", "size", "rounded", "fillMode", "themeColor"], outputs: ["remove", "menuToggle", "contentClick"] }, { kind: "directive", type: DraggableColumnDirective, selector: "[kendoDraggableColumn]", inputs: ["context", "enableDrag"], outputs: ["drag"] }, { kind: "directive", type: DraggableDirective, selector: "[kendoDraggable]", inputs: ["enableDrag"], outputs: ["kendoPress", "kendoDrag", "kendoRelease"] }, { kind: "directive", type: EventsOutsideAngularDirective, selector: "[kendoEventsOutsideAngular]", inputs: ["kendoEventsOutsideAngular", "scope"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GroupPanelComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-grid-group-panel',
                    template: `
        <div
            *ngIf="groups.length === 0"
            class="k-grouping-drop-container"
            [context]="{
                lastTarget: true
            }"
            kendoDropTarget
        >
            {{ text }}
        </div>

        <kendo-chiplist
            *ngIf="groups.length !== 0"
            [navigable]="navigable"
            role="none">
            <kendo-chip
                *ngFor="let group of groups; let index = index; let first = first; let last = last;"
                #chip
                kendoDropTarget
                kendoDraggableColumn
                kendoDraggable
                [title]="getTitle(group)"
                [enableDrag]="true"
                [context]="{
                    field: group.field,
                    type: 'groupIndicator',
                    hint:  groupTitles[index],
                    target: chip
                }"
                [label]="groupTitles[index]"
                [removable]="true"
                [hasMenu]="true"
                [icon]="getDirectionIcon(group)"
                [svgIcon]="getDirectionSvgIcon(group)"
                [attr.aria-haspopup]="'menu'"
                [attr.aria-expanded]="isChipMenuOpen"
                [attr.aria-controls]="gridId"
                (contentClick)="directionChange(group)"
                (remove)="remove(group)"
                (menuToggle)="toggleMenu(chip, first, last, group.field)"
                (keydown.alt.arrowdown)="$event.preventDefault(); toggleMenu(chip, first, last, group.field)"
            >
            </kendo-chip>
        </kendo-chiplist>

        <div
            *ngIf="groups.length !== 0"
            class="k-grouping-drop-container"
            [context]="{
                lastTarget: true
            }"
            kendoDropTarget
        >&nbsp;</div>

        <ng-template #defaultTemplate>
            <ul unselectable="on" role="menu" class="k-group k-menu-group k-reset k-menu-group-md" [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown,
                click: handleClick
            }">
                <li role="menuitem" unselectable="on" class="k-item k-menu-item" [attr.aria-disabled]="first">
                    <span class="k-link k-menu-link" [class.k-disabled]="first">
                        <kendo-icon-wrapper
                            [name]="rtl ? 'arrow-right' : 'arrow-left'"
                            [svgIcon]="rtl ? arrowRightIcon : arrowLeftIcon"></kendo-icon-wrapper>
                        <span class="k-menu-link-text">{{messageFor('groupChipMenuPrevious')}}</span>
                    </span>
                </li>
                <li role="menuitem" unselectable="on" class="k-item k-menu-item" [attr.aria-disabled]="last">
                    <span class="k-link k-menu-link" [class.k-disabled]="last">
                        <kendo-icon-wrapper
                            [name]="rtl ? 'arrow-left' : 'arrow-right'"
                            [svgIcon]="rtl ? arrowLeftIcon : arrowRightIcon"></kendo-icon-wrapper>
                        <span class="k-menu-link-text">{{messageFor('groupChipMenuNext')}}</span>
                    </span>
                </li>
            </ul>
        </ng-template>
    `,
                    standalone: true,
                    imports: [NgIf, DropTargetDirective, ChipListComponent, NgFor, ChipComponent, DraggableColumnDirective, DraggableDirective, EventsOutsideAngularDirective, IconWrapperComponent]
                }]
        }], ctorParameters: function () { return [{ type: DragHintService }, { type: DropCueService }, { type: GroupInfoService }, { type: ContextService }, { type: i0.ChangeDetectorRef }, { type: i5.PopupService }, { type: i0.NgZone }, { type: i0.Renderer2 }]; }, propDecorators: { change: [{
                type: Output
            }], groupHeaderClass: [{
                type: HostBinding,
                args: ["class.k-grouping-header"]
            }], text: [{
                type: Input
            }], navigable: [{
                type: Input
            }], groups: [{
                type: Input
            }], dropTargets: [{
                type: ViewChildren,
                args: [DropTargetDirective]
            }], defaultTemplate: [{
                type: ViewChild,
                args: ['defaultTemplate', { static: true, read: TemplateRef }]
            }] } });

const localizeOperators$1 = operators => localization => Object.keys(operators).reduce((acc, key) => {
    acc[operators[key]] = localization.get(key);
    return acc;
}, {});
const operatorTexts = localizeOperators$1({
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    "filterGteOperator": "gte",
    "filterGtOperator": "gt",
    "filterLteOperator": "lte",
    "filterLtOperator": "lt",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull",
    "filterIsEmptyOperator": "isempty",
    "filterIsNotEmptyOperator": "isnotempty",
    "filterContainsOperator": "contains",
    "filterNotContainsOperator": "doesnotcontain",
    "filterStartsWithOperator": "startswith",
    "filterEndsWithOperator": "endswith",
    "filterAfterOrEqualOperator": "after-eq",
    "filterAfterOperator": "after",
    "filterBeforeOrEqualOperator": "before-eq",
    "filterBeforeOperator": "before"
});
/**
 * @hidden
 */
const toJSON = (xs) => xs.map(x => x.toJSON());
/**
 * @hidden
 */
class FilterOperatorBase {
    operator;
    ctx;
    /**
     * The text that will be displayed in the drop-down list.
     * @readonly
     * @type {string}
     * @memberOf FilterOperatorBase
     */
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = isNullOrEmptyString(value) ? this.messages[this.operator] : value;
    }
    subscription;
    messages;
    _text;
    constructor(operator, ctx) {
        this.operator = operator;
        this.ctx = ctx;
        this.messages = operatorTexts(this.ctx.localization);
        this._text = this.messages[this.operator];
        this.subscription = this.ctx.localization.changes.subscribe(this.refreshText.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: this.operator
        };
    }
    refreshText() {
        const update = this._text === this.messages[this.operator];
        this.messages = operatorTexts(this.ctx.localization);
        if (update) {
            this._text = this.messages[this.operator];
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterOperatorBase, deps: [{ token: 'filterOperator' }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: FilterOperatorBase, selector: "kendo-grid-filter-operator-base", inputs: { text: "text" }, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterOperatorBase, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-filter-operator-base',
                    template: ``
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['filterOperator']
                }] }, { type: ContextService }]; }, propDecorators: { text: [{
                type: Input
            }] } });

/**
 * Represents the `Contains` (**Contains**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 */
class ContainsFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("contains", ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ContainsFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ContainsFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-contains-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => ContainsFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ContainsFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => ContainsFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-contains-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `DoesNotContain` (**Does not contain**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 *
 * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 */
class DoesNotContainFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("doesnotcontain", ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DoesNotContainFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DoesNotContainFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-not-contains-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => DoesNotContainFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DoesNotContainFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => DoesNotContainFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-not-contains-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `EndsWith` (**Ends with**) string filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 *
 * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 */
class EndsWithFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("endswith", ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EndsWithFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: EndsWithFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-endswith-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => EndsWithFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EndsWithFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => EndsWithFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-endswith-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `Equal` (**Is equal to**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 *
 * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 */
class EqualFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("eq", ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EqualFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: EqualFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-eq-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => EqualFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EqualFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => EqualFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-eq-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `IsEmpty` (**Is empty**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 *
 * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 */
class IsEmptyFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("isempty", ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IsEmptyFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: IsEmptyFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-isempty-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => IsEmptyFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IsEmptyFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => IsEmptyFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-isempty-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `IsNotEmpty` (**Is not empty**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 *
 * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 */
class IsNotEmptyFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("isnotempty", ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IsNotEmptyFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: IsNotEmptyFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-isnotempty-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => IsNotEmptyFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IsNotEmptyFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => IsNotEmptyFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-isnotempty-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `IsNotNull` (**Is not null**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 *
 * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 */
class IsNotNullFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("isnotnull", ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IsNotNullFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: IsNotNullFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-isnotnull-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => IsNotNullFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IsNotNullFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => IsNotNullFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-isnotnull-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `IsNull` (**Is null**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 *
 * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 */
class IsNullFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("isnull", ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IsNullFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: IsNullFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-isnull-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => IsNullFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IsNullFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => IsNullFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-isnull-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `NotEqual` (**Is not equal to**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 *
 * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 */
class NotEqualFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("neq", ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NotEqualFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: NotEqualFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-neq-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => NotEqualFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NotEqualFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => NotEqualFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-neq-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `StartsWith` (**Starts with**) filter operator. [See example](slug:filtering_grid#toc-using-the-built-in-directive).
 *
 * For more information and examples, refer to the article on setting [default filter operators](slug:filter_row#toc-default-filter-operator).
 */
class StartsWithFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("startswith", ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StartsWithFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: StartsWithFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-startswith-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => StartsWithFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StartsWithFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => StartsWithFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-startswith-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `Greater` (**Is greater than**) [numeric filter](slug:filtering_grid#toc-numeric-filter) operator.
 * [See example](slug:filter_row#toc-default-filter-operator).
 */
class GreaterFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("gt", ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GreaterFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: GreaterFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-gt-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => GreaterFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GreaterFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => GreaterFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-gt-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `GreaterOrEqualTo` (**Is greater than or equal to**) [numeric filter](slug:filtering_grid#toc-numeric-filter) operator.
 * [See example](slug:filter_row#toc-default-filter-operator).
 */
class GreaterOrEqualToFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("gte", ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GreaterOrEqualToFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: GreaterOrEqualToFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-gte-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => GreaterOrEqualToFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GreaterOrEqualToFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => GreaterOrEqualToFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-gte-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `Less` (**Is less than**) [numeric filter](slug:filtering_grid#toc-numeric-filter) operator.
 *
 * [See example](slug:filter_row#toc-default-filter-operator).
 */
class LessFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("lt", ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LessFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: LessFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-lt-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => LessFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LessFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => LessFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-lt-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `LessOrEqualTo` (**Is less than or equal to**) [numeric filter](slug:filtering_grid#toc-numeric-filter) operator.
 *
 * [See example](slug:filter_row#toc-default-filter-operator).
 */
class LessOrEqualToFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("lte", ctx); }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LessOrEqualToFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: LessOrEqualToFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-lte-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => LessOrEqualToFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LessOrEqualToFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => LessOrEqualToFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-lte-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `Greater` (**Is after**) [date filter](slug:filtering_grid#toc-date-filter) operator.
 * [See example](slug:filter_row#toc-default-filter-operator).
 */
class AfterFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("after", ctx); }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: "gt"
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AfterFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: AfterFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-after-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => AfterFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AfterFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => AfterFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-after-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `GreaterOrEqualTo` (**Is after or equal to**) [date filter](slug:filtering_grid#toc-date-filter) operator.
 * [See example](slug:filter_row#toc-default-filter-operator).
 */
class AfterEqFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("after-eq", ctx); }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: "gte"
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AfterEqFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: AfterEqFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-after-eq-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => AfterEqFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AfterEqFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => AfterEqFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-after-eq-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `LessOrEqualTo` (**Is before or equal to**) [date filter](slug:filtering_grid#toc-date-filter) operator.
 * [See example](slug:filter_row#toc-default-filter-operator).
 */
class BeforeEqFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("before-eq", ctx); }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: "lte"
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BeforeEqFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BeforeEqFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-before-eq-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => BeforeEqFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BeforeEqFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => BeforeEqFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-before-eq-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the `Less than` (**Is before**) [date filter](slug:filtering_grid#toc-date-filter) operator.
 * [See example](slug:filter_row#toc-default-filter-operator).
 */
class BeforeFilterOperatorComponent extends FilterOperatorBase {
    constructor(ctx) { super("before", ctx); }
    /**
     * @hidden
     */
    toJSON() {
        return {
            text: this.text,
            value: "lt"
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BeforeFilterOperatorComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BeforeFilterOperatorComponent, isStandalone: true, selector: "kendo-filter-before-operator", providers: [
            {
                provide: FilterOperatorBase,
                useExisting: forwardRef(() => BeforeFilterOperatorComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BeforeFilterOperatorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: FilterOperatorBase,
                            useExisting: forwardRef(() => BeforeFilterOperatorComponent)
                        }
                    ],
                    selector: 'kendo-filter-before-operator',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * @hidden
*/
class SizingOptionsService {
    changes = new Subject();
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SizingOptionsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SizingOptionsService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SizingOptionsService, decorators: [{
            type: Injectable
        }] });

/**
 * Represents a component which accommodates the filter operators.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData">
 *   <kendo-grid-column field="ProductName">
 *     <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *       <input />
 *       <kendo-grid-filter-cell-operators
 *         [operators]="[{text: 'Equals', value: 'eq'}]">
 *       </kendo-grid-filter-cell-operators>
 *     </ng-template>
 *   </kendo-grid-column>
 * <kendo-grid>
 * ```
 */
class FilterCellOperatorsComponent {
    ctx;
    sizing;
    clearText = 'Clear';
    filterClearIcon = filterClearIcon;
    /**
     * @hidden
     */
    filterSVGIcon = filterIcon;
    /**
     * @hidden
     */
    size = 'medium';
    /**
     * @hidden
     */
    get hostClasses() {
        return true;
    }
    /**
     * @hidden
     */
    dropdown;
    /**
     * The filter operators that will be displayed.
     */
    operators = [];
    /**
     * Determines if the **Clear** button will be displayed.
     * @type {boolean}
     */
    showButton;
    /**
     * Determines if the list of operators will be displayed.
     * @type {boolean}
     * @default true
     */
    showOperators = true;
    /**
     * The selected operator.
     * @type {string}
     */
    value;
    /**
     * The Grid column which the filter operators are associated with.
     */
    column;
    /**
     * Fires when the operator is selected.
     * @type {EventEmitter<string>}
     */
    valueChange = new EventEmitter();
    /**
     * Fires when the **Clear** button is clicked.
     * @type {EventEmitter<undefined>}
     */
    clear = new EventEmitter();
    subs;
    constructor(ctx, sizing) {
        this.ctx = ctx;
        this.sizing = sizing;
    }
    /**
     * @hidden
     */
    onChange(dataItem) {
        this.valueChange.emit(dataItem);
    }
    /**
     * @hidden
     */
    clearClick() {
        this.clear.emit();
        return false;
    }
    /**
     * @hidden
     */
    clearKeydown(args) {
        if (args.keyCode === Keys.Enter || args.keyCode === Keys.Space) {
            this.clear.emit();
        }
    }
    /**
     * @hidden
     */
    dropdownKeydown(args) {
        if (args.defaultPrevented) {
            return;
        }
        if (args.keyCode === Keys.Enter && !this.dropdown.isOpen) {
            this.dropdown.toggle(true);
            args.preventDefault();
        }
    }
    ngOnInit() {
        this.subs = this.ctx.localization.changes.subscribe(() => this.clearText = this.ctx.localization.get('filterClearButton'));
        this.subs.add(this.sizing.changes.subscribe((size) => this.size = size));
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('filterCellOperatorLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterCellOperatorsComponent, deps: [{ token: ContextService }, { token: SizingOptionsService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: FilterCellOperatorsComponent, isStandalone: true, selector: "kendo-grid-filter-cell-operators", inputs: { operators: "operators", showButton: "showButton", showOperators: "showOperators", value: "value", column: "column" }, outputs: { valueChange: "valueChange", clear: "clear" }, host: { properties: { "class.k-filtercell-operator": "this.hostClasses" } }, viewQueries: [{ propertyName: "dropdown", first: true, predicate: ["dropdown"], descendants: true }], ngImport: i0, template: `
        <kendo-dropdownlist
            #dropdown
            *ngIf="showOperators"
            kendoGridFocusable
            [attr.aria-label]="column && columnLabel"
            [data]="operators"
            class="k-dropdown-operator"
            (valueChange)="onChange($event)"
            [value]="value"
            icon="filter"
            [svgIcon]="filterSVGIcon"
            [valuePrimitive]="true"
            textField="text"
            [popupSettings]="{ width: 'auto' }"
            valueField="value"
            [size]="size"
            (keydown)="dropdownKeydown($event)">
        </kendo-dropdownlist>
        <button type="button"
            kendoButton
            kendoGridFocusable
            *ngIf="showButton"
            icon="filter-clear"
            [svgIcon]="filterClearIcon"
            [title]="clearText"
            [size]="size"
            (click)="clearClick()"
            (keydown)="clearKeydown($event)"></button>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: DropDownListComponent, selector: "kendo-dropdownlist", inputs: ["customIconClass", "showStickyHeader", "icon", "svgIcon", "loading", "data", "value", "textField", "valueField", "adaptiveMode", "title", "subtitle", "popupSettings", "listHeight", "defaultItem", "disabled", "itemDisabled", "readonly", "filterable", "virtual", "ignoreCase", "delay", "valuePrimitive", "tabindex", "tabIndex", "size", "rounded", "fillMode", "leftRightArrowsNavigation", "id"], outputs: ["valueChange", "filterChange", "selectionChange", "open", "opened", "close", "closed", "focus", "blur"], exportAs: ["kendoDropDownList"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: ["kendoGridFocusable"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterCellOperatorsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-filter-cell-operators',
                    template: `
        <kendo-dropdownlist
            #dropdown
            *ngIf="showOperators"
            kendoGridFocusable
            [attr.aria-label]="column && columnLabel"
            [data]="operators"
            class="k-dropdown-operator"
            (valueChange)="onChange($event)"
            [value]="value"
            icon="filter"
            [svgIcon]="filterSVGIcon"
            [valuePrimitive]="true"
            textField="text"
            [popupSettings]="{ width: 'auto' }"
            valueField="value"
            [size]="size"
            (keydown)="dropdownKeydown($event)">
        </kendo-dropdownlist>
        <button type="button"
            kendoButton
            kendoGridFocusable
            *ngIf="showButton"
            icon="filter-clear"
            [svgIcon]="filterClearIcon"
            [title]="clearText"
            [size]="size"
            (click)="clearClick()"
            (keydown)="clearKeydown($event)"></button>
    `,
                    standalone: true,
                    imports: [NgIf, DropDownListComponent, FocusableDirective, ButtonComponent]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }, { type: SizingOptionsService }]; }, propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-filtercell-operator']
            }], dropdown: [{
                type: ViewChild,
                args: ['dropdown', { static: false }]
            }], operators: [{
                type: Input
            }], showButton: [{
                type: Input
            }], showOperators: [{
                type: Input
            }], value: [{
                type: Input
            }], column: [{
                type: Input
            }], valueChange: [{
                type: Output
            }], clear: [{
                type: Output
            }] } });

/**
 * @hidden
 */
class FilterInputDirective {
    element;
    renderer;
    change = new EventEmitter();
    composing = false;
    kendoInput;
    filterDelay = 500;
    columnLabel;
    set value(value) {
        this.accessor.writeValue(value);
    }
    set disabled(value) {
        this.accessor.setDisabledState(value);
    }
    accessor;
    changeRequests = new Subject();
    changeRequestsSubscription;
    unsubscribeEvents;
    constructor(valueAccessors, ngZone, element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.accessor = valueAccessors[0];
        ngZone.runOutsideAngular(() => {
            const unsubscribeStart = renderer.listen(element.nativeElement, 'compositionstart', () => this.composing = true);
            const unsubscribeEnd = renderer.listen(element.nativeElement, 'compositionend', () => this.composing = false);
            this.unsubscribeEvents = () => {
                unsubscribeStart();
                unsubscribeEnd();
            };
        });
    }
    ngAfterViewInit() {
        this.addAriaAttributes();
        this.accessor.registerOnChange(x => this.filterDelay > 0 ?
            this.changeRequests.next(x) :
            this.change.emit(x));
        this.subscribeChanges();
    }
    ngOnChanges(changes) {
        if (isChanged$1('filterDelay', changes)) {
            this.unsubscribeChanges();
            this.subscribeChanges();
        }
    }
    ngOnDestroy() {
        this.unsubscribeChanges();
        this.unsubscribeEvents();
    }
    subscribeChanges() {
        this.changeRequestsSubscription = this.changeRequests
            .pipe(debounceTime(this.filterDelay), filter(() => !this.composing))
            .subscribe(x => this.change.emit(x));
    }
    unsubscribeChanges() {
        if (this.changeRequestsSubscription) {
            this.changeRequestsSubscription.unsubscribe();
        }
    }
    addAriaAttributes() {
        const ariaValue = this.columnLabel;
        if (this.kendoInput && this.kendoInput.focusableId && isDocumentAvailable()) {
            const focusableElement = this.element.nativeElement.querySelector(`#${this.kendoInput.focusableId}`) ||
                this.element.nativeElement;
            this.renderer.setAttribute(focusableElement, 'aria-label', ariaValue);
        }
        else {
            const inputElement = this.element.nativeElement.querySelector('.k-input-inner');
            const elementToSetLabel = inputElement ? inputElement : this.element.nativeElement;
            if (ariaValue) {
                this.renderer.setAttribute(elementToSetLabel, 'aria-label', ariaValue);
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterInputDirective, deps: [{ token: NG_VALUE_ACCESSOR, self: true }, { token: i0.NgZone }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: FilterInputDirective, isStandalone: true, selector: "[kendoFilterInput]", inputs: { filterDelay: "filterDelay", columnLabel: "columnLabel", value: "value" }, queries: [{ propertyName: "kendoInput", first: true, predicate: KendoInput, descendants: true, static: true }], usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterInputDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoFilterInput]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Self
                }, {
                    type: Inject,
                    args: [NG_VALUE_ACCESSOR]
                }] }, { type: i0.NgZone }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { kendoInput: [{
                type: ContentChild,
                args: [KendoInput, { static: true }]
            }], filterDelay: [{
                type: Input
            }], columnLabel: [{
                type: Input
            }], value: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class MenuTabbingService {
    firstFocusable;
    lastFocusable;
    isColumnMenu = false;
    isPopupOpen = false;
    lastMenuItem;
    isTabbedInterface = false;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MenuTabbingService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MenuTabbingService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MenuTabbingService, decorators: [{
            type: Injectable
        }] });

/**
 * Represents a service to set the filter descriptor
 * ([see example]({% slug filter_row %}#toc-custom-filter-row-components)).
 */
class FilterService {
    /**
     * @hidden
     */
    menuTabbingService;
    /**
     * Fires when the filter descriptors is set.
     */
    changes = new Subject();
    /**
     * Sets the filter descriptor.
     *
     * @param {CompositeFilterDescriptor} value - The filter descriptor that will be set.
     */
    filter(value) {
        this.changes.next(value);
    }
    /**
     * @hidden
     */
    constructor(menuTabbingService) {
        this.menuTabbingService = menuTabbingService;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterService, deps: [{ token: MenuTabbingService, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: MenuTabbingService, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * @hidden
 */
class ScrollSyncService {
    ngZone;
    changes = new Subject();
    elements = [];
    source;
    subscriptions = new Subscription();
    headerSubscription = new Subscription();
    bodySubscription = new Subscription();
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.subscriptions.add(this.changes.subscribe(args => this.scrollLeft(args)));
    }
    registerEmitter(el, sourceType) {
        this.unregister(sourceType);
        this.elements.push({ element: el, sourceType });
        if (sourceType === "body" || sourceType === "header") {
            this.ngZone.runOutsideAngular(() => {
                const obs = fromEvent(el, "scroll").pipe(map(({ target: { scrollLeft } }) => ({
                    scrollLeft,
                    sourceType
                })));
                const subscription = obs.pipe(distinctUntilChanged((x, y) => (x.scrollLeft === y.scrollLeft)), filter(x => !this.source || this.source === x.sourceType), tap(x => this.source = x.sourceType))
                    .subscribe((x) => this.changes.next(x));
                subscription.add(obs.pipe(filter(x => this.source && this.source !== x.sourceType))
                    .subscribe(() => this.source = undefined));
                if (sourceType === "body") {
                    this.bodySubscription.add(subscription);
                }
                else {
                    this.headerSubscription.add(subscription);
                }
            });
        }
    }
    /**
     * destroy
     */
    destroy() {
        this.subscriptions.unsubscribe();
        this.headerSubscription.unsubscribe();
        this.bodySubscription.unsubscribe();
    }
    scrollLeft({ scrollLeft, sourceType }) {
        this.ngZone.runOutsideAngular(() => {
            this.elements
                .filter(x => sourceType !== x.sourceType)
                .forEach(({ element }) => element.scrollLeft = scrollLeft);
        });
    }
    unregister(sourceType) {
        const index = this.elements.findIndex(x => x.sourceType === sourceType);
        if (index > -1) {
            if (sourceType === "header") {
                this.headerSubscription.unsubscribe();
                this.headerSubscription = new Subscription();
            }
            else if (sourceType === "body") {
                this.bodySubscription.unsubscribe();
                this.bodySubscription = new Subscription();
            }
            this.elements.splice(index, 1);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ScrollSyncService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ScrollSyncService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ScrollSyncService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });

const contains = (node, predicate) => {
    while (node) {
        if (predicate(node)) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
};
/**
 * Arguments for the `close` event of the filter and column-menu popup.
 */
class PopupCloseEvent extends PreventableEvent {
    /**
     * The original DOM event that causes the popup to close.
     */
    originalEvent;
    constructor(e) {
        super();
        this.originalEvent = e;
    }
}
const DEFAULT_POPUP_CLASS = 'k-grid-filter-popup';
/**
 * The service that is used for the popups of the filter and column menus
 * ([see example]({% slug filter_menu %}#toc-filter-menu-with-popup)).
 */
class SinglePopupService {
    popupService;
    renderer;
    ngZone;
    ctx;
    /**
     * Fires when the filter or column menus are about to close because the user clicked outside their popups.
     * Used to prevent the popup from closing.
     */
    onClose = new Subject();
    removeClick;
    pointerEventsSub = new Subscription();
    popupRef;
    scrollSubscription;
    canClosePopup = true;
    /**
     * @hidden
     */
    constructor(popupService, renderer, ngZone, scrollSyncService, ctx) {
        this.popupService = popupService;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.ctx = ctx;
        this.scrollSubscription = scrollSyncService.changes.pipe(skip(1)).subscribe(() => this.destroy());
    }
    /**
     * @hidden
     */
    open(anchor, template, popupRef, popupClass = DEFAULT_POPUP_CLASS) {
        const toggle = isPresent(popupRef) && this.popupRef === popupRef;
        this.destroy();
        if (!toggle) {
            const direction = this.ctx.localization.rtl ? 'right' : 'left';
            this.popupRef = this.popupService.open({
                anchorAlign: { vertical: 'bottom', horizontal: direction },
                popupAlign: { vertical: 'top', horizontal: direction },
                anchor: anchor,
                popupClass: popupClass,
                content: template,
                positionMode: "absolute"
            });
            this.renderer.setAttribute(this.popupRef.popupElement, 'dir', this.ctx.localization.rtl ? 'rtl' : 'ltr');
            this.attachClose(anchor);
        }
        const popupEl = this.popupRef?.popupElement;
        if (popupEl) {
            this.attachMouseListeners(popupEl);
        }
        return this.popupRef;
    }
    /**
     * @hidden
     */
    destroy() {
        if (this.popupRef) {
            this.detachClose();
            this.pointerEventsSub.unsubscribe();
            this.pointerEventsSub = null;
            this.popupRef.close();
            this.popupRef = null;
        }
    }
    ngOnDestroy() {
        this.destroy();
        this.scrollSubscription.unsubscribe();
    }
    detachClose() {
        if (this.removeClick) {
            this.removeClick();
        }
    }
    attachClose(skipElement) {
        if (!isDocumentAvailable()) {
            return;
        }
        this.detachClose();
        this.ngZone.runOutsideAngular(() => this.removeClick = this.renderer.listen('document', 'click', (e) => {
            if (!contains(e.target, x => this.popupRef.popupElement === x || x === skipElement)) {
                const args = new PopupCloseEvent(e);
                this.onClose.next(args);
                if (!args.isDefaultPrevented() && this.canClosePopup) {
                    this.destroy();
                }
                this.canClosePopup = true;
            }
        }));
    }
    attachMouseListeners(el) {
        this.pointerEventsSub = new Subscription();
        this.ngZone.runOutsideAngular(() => {
            this.pointerEventsSub.add(this.renderer.listen(el, 'pointerdown', (e) => {
                e.stopImmediatePropagation();
                this.canClosePopup = false;
            }));
            this.pointerEventsSub.add(this.renderer.listen(el, 'pointerup', () => {
                this.canClosePopup = true;
            }));
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SinglePopupService, deps: [{ token: i5.PopupService }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: ScrollSyncService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SinglePopupService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SinglePopupService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i5.PopupService }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: ScrollSyncService }, { type: ContextService }]; } });

const insertDefaultFilter = (index, rootFilter, filter) => {
    rootFilter = (rootFilter || { filters: [], logic: "and" });
    rootFilter.filters[index] = filter;
    return filter;
};
/**
 * @hidden
 */
const setFilter = (index, filter, field, defaultOperator) => {
    if (isPresent(filter) && isPresent(filter.filters) && filter.filters.length > index) {
        return filter.filters[index];
    }
    else {
        return insertDefaultFilter(index, filter, {
            field,
            operator: defaultOperator
        });
    }
};
/**
 * @hidden
 */
const logicOperators = (localization) => [
    { text: localization.get("filterAndLogic"), value: "and" },
    { text: localization.get("filterOrLogic"), value: "or" }
];
/**
 * @hidden
 */
const flatten = (filter) => {
    if (isPresent(filter.filters)) {
        return filter.filters.reduce((acc, curr) => acc.concat(isCompositeFilterDescriptor(curr) ? flatten(curr) : [curr]), []);
    }
    return [];
};
const trimFilterByField = (filter, field) => {
    if (isPresent(filter) && isPresent(filter.filters)) {
        filter.filters = filter.filters.filter(x => {
            if (isCompositeFilterDescriptor(x)) {
                trimFilterByField(x, field);
                return x.filters.length;
            }
            else {
                return x.field !== field;
            }
        });
    }
};
/**
 * @hidden
 */
const filtersByField = (filter, field) => flatten(filter || {}).filter(x => x.field === field);
/**
 * @hidden
 */
const filterByField = (filter, field) => {
    const [currentFilter] = filtersByField(filter, field);
    return currentFilter;
};
/**
 * @hidden
 */
const removeFilter = (filter, field) => {
    trimFilterByField(filter, field);
    return filter;
};
/**
 * @hidden
 */
const localizeOperators = operators => localization => Object.keys(operators).map(key => ({
    text: localization.get(key),
    value: operators[key]
}));
/**
 * An abstract base class for the filter-cell component ([see example]({% slug filter_row %}#toc-custom-filter-row-components)).
 */
class BaseFilterCellComponent {
    filterService;
    get hostClasses() {
        return true;
    }
    operatorList = new QueryList();
    get operators() {
        return this._operators?.length ? this._operators : this.defaultOperators;
    }
    set operators(values) {
        this._operators = values;
    }
    /**
     * @hidden
     */
    size = 'medium';
    /**
     * The current root filter.
     * @type {CompositeFilterDescriptor}
     */
    filter;
    defaultOperators;
    _operators;
    operationListSubscription;
    constructor(filterService) {
        this.filterService = filterService;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.operationListSubscription = observe(this.operatorList)
            .pipe(map(q => q.toArray()), map(toJSON))
            .subscribe(x => {
            this.operators = x;
        });
    }
    ngOnDestroy() {
        if (this.operationListSubscription) {
            this.operationListSubscription.unsubscribe();
        }
    }
    filterByField(field) {
        return filterByField(this.filter, field);
    }
    filtersByField(field) {
        return filtersByField(this.filter, field);
    }
    removeFilter(field) {
        return removeFilter(this.filter, field);
    }
    updateFilter(filter) {
        const root = this.filter || {
            filters: [],
            logic: "and"
        };
        const [currentFilter] = flatten(root).filter(x => x.field === filter.field);
        if (!isPresent(currentFilter)) {
            root.filters.push(filter);
        }
        else {
            Object.assign(currentFilter, filter);
        }
        return root;
    }
    applyFilter(filter) {
        this.filterService.filter(filter);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BaseFilterCellComponent, deps: [{ token: FilterService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: BaseFilterCellComponent, inputs: { operators: "operators", filter: "filter" }, host: { properties: { "class.k-filtercell": "this.hostClasses" } }, queries: [{ propertyName: "operatorList", predicate: FilterOperatorBase }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BaseFilterCellComponent, decorators: [{
            type: Directive,
            args: [{}]
        }], ctorParameters: function () { return [{ type: FilterService }]; }, propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-filtercell']
            }], operatorList: [{
                type: ContentChildren,
                args: [FilterOperatorBase]
            }], operators: [{
                type: Input
            }], filter: [{
                type: Input
            }] } });

const areDifferent = (a, b) => a.field !== b.field || a.operator !== b.operator || a.value !== b.value;
const isChanged = (a, b) => {
    if (a.length !== b.length) {
        return true;
    }
    for (let idx = 0, len = a.length; idx < len; idx++) {
        const prev = a[idx];
        const curr = b[idx];
        if (isCompositeFilterDescriptor(prev)) {
            if (diffFilters(prev, curr[idx])) {
                return true;
            }
        }
        else if (areDifferent(prev, curr)) {
            return true;
        }
    }
    return false;
};
const copyObject = (obj) => {
    const result = {};
    Object.assign(result, obj);
    if (obj.constructor !== Object) {
        const proto = obj.constructor.prototype;
        Object.getOwnPropertyNames(proto).forEach((property) => {
            if (property !== 'constructor' && proto.hasOwnProperty(property)) {
                result[property] = obj[property];
            }
        });
    }
    return result;
};
const cloneFilter = (filter) => copyObject(filter);
/**
 * @hidden
 */
const cloneFilters = (filter) => {
    if (!filter) {
        return;
    }
    if (isCompositeFilterDescriptor(filter)) {
        return {
            filters: cloneFilters(filter.filters),
            logic: filter.logic
        };
    }
    else if (Array.isArray(filter)) {
        return filter.map(cloneFilters);
    }
    return cloneFilter(filter);
};
/**
 * @hidden
 */
const diffFilters = (a, b) => {
    if (isPresent(a) && !isPresent(b)) {
        return true;
    }
    if (!isPresent(a) && isPresent(b)) {
        return true;
    }
    return isPresent(a) && isPresent(b) && isChanged(a.filters, b.filters);
};

/**
 * @hidden
 */
class FilterHostDirective {
    host;
    resolver;
    column;
    filter;
    component;
    constructor(host, resolver) {
        this.host = host;
        this.resolver = resolver;
    }
    ngOnInit() {
        this.component = this.host.createComponent(this.resolver.resolveComponentFactory(this.componentType()));
        this.initComponent({
            column: this.column,
            filter: this.filter
        });
    }
    ngOnDestroy() {
        if (this.component) {
            this.component.destroy();
            this.component = null;
        }
    }
    ngOnChanges(changes) {
        if (anyChanged(["column", "filter"], changes)) {
            this.initComponent({
                column: this.column,
                filter: this.filter
            });
        }
    }
    initComponent({ column, filter }) {
        const instance = this.component.instance;
        instance.column = column;
        instance.filter = filter;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterHostDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: FilterHostDirective, selector: "[kendoGridFilterHostBase]", inputs: { column: "column", filter: "filter" }, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterHostDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridFilterHostBase]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.ComponentFactoryResolver }]; }, propDecorators: { column: [{
                type: Input
            }], filter: [{
                type: Input
            }] } });

// eslint-disable no-access-missing-member
const stringOperators$1 = localizeOperators({
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    "filterContainsOperator": "contains",
    "filterNotContainsOperator": "doesnotcontain",
    "filterStartsWithOperator": "startswith",
    "filterEndsWithOperator": "endswith",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull",
    "filterIsEmptyOperator": "isempty",
    "filterIsNotEmptyOperator": "isnotempty"
});
/**
 * Represents a base string filter component.
 */
class StringFilterComponent extends BaseFilterCellComponent {
    ctx;
    /**
     * The column with which the filter is associated.
     * @type {ColumnComponent}
     */
    column;
    /**
     * The default filter operator.
     * @type {string}
     * @default 'contains'
     */
    operator = "contains";
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this.filterByField((this.column || {}).field);
    }
    /**
     * The current filter operator for the associated column field.
     * @readonly
     * @type {string}
     */
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : this.operator;
    }
    subscription;
    constructor(filterService, ctx) {
        super(filterService);
        this.ctx = ctx;
    }
    ngOnInit() {
        this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    localizationChange() {
        this.defaultOperators = stringOperators$1(this.ctx.localization);
        if (this.operatorList.length) {
            this.operators = toJSON(this.operatorList.toArray());
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StringFilterComponent, deps: [{ token: FilterService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: StringFilterComponent, inputs: { column: "column", operator: "operator" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StringFilterComponent, decorators: [{
            type: Directive,
            args: [{}]
        }], ctorParameters: function () { return [{ type: FilterService }, { type: ContextService }]; }, propDecorators: { column: [{
                type: Input
            }], operator: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class FilterMenuDropDownListDirective {
    host;
    filterMenuDropDownLabel;
    constructor(host) {
        this.host = host;
    }
    ngAfterViewInit() {
        const wrapperElement = this.host.wrapper.nativeElement;
        wrapperElement.setAttribute('aria-label', this.filterMenuDropDownLabel);
        wrapperElement.addEventListener('keydown', this.keydownHandler, true);
    }
    ngOnDestroy() {
        this.host.wrapper.nativeElement.removeEventListener('keydown', this.keydownHandler);
    }
    keydownHandler = (e) => {
        if (e.keyCode === Keys.Escape && this.host.isOpen) {
            e.stopPropagation();
            this.host.toggle(false);
        }
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterMenuDropDownListDirective, deps: [{ token: i1$5.DropDownListComponent }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: FilterMenuDropDownListDirective, isStandalone: true, selector: "[kendoFilterMenuDropDown]", inputs: { filterMenuDropDownLabel: "filterMenuDropDownLabel" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterMenuDropDownListDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoFilterMenuDropDown]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i1$5.DropDownListComponent }]; }, propDecorators: { filterMenuDropDownLabel: [{
                type: Input
            }] } });

const EMPTY_VALUE_OPERATORS = new Set(['isnull', 'isnotnull', 'isempty', 'isnotempty']);
const isEmptyValueOperator = (operator) => EMPTY_VALUE_OPERATORS.has(operator);
/**
 * @hidden
 */
class FilterInputWrapperComponent extends BaseFilterCellComponent {
    column;
    input;
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    get currentOperator() {
        const filter = this.currentFilter;
        if (!this._operator) {
            this._operator = filter ? filter.operator : this.defaultOperator;
        }
        return this._operator;
    }
    set currentOperator(value) {
        this._operator = value;
        const emptyValueOperator = isEmptyValueOperator(value);
        this.filterInputDisabled = emptyValueOperator;
        if (emptyValueOperator) {
            this.applyNoValueFilter(value);
        }
        else if (!isBlank(value) && isPresent(this.currentFilter)) {
            this.onChange(this.currentFilter.value);
        }
    }
    get defaultOperator() {
        if (!isNullOrEmptyString(this._defaultOperator)) {
            return this._defaultOperator;
        }
        else if (this.operators && this.operators.length) {
            return this.operators[0].value;
        }
        return "eq";
    }
    set defaultOperator(value) {
        this._defaultOperator = value;
    }
    set filterInputDisabled(disabled) {
        if (!this.input) {
            return;
        }
        this.input.disabled = disabled;
    }
    _defaultOperator;
    _operator;
    changeSubscription;
    constructor(filterService) {
        super(filterService);
    }
    ngAfterContentInit() {
        if (isPresent(this.input)) {
            this.changeSubscription = this.input.change.subscribe(this.onChange.bind(this));
            this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this.changeSubscription) {
            this.changeSubscription.unsubscribe();
        }
    }
    onChange(value) {
        if (!isNullOrEmptyString(value) || this.filterByField(this.column.field)) {
            this.filterChange(isNullOrEmptyString(value) ?
                this.removeFilter(this.column.field) :
                this.updateFilter({
                    field: this.column.field,
                    operator: this.currentOperator,
                    value: value
                }));
        }
    }
    onClear() {
        this.onChange(null);
        this.filterInputDisabled = isEmptyValueOperator(this.defaultOperator);
    }
    applyNoValueFilter(operator) {
        this.filterChange(this.updateFilter({
            field: this.column.field,
            operator: operator,
            value: null
        }));
    }
    ngOnChanges(changes) {
        if (isChanged$1("filter", changes, false)) {
            this._operator = null;
            this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterInputWrapperComponent, deps: [{ token: FilterService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: FilterInputWrapperComponent, inputs: { column: "column", defaultOperator: "defaultOperator" }, queries: [{ propertyName: "input", first: true, predicate: FilterInputDirective, descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterInputWrapperComponent, decorators: [{
            type: Directive,
            args: [{}]
        }], ctorParameters: function () { return [{ type: FilterService }]; }, propDecorators: { column: [{
                type: Input
            }], input: [{
                type: ContentChild,
                args: [FilterInputDirective, { static: false }]
            }], defaultOperator: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class FilterMenuInputWrapperComponent extends FilterInputWrapperComponent {
    ctx;
    filterService;
    isFirstDropDown;
    menuTabbingService;
    firstOperatorDropDown;
    _currentFilter;
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    constructor(ctx) {
        super(null);
        this.ctx = ctx;
    }
    ngAfterViewInit() {
        const shouldFocusFirstFocusable = this.isFirstDropDown && this.filterService && this.filterService.menuTabbingService;
        const isTabbedInterface = this.menuTabbingService?.isTabbedInterface;
        if (shouldFocusFirstFocusable && !isTabbedInterface) {
            this.filterService.menuTabbingService.firstFocusable = this.firstOperatorDropDown;
            this.firstOperatorDropDown.focus();
        }
    }
    operatorChange(dataItem) {
        this.currentOperator = dataItem;
    }
    filterChange(filter) {
        this.applyFilter(filter);
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this._currentFilter;
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    set currentFilter(value) {
        this._currentFilter = value;
    }
    updateFilter(filter) {
        Object.assign(this.currentFilter, filter);
        return this.filter;
    }
    onChange(value) {
        this.filterChange(this.updateFilter({
            field: this.column.field,
            operator: this.currentOperator,
            value: value
        }));
    }
    onShiftTab(e) {
        e.stopImmediatePropagation();
        if ((!this.menuTabbingService || !this.menuTabbingService.isColumnMenu) && this.isFirstDropDown && this.filterService.menuTabbingService.lastFocusable) {
            e.preventDefault();
            this.filterService.menuTabbingService.lastFocusable.focus();
        }
    }
    get filterMenuDropDownLabel() {
        const localizationMsg = this.ctx.localization.get('filterMenuOperatorsDropDownLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterMenuInputWrapperComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: FilterMenuInputWrapperComponent, isStandalone: true, selector: "kendo-grid-filter-menu-input-wrapper", inputs: { filterService: "filterService", isFirstDropDown: "isFirstDropDown", menuTabbingService: "menuTabbingService", currentFilter: "currentFilter" }, viewQueries: [{ propertyName: "firstOperatorDropDown", first: true, predicate: DropDownListComponent, descendants: true }], usesInheritance: true, ngImport: i0, template: `
        <kendo-dropdownlist
            kendoFilterMenuDropDown
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            [data]="operators"
            (valueChange)="operatorChange($event)"
            [value]="currentOperator"
            [valuePrimitive]="true"
            textField="text"
            valueField="value"
            (keydown.shift.tab)="onShiftTab($event)">
        </kendo-dropdownlist>
        <ng-content></ng-content>
    `, isInline: true, dependencies: [{ kind: "component", type: DropDownListComponent, selector: "kendo-dropdownlist", inputs: ["customIconClass", "showStickyHeader", "icon", "svgIcon", "loading", "data", "value", "textField", "valueField", "adaptiveMode", "title", "subtitle", "popupSettings", "listHeight", "defaultItem", "disabled", "itemDisabled", "readonly", "filterable", "virtual", "ignoreCase", "delay", "valuePrimitive", "tabindex", "tabIndex", "size", "rounded", "fillMode", "leftRightArrowsNavigation", "id"], outputs: ["valueChange", "filterChange", "selectionChange", "open", "opened", "close", "closed", "focus", "blur"], exportAs: ["kendoDropDownList"] }, { kind: "directive", type: FilterMenuDropDownListDirective, selector: "[kendoFilterMenuDropDown]", inputs: ["filterMenuDropDownLabel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterMenuInputWrapperComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-filter-menu-input-wrapper',
                    template: `
        <kendo-dropdownlist
            kendoFilterMenuDropDown
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            [data]="operators"
            (valueChange)="operatorChange($event)"
            [value]="currentOperator"
            [valuePrimitive]="true"
            textField="text"
            valueField="value"
            (keydown.shift.tab)="onShiftTab($event)">
        </kendo-dropdownlist>
        <ng-content></ng-content>
    `,
                    standalone: true,
                    imports: [DropDownListComponent, FilterMenuDropDownListDirective]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; }, propDecorators: { filterService: [{
                type: Input
            }], isFirstDropDown: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }], firstOperatorDropDown: [{
                type: ViewChild,
                args: [DropDownListComponent, { static: false }]
            }], currentFilter: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class StringFilterMenuInputComponent {
    ctx;
    operators = [];
    column;
    filter;
    operator;
    currentFilter;
    filterService;
    isFirstDropDown;
    menuTabbingService;
    placeholder;
    constructor(ctx) {
        this.ctx = ctx;
    }
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StringFilterMenuInputComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: StringFilterMenuInputComponent, isStandalone: true, selector: "kendo-grid-string-filter-menu-input", inputs: { operators: "operators", column: "column", filter: "filter", operator: "operator", currentFilter: "currentFilter", filterService: "filterService", isFirstDropDown: "isFirstDropDown", menuTabbingService: "menuTabbingService", placeholder: "placeholder" }, ngImport: i0, template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService"
            >
            <kendo-textbox
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="0"
                [placeholder]="placeholder"
                [ngModel]="currentFilter?.value ?? null">
            </kendo-textbox>
        </kendo-grid-filter-menu-input-wrapper>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterMenuInputWrapperComponent, selector: "kendo-grid-filter-menu-input-wrapper", inputs: ["filterService", "isFirstDropDown", "menuTabbingService", "currentFilter"] }, { kind: "component", type: TextBoxComponent, selector: "kendo-textbox", inputs: ["focusableId", "title", "type", "disabled", "readonly", "tabindex", "value", "selectOnFocus", "showSuccessIcon", "showErrorIcon", "clearButton", "successIcon", "successSvgIcon", "errorIcon", "errorSvgIcon", "clearButtonIcon", "clearButtonSvgIcon", "size", "rounded", "fillMode", "tabIndex", "placeholder", "maxlength", "inputAttributes"], outputs: ["valueChange", "inputFocus", "inputBlur", "focus", "blur"], exportAs: ["kendoTextBox"] }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i4.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StringFilterMenuInputComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-string-filter-menu-input',
                    template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService"
            >
            <kendo-textbox
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="0"
                [placeholder]="placeholder"
                [ngModel]="currentFilter?.value ?? null">
            </kendo-textbox>
        </kendo-grid-filter-menu-input-wrapper>
    `,
                    standalone: true,
                    imports: [FilterMenuInputWrapperComponent, TextBoxComponent, FilterInputDirective, FormsModule]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; }, propDecorators: { operators: [{
                type: Input
            }], column: [{
                type: Input
            }], filter: [{
                type: Input
            }], operator: [{
                type: Input
            }], currentFilter: [{
                type: Input
            }], filterService: [{
                type: Input
            }], isFirstDropDown: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }], placeholder: [{
                type: Input
            }] } });

/**
 * Represents a string-filter menu component
 * ([see example](slug:filter_menu#toc-built-in-filter-menu-components)).
 *
 * ```html
 * <kendo-grid-column field="ProductName">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-string-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *     </kendo-grid-string-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class StringFilterMenuComponent extends StringFilterComponent {
    logicOperators = logicOperators(this.ctx.localization);
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    /**
     * The current menu filter.
     * @type {CompositeFilterDescriptor}
     */
    filter = { filters: [], logic: "and" };
    /**
     * Determines if the inputs of second criteria will displayed.
     * @default true
     */
    extra = true;
    /**
     * The `FilterService` instance which is responsible for handling the changes in the filter descriptor.
     */
    filterService;
    /**
     * The placeholder text for the filter input.
     * @type {string}
     */
    placeholder;
    /**
     * The placeholder text for the second filter input. Applies when `extra` is set to `true`.
     * @type {string}
     */
    extraPlaceholder;
    /**
     * @hidden
     */
    menuTabbingService;
    constructor(ctx) {
        super(null, ctx);
    }
    get firstFilter() {
        return setFilter(0, this.filter, (this.column || {}).field, this.operator);
    }
    get secondFilter() {
        return setFilter(1, this.filter, (this.column || {}).field, this.operator);
    }
    logicChange(value) {
        this.filter.logic = value;
    }
    get filterMenuDropDownLabel() {
        const localizationMsg = this.ctx.localization.get('filterMenuLogicDropDownLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    localizationChange() {
        this.logicOperators = logicOperators(this.ctx.localization);
        super.localizationChange();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StringFilterMenuComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: StringFilterMenuComponent, isStandalone: true, selector: "kendo-grid-string-filter-menu", inputs: { filter: "filter", extra: "extra", filterService: "filterService", placeholder: "placeholder", extraPlaceholder: "extraPlaceholder", menuTabbingService: "menuTabbingService" }, host: { properties: { "class.k-filtercell": "this.hostClasses" } }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-string-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [isFirstDropDown]="true"
            [placeholder]="placeholder"
            [menuTabbingService]="menuTabbingService">
        </kendo-grid-string-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            kendoFilterMenuDropDown
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true" (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-grid-string-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [placeholder]="extraPlaceholder"
            [menuTabbingService]="menuTabbingService">
        </kendo-grid-string-filter-menu-input>
    `, isInline: true, dependencies: [{ kind: "component", type: StringFilterMenuInputComponent, selector: "kendo-grid-string-filter-menu-input", inputs: ["operators", "column", "filter", "operator", "currentFilter", "filterService", "isFirstDropDown", "menuTabbingService", "placeholder"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: DropDownListComponent, selector: "kendo-dropdownlist", inputs: ["customIconClass", "showStickyHeader", "icon", "svgIcon", "loading", "data", "value", "textField", "valueField", "adaptiveMode", "title", "subtitle", "popupSettings", "listHeight", "defaultItem", "disabled", "itemDisabled", "readonly", "filterable", "virtual", "ignoreCase", "delay", "valuePrimitive", "tabindex", "tabIndex", "size", "rounded", "fillMode", "leftRightArrowsNavigation", "id"], outputs: ["valueChange", "filterChange", "selectionChange", "open", "opened", "close", "closed", "focus", "blur"], exportAs: ["kendoDropDownList"] }, { kind: "directive", type: FilterMenuDropDownListDirective, selector: "[kendoFilterMenuDropDown]", inputs: ["filterMenuDropDownLabel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StringFilterMenuComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-string-filter-menu',
                    template: `
        <kendo-grid-string-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [isFirstDropDown]="true"
            [placeholder]="placeholder"
            [menuTabbingService]="menuTabbingService">
        </kendo-grid-string-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            kendoFilterMenuDropDown
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true" (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-grid-string-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [placeholder]="extraPlaceholder"
            [menuTabbingService]="menuTabbingService">
        </kendo-grid-string-filter-menu-input>
    `,
                    standalone: true,
                    imports: [StringFilterMenuInputComponent, NgIf, DropDownListComponent, FilterMenuDropDownListDirective]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; }, propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-filtercell']
            }], filter: [{
                type: Input
            }], extra: [{
                type: Input
            }], filterService: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], extraPlaceholder: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }] } });

// eslint-disable no-access-missing-member
const numericOperators = localizeOperators({
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    "filterGteOperator": "gte",
    "filterGtOperator": "gt",
    "filterLteOperator": "lte",
    "filterLtOperator": "lt",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull"
});
/**
 * Represents a base numeric filter component.
 */
class NumericFilterComponent extends BaseFilterCellComponent {
    ctx;
    /**
     * The column with which the filter is associated.
     * @type {ColumnComponent}
     */
    column;
    /**
     * The default filter operator.
     * @type {string}
     * @default 'eq'
     */
    operator = "eq";
    /**
     * Specifies the value that is used to increment or decrement the component value.
     * @type {numeric}
     * @default 1
     */
    step = 1;
    /**
     * Specifies the smallest value that is valid.
     * @type {number}
     */
    min;
    /**
     * Specifies the greatest value that is valid.
     * @type {number}
     */
    max;
    /**
     * Specifies whether the **Up** and **Down** spin buttons will be rendered.
     * @type {boolean}
     * @default true
     */
    spinners = true;
    /**
     * Specifies the number precision applied to the component value when it is focused.
     * If the user enters a number with a greater precision than is currently configured, the component value is rounded.
     *
     * @type {number}
     */
    decimals;
    /**
     * Specifies the number format used when the component is not focused.
     * By default, the `column.format` value is used (if set).
     */
    get format() {
        return !isNullOrEmptyString(this._format) ? this._format : this.columnFormat;
    }
    set format(value) {
        this._format = value;
    }
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    /**
     * The current filter operator for the associated column field.
     * @readonly
     * @type {string}
     */
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : this.operator;
    }
    get columnFormat() {
        return this.column && !isNullOrEmptyString(this.column.format) ?
            extractFormat(this.column.format) : "n2";
    }
    _format;
    subscription;
    constructor(filterService, ctx) {
        super(filterService);
        this.ctx = ctx;
        this.defaultOperators = numericOperators(this.ctx.localization);
    }
    ngOnInit() {
        this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    localizationChange() {
        this.defaultOperators = numericOperators(this.ctx.localization);
        if (this.operatorList.length) {
            this.operators = toJSON(this.operatorList.toArray());
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NumericFilterComponent, deps: [{ token: FilterService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: NumericFilterComponent, inputs: { column: "column", operator: "operator", step: "step", min: "min", max: "max", spinners: "spinners", decimals: "decimals", format: "format" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NumericFilterComponent, decorators: [{
            type: Directive,
            args: [{}]
        }], ctorParameters: function () { return [{ type: FilterService }, { type: ContextService }]; }, propDecorators: { column: [{
                type: Input
            }], operator: [{
                type: Input
            }], step: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], spinners: [{
                type: Input
            }], decimals: [{
                type: Input
            }], format: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class NumericFilterMenuInputComponent {
    ctx;
    operators = [];
    column;
    filter;
    operator;
    currentFilter;
    filterService;
    filterDelay;
    isFirstDropDown;
    menuTabbingService;
    /**
     * Specifies the value which is used to increment or decrement the component value.
     * @type {numeric}
     */
    step = 1;
    /**
     * Specifies the smallest value that is valid.
     * @type {number}
     */
    min;
    /**
     * Specifies the greatest value that is valid.
     * @type {number}
     */
    max;
    /**
     * Specifies whether the **Up** and **Down** spin buttons will be rendered.
     * @type {boolean}
     */
    spinners = true;
    /**
     * Specifies the number precision tat is applied to the component value when it is focused.
     * If the user enters a number with a greater precision than is currently configured, the component value is rounded.
     *
     * @type {number}
     */
    decimals;
    /**
     * Specifies the number format that is used when the component is not focused.
     * By default, the `column.format` value is used (if set).
     */
    format;
    /**
     * The placeholder text for the filter input.
     * @type {string}
     */
    placeholder;
    constructor(ctx) {
        this.ctx = ctx;
    }
    messageFor(key) {
        return this.ctx.localization.get(key);
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NumericFilterMenuInputComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: NumericFilterMenuInputComponent, isStandalone: true, selector: "kendo-grid-numeric-filter-menu-input", inputs: { operators: "operators", column: "column", filter: "filter", operator: "operator", currentFilter: "currentFilter", filterService: "filterService", filterDelay: "filterDelay", isFirstDropDown: "isFirstDropDown", menuTabbingService: "menuTabbingService", step: "step", min: "min", max: "max", spinners: "spinners", decimals: "decimals", format: "format", placeholder: "placeholder" }, ngImport: i0, template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService"
        >
            <kendo-numerictextbox
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [autoCorrect]="true"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [step]="step"
                [placeholder]="placeholder"
            >
                <kendo-numerictextbox-messages
                    [increment]="messageFor('filterNumericIncrement')"
                    [decrement]="messageFor('filterNumericDecrement')"
                >
                </kendo-numerictextbox-messages>
            </kendo-numerictextbox>
        </kendo-grid-filter-menu-input-wrapper>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterMenuInputWrapperComponent, selector: "kendo-grid-filter-menu-input-wrapper", inputs: ["filterService", "isFirstDropDown", "menuTabbingService", "currentFilter"] }, { kind: "component", type: NumericTextBoxComponent, selector: "kendo-numerictextbox", inputs: ["focusableId", "disabled", "readonly", "title", "autoCorrect", "format", "max", "min", "decimals", "placeholder", "step", "spinners", "rangeValidation", "tabindex", "tabIndex", "changeValueOnScroll", "selectOnFocus", "value", "maxlength", "size", "rounded", "fillMode", "inputAttributes"], outputs: ["valueChange", "focus", "blur", "inputFocus", "inputBlur"], exportAs: ["kendoNumericTextBox"] }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }, { kind: "component", type: NumericTextBoxCustomMessagesComponent, selector: "kendo-numerictextbox-messages" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NumericFilterMenuInputComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-numeric-filter-menu-input',
                    template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService"
        >
            <kendo-numerictextbox
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [autoCorrect]="true"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [step]="step"
                [placeholder]="placeholder"
            >
                <kendo-numerictextbox-messages
                    [increment]="messageFor('filterNumericIncrement')"
                    [decrement]="messageFor('filterNumericDecrement')"
                >
                </kendo-numerictextbox-messages>
            </kendo-numerictextbox>
        </kendo-grid-filter-menu-input-wrapper>
    `,
                    standalone: true,
                    imports: [FilterMenuInputWrapperComponent, NumericTextBoxComponent, FilterInputDirective, NumericTextBoxCustomMessagesComponent]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; }, propDecorators: { operators: [{
                type: Input
            }], column: [{
                type: Input
            }], filter: [{
                type: Input
            }], operator: [{
                type: Input
            }], currentFilter: [{
                type: Input
            }], filterService: [{
                type: Input
            }], filterDelay: [{
                type: Input
            }], isFirstDropDown: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }], step: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], spinners: [{
                type: Input
            }], decimals: [{
                type: Input
            }], format: [{
                type: Input
            }], placeholder: [{
                type: Input
            }] } });

/**
 * Represents a numeric filter-menu component.
 *
 * @example
 * ```html
 * <kendo-grid-column field="UnitPrice">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-numeric-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *     </kendo-grid-numeric-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class NumericFilterMenuComponent extends NumericFilterComponent {
    logicOperators = logicOperators(this.ctx.localization);
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    /**
     * The current menu filter.
     * @type {CompositeFilterDescriptor}
     */
    filter = { filters: [], logic: "and" };
    /**
     * Determines if the inputs of second criteria will displayed.
     * @default true
     */
    extra = true;
    /**
     * The `FilterService` instance which is responsible for handling the changes in the filter descriptor.
     */
    filterService;
    /**
     * Determines the delay (in milliseconds) before creating a filter descriptor based on the value. A value of 0 indicates no delay. The default value is 500.
     *
     * @default 500
     */
    filterDelay = 500;
    /**
     * The placeholder text for the filter input.
     * @type {string}
     */
    placeholder = '';
    /**
     * The placeholder text for the extra filter input. Applies when `extra` is set to `true`.
     * @type {string}
     */
    extraPlaceholder = '';
    /**
     * @hidden
     */
    menuTabbingService;
    constructor(ctx) {
        super(null, ctx);
    }
    get firstFilter() {
        return setFilter(0, this.filter, (this.column || {}).field, this.operator);
    }
    get secondFilter() {
        return setFilter(1, this.filter, (this.column || {}).field, this.operator);
    }
    logicChange(value) {
        this.filter.logic = value;
    }
    get filterMenuDropDownLabel() {
        const localizationMsg = this.ctx.localization.get('filterMenuLogicDropDownLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    localizationChange() {
        this.logicOperators = logicOperators(this.ctx.localization);
        super.localizationChange();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NumericFilterMenuComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: NumericFilterMenuComponent, isStandalone: true, selector: "kendo-grid-numeric-filter-menu", inputs: { filter: "filter", extra: "extra", filterService: "filterService", filterDelay: "filterDelay", placeholder: "placeholder", extraPlaceholder: "extraPlaceholder", menuTabbingService: "menuTabbingService" }, host: { properties: { "class.k-filtercell": "this.hostClasses" } }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-numeric-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [filterDelay]="filterDelay"
            [format]="format"
            [decimals]="decimals"
            [spinners]="spinners"
            [min]="min"
            [max]="max"
            [step]="step"
            [menuTabbingService]="menuTabbingService"
            [isFirstDropDown]="true"
            [placeholder]="placeholder"
            >
        </kendo-grid-numeric-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            kendoFilterMenuDropDown
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-grid-numeric-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [format]="format"
            [decimals]="decimals"
            [spinners]="spinners"
            [min]="min"
            [max]="max"
            [step]="step"
            [menuTabbingService]="menuTabbingService"
            [placeholder]="extraPlaceholder"
            >
        </kendo-grid-numeric-filter-menu-input>
    `, isInline: true, dependencies: [{ kind: "component", type: NumericFilterMenuInputComponent, selector: "kendo-grid-numeric-filter-menu-input", inputs: ["operators", "column", "filter", "operator", "currentFilter", "filterService", "filterDelay", "isFirstDropDown", "menuTabbingService", "step", "min", "max", "spinners", "decimals", "format", "placeholder"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: DropDownListComponent, selector: "kendo-dropdownlist", inputs: ["customIconClass", "showStickyHeader", "icon", "svgIcon", "loading", "data", "value", "textField", "valueField", "adaptiveMode", "title", "subtitle", "popupSettings", "listHeight", "defaultItem", "disabled", "itemDisabled", "readonly", "filterable", "virtual", "ignoreCase", "delay", "valuePrimitive", "tabindex", "tabIndex", "size", "rounded", "fillMode", "leftRightArrowsNavigation", "id"], outputs: ["valueChange", "filterChange", "selectionChange", "open", "opened", "close", "closed", "focus", "blur"], exportAs: ["kendoDropDownList"] }, { kind: "directive", type: FilterMenuDropDownListDirective, selector: "[kendoFilterMenuDropDown]", inputs: ["filterMenuDropDownLabel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NumericFilterMenuComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-numeric-filter-menu',
                    template: `
        <kendo-grid-numeric-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [filterDelay]="filterDelay"
            [format]="format"
            [decimals]="decimals"
            [spinners]="spinners"
            [min]="min"
            [max]="max"
            [step]="step"
            [menuTabbingService]="menuTabbingService"
            [isFirstDropDown]="true"
            [placeholder]="placeholder"
            >
        </kendo-grid-numeric-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            kendoFilterMenuDropDown
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-grid-numeric-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [format]="format"
            [decimals]="decimals"
            [spinners]="spinners"
            [min]="min"
            [max]="max"
            [step]="step"
            [menuTabbingService]="menuTabbingService"
            [placeholder]="extraPlaceholder"
            >
        </kendo-grid-numeric-filter-menu-input>
    `,
                    standalone: true,
                    imports: [NumericFilterMenuInputComponent, NgIf, DropDownListComponent, FilterMenuDropDownListDirective]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; }, propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-filtercell']
            }], filter: [{
                type: Input
            }], extra: [{
                type: Input
            }], filterService: [{
                type: Input
            }], filterDelay: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], extraPlaceholder: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }] } });

// eslint-disable no-access-missing-member
const dateOperators = localizeOperators({
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    "filterAfterOrEqualOperator": "gte",
    "filterAfterOperator": "gt",
    "filterBeforeOrEqualOperator": "lte",
    "filterBeforeOperator": "lt",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull"
});
/**
 * @hidden
 */
class DateFilterComponent extends BaseFilterCellComponent {
    ctx;
    /**
     * The column with which the filter is associated.
     * @type {ColumnComponent}
     */
    column;
    /**
     * The default filter operator. Defaults to `contains`.
     * @type {string}
     * @default 'gte'
     */
    operator = "gte";
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    /**
     * Specifies the date format that is used when the component is not focused.
     * By default, the `column.format` value is used (if set).
     */
    set format(value) {
        this._format = value;
    }
    /**
     * Specifies the date format that is used when the component is not focused.
     * By default, the `column.format` value is used (if set).
     *
     * @readonly
     * @type {string}
     */
    get format() {
        return !isNullOrEmptyString(this._format) ? this._format : this.columnFormat;
    }
    /**
     * Specifies the smallest value that is valid.
     * @type {Date}
     */
    min;
    /**
     * Specifies the greatest value that is valid.
     * @type {Date}
     */
    max;
    /**
     * Defines the descriptions of the format sections in the input field.
     * [See example](slug:placeholders_datepicker#toc-format-sections-description).
     */
    formatPlaceholder;
    /**
     * Specifies the hint that the component displays when its value is `null`.
     * [See example](slug:placeholders_datepicker#toc-text-hints).
     */
    placeholder;
    /**
     * Defines the active view that the calendar initially renders.
     * By default, the active view is `month`.
     * You have to set `activeView` within the `topView`-`bottomView` range.
     * @default 'month'
     */
    activeView = "month";
    /**
     * Defines the bottommost calendar view, to which the user can navigate.
     * @default 'month'
     */
    bottomView = "month";
    /**
     * Defines the topmost calendar view, to which the user can navigate.
     * @default 'century'
     */
    topView = "century";
    /**
     * Determines whether to display a week number column in the `month` view of the Calendar.
     * @default false
     */
    weekNumber = false;
    /**
     * The current filter operator for the associated column field.
     * @readonly
     * @type {string}
     */
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : this.operator;
    }
    get columnFormat() {
        return this.column && !isNullOrEmptyString(this.column.format) ?
            extractFormat(this.column.format) : "d";
    }
    _format;
    subscription;
    constructor(filterService, ctx) {
        super(filterService);
        this.ctx = ctx;
        this.defaultOperators = dateOperators(this.ctx.localization);
    }
    ngOnInit() {
        this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    localizationChange() {
        this.defaultOperators = dateOperators(this.ctx.localization);
        if (this.operatorList.length) {
            this.operators = toJSON(this.operatorList.toArray());
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DateFilterComponent, deps: [{ token: FilterService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DateFilterComponent, selector: "kendo-grid-date-filter-base", inputs: { column: "column", operator: "operator", format: "format", min: "min", max: "max", formatPlaceholder: "formatPlaceholder", placeholder: "placeholder", activeView: "activeView", bottomView: "bottomView", topView: "topView", weekNumber: "weekNumber" }, usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DateFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-date-filter-base',
                    template: ``
                }]
        }], ctorParameters: function () { return [{ type: FilterService }, { type: ContextService }]; }, propDecorators: { column: [{
                type: Input
            }], operator: [{
                type: Input
            }], format: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], formatPlaceholder: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], activeView: [{
                type: Input
            }], bottomView: [{
                type: Input
            }], topView: [{
                type: Input
            }], weekNumber: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class DateFilterMenuInputComponent {
    popupService;
    ctx;
    operators = [];
    column;
    filter;
    operator;
    currentFilter;
    filterService;
    menuTabbingService;
    format;
    formatPlaceholder;
    placeholder;
    min;
    max;
    activeView;
    bottomView;
    topView;
    weekNumber;
    isFirstDropDown;
    subscription;
    constructor(popupService, ctx) {
        this.popupService = popupService;
        this.ctx = ctx;
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    open(picker) {
        this.subscription = this.popupService.onClose
            .pipe(filter(() => picker.isActive))
            .subscribe(e => e.preventDefault());
    }
    messageFor(key) {
        return this.ctx.localization.get(key);
    }
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DateFilterMenuInputComponent, deps: [{ token: SinglePopupService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DateFilterMenuInputComponent, isStandalone: true, selector: "kendo-grid-date-filter-menu-input", inputs: { operators: "operators", column: "column", filter: "filter", operator: "operator", currentFilter: "currentFilter", filterService: "filterService", menuTabbingService: "menuTabbingService", format: "format", formatPlaceholder: "formatPlaceholder", placeholder: "placeholder", min: "min", max: "max", activeView: "activeView", bottomView: "bottomView", topView: "topView", weekNumber: "weekNumber", isFirstDropDown: "isFirstDropDown" }, ngImport: i0, template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService"
        >
            <kendo-datepicker
                #picker
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="0"
                (open)="open(picker)"
                [value]="currentFilter?.value"
                [placeholder]="placeholder"
                [formatPlaceholder]="formatPlaceholder"
                [format]="format"
                [min]="min"
                [max]="max"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [weekNumber]="weekNumber"
            >
                <kendo-datepicker-messages
                    [toggle]="messageFor('filterDateToggle')"
                    [today]="messageFor('filterDateToday')"
                >
                </kendo-datepicker-messages>
            </kendo-datepicker>
        </kendo-grid-filter-menu-input-wrapper>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterMenuInputWrapperComponent, selector: "kendo-grid-filter-menu-input-wrapper", inputs: ["filterService", "isFirstDropDown", "menuTabbingService", "currentFilter"] }, { kind: "component", type: DatePickerComponent, selector: "kendo-datepicker", inputs: ["focusableId", "cellTemplate", "clearButton", "inputAttributes", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "navigationItemTemplate", "weekDaysFormat", "showOtherMonthDays", "activeView", "bottomView", "topView", "calendarType", "animateCalendarNavigation", "disabled", "readonly", "readOnlyInput", "popupSettings", "navigation", "min", "max", "incompleteDateValidation", "autoCorrectParts", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "autoFill", "focusedDate", "value", "format", "twoDigitYearMax", "formatPlaceholder", "placeholder", "tabindex", "tabIndex", "disabledDates", "title", "subtitle", "rangeValidation", "disabledDatesValidation", "weekNumber", "size", "rounded", "fillMode", "adaptiveMode"], outputs: ["valueChange", "focus", "blur", "open", "close", "escape"], exportAs: ["kendo-datepicker"] }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }, { kind: "component", type: DatePickerCustomMessagesComponent, selector: "kendo-datepicker-messages" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DateFilterMenuInputComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-date-filter-menu-input',
                    template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService"
        >
            <kendo-datepicker
                #picker
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="0"
                (open)="open(picker)"
                [value]="currentFilter?.value"
                [placeholder]="placeholder"
                [formatPlaceholder]="formatPlaceholder"
                [format]="format"
                [min]="min"
                [max]="max"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [weekNumber]="weekNumber"
            >
                <kendo-datepicker-messages
                    [toggle]="messageFor('filterDateToggle')"
                    [today]="messageFor('filterDateToday')"
                >
                </kendo-datepicker-messages>
            </kendo-datepicker>
        </kendo-grid-filter-menu-input-wrapper>
    `,
                    standalone: true,
                    imports: [FilterMenuInputWrapperComponent, DatePickerComponent, FilterInputDirective, DatePickerCustomMessagesComponent]
                }]
        }], ctorParameters: function () { return [{ type: SinglePopupService }, { type: ContextService }]; }, propDecorators: { operators: [{
                type: Input
            }], column: [{
                type: Input
            }], filter: [{
                type: Input
            }], operator: [{
                type: Input
            }], currentFilter: [{
                type: Input
            }], filterService: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }], format: [{
                type: Input
            }], formatPlaceholder: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], activeView: [{
                type: Input
            }], bottomView: [{
                type: Input
            }], topView: [{
                type: Input
            }], weekNumber: [{
                type: Input
            }], isFirstDropDown: [{
                type: Input
            }] } });

/**
 * Represents a date filter-menu component.
 *
 * @example
 * ```html
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-date-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *     </kendo-grid-date-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class DateFilterMenuComponent extends DateFilterComponent {
    logicOperators = logicOperators(this.ctx.localization);
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    /**
     * The current menu filter.
     * @type {CompositeFilterDescriptor}
     */
    filter = { filters: [], logic: "and" };
    /**
     * Determines if the inputs of second criteria will be displayed.
     * @default true
     */
    extra = true;
    /**
     * The `FilterService` instance which is responsible for handling the changes in the filter descriptor.
     */
    filterService;
    /**
     * @hidden
     */
    menuTabbingService;
    constructor(ctx) {
        super(null, ctx);
    }
    get firstFilter() {
        return setFilter(0, this.filter, (this.column || {}).field, this.operator);
    }
    get secondFilter() {
        return setFilter(1, this.filter, (this.column || {}).field, this.operator);
    }
    logicChange(value) {
        this.filter.logic = value;
    }
    get filterMenuDropDownLabel() {
        const localizationMsg = this.ctx.localization.get('filterMenuLogicDropDownLabel') || '';
        const columnName = this.column ? this.column.title || this.column.field : '';
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    localizationChange() {
        this.logicOperators = logicOperators(this.ctx.localization);
        super.localizationChange();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DateFilterMenuComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DateFilterMenuComponent, isStandalone: true, selector: "kendo-grid-date-filter-menu", inputs: { filter: "filter", extra: "extra", filterService: "filterService", menuTabbingService: "menuTabbingService" }, host: { properties: { "class.k-filtercell": "this.hostClasses" } }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-date-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [weekNumber]="weekNumber"
            [isFirstDropDown]="true"
            [menuTabbingService]="menuTabbingService"
            >
        </kendo-grid-date-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            kendoFilterMenuDropDown
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-grid-date-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [weekNumber]="weekNumber"
            [menuTabbingService]="menuTabbingService"
            >
        </kendo-grid-date-filter-menu-input>
    `, isInline: true, dependencies: [{ kind: "component", type: DateFilterMenuInputComponent, selector: "kendo-grid-date-filter-menu-input", inputs: ["operators", "column", "filter", "operator", "currentFilter", "filterService", "menuTabbingService", "format", "formatPlaceholder", "placeholder", "min", "max", "activeView", "bottomView", "topView", "weekNumber", "isFirstDropDown"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: DropDownListComponent, selector: "kendo-dropdownlist", inputs: ["customIconClass", "showStickyHeader", "icon", "svgIcon", "loading", "data", "value", "textField", "valueField", "adaptiveMode", "title", "subtitle", "popupSettings", "listHeight", "defaultItem", "disabled", "itemDisabled", "readonly", "filterable", "virtual", "ignoreCase", "delay", "valuePrimitive", "tabindex", "tabIndex", "size", "rounded", "fillMode", "leftRightArrowsNavigation", "id"], outputs: ["valueChange", "filterChange", "selectionChange", "open", "opened", "close", "closed", "focus", "blur"], exportAs: ["kendoDropDownList"] }, { kind: "directive", type: FilterMenuDropDownListDirective, selector: "[kendoFilterMenuDropDown]", inputs: ["filterMenuDropDownLabel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DateFilterMenuComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-date-filter-menu',
                    template: `
        <kendo-grid-date-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [weekNumber]="weekNumber"
            [isFirstDropDown]="true"
            [menuTabbingService]="menuTabbingService"
            >
        </kendo-grid-date-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            kendoFilterMenuDropDown
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-grid-date-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [weekNumber]="weekNumber"
            [menuTabbingService]="menuTabbingService"
            >
        </kendo-grid-date-filter-menu-input>
    `,
                    standalone: true,
                    imports: [DateFilterMenuInputComponent, NgIf, DropDownListComponent, FilterMenuDropDownListDirective]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; }, propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-filtercell']
            }], filter: [{
                type: Input
            }], extra: [{
                type: Input
            }], filterService: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }] } });

// eslint-disable no-access-missing-member
/**
 * @hidden
 */
class BooleanFilterComponent extends BaseFilterCellComponent {
    ctx;
    /**
     * The column with which the filter is associated.
     * @type {ColumnComponent}
     */
    column;
    /**
     * @hidden
     */
    operator = "eq";
    /**
     * The current filter for the associated column field.
     * @readonly
     * @type {FilterDescriptor}
     */
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    /**
     * The current filter operator for the associated column field.
     * @readonly
     * @type {string}
     */
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : this.operator;
    }
    items;
    defaultItem;
    subscription;
    constructor(filterService, ctx) {
        super(filterService);
        this.ctx = ctx;
        this.items = [
            { text: this.ctx.localization.get("filterIsTrue"), value: true },
            { text: this.ctx.localization.get("filterIsFalse"), value: false }
        ];
        this.defaultItem = { text: this.ctx.localization.get("filterBooleanAll"), value: null };
    }
    ngOnInit() {
        this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
    localizationChange() {
        this.items = [
            { text: this.ctx.localization.get("filterIsTrue"), value: true },
            { text: this.ctx.localization.get("filterIsFalse"), value: false }
        ];
        this.defaultItem = { text: this.ctx.localization.get("filterBooleanAll"), value: null };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BooleanFilterComponent, deps: [{ token: FilterService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BooleanFilterComponent, selector: "kendo-grid-boolean-filter-base", inputs: { column: "column" }, usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BooleanFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-boolean-filter-base',
                    template: ``
                }]
        }], ctorParameters: function () { return [{ type: FilterService }, { type: ContextService }]; }, propDecorators: { column: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class BooleanFilterRadioButtonDirective {
    hostElement;
    renderer;
    columnLabel;
    radioButtonEl;
    constructor(hostElement, renderer) {
        this.hostElement = hostElement;
        this.renderer = renderer;
    }
    ngAfterViewInit() {
        this.radioButtonEl = this.hostElement.nativeElement;
        this.renderer.setAttribute(this.hostElement.nativeElement, 'aria-label', this.columnLabel);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BooleanFilterRadioButtonDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: BooleanFilterRadioButtonDirective, isStandalone: true, selector: "[kendoFilterMenuRadioButton]", inputs: { columnLabel: "columnLabel" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BooleanFilterRadioButtonDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoFilterMenuRadioButton]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { columnLabel: [{
                type: Input
            }] } });

/**
 * Represents a Boolean-filter menu component. [See example](slug:filter_menu#toc-built-in-filter-menu-components)
 *
 * @example
 *
 * ```html
 * <kendo-grid-column field="Discontinued" title="Discontinued">
 *   <ng-template kendoGridFilterMenuTemplate let-filter let-column="column" let-filterService="filterService">
 *     <kendo-grid-boolean-filter-menu
 *       [column]="column"
 *       [filter]="filter"
 *       [filterService]="filterService">
 *     </kendo-grid-boolean-filter-menu>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class BooleanFilterMenuComponent extends BooleanFilterComponent {
    /**
     * @hidden
     */
    get hostClasses() {
        return false;
    }
    /**
     * The current menu filter.
     * @type {CompositeFilterDescriptor}
     */
    filter = { filters: [], logic: "and" };
    /**
     * The `FilterService` instance which is responsible for handling the changes in the filter descriptor.
     */
    filterService;
    /**
     * @hidden
     */
    menuTabbingService;
    idPrefix = guid();
    /**
     * @hidden
     */
    radioButtons;
    constructor(ctx) {
        super(null, ctx);
    }
    ngAfterViewInit() {
        this.filterService.menuTabbingService.firstFocusable = this.radioButtons.first.radioButtonEl;
        if (!this.menuTabbingService?.isTabbedInterface) {
            this.radioButtons.first.radioButtonEl.focus();
        }
    }
    /**
     * @hidden
     */
    radioId(value) {
        return `${this.idPrefix}_${value}`;
    }
    /**
     * @hidden
     */
    onChange(value, input) {
        this.applyFilter(this.updateFilter({
            field: this.column.field,
            operator: "eq",
            value: value
        }));
        this.filterService.menuTabbingService.firstFocusable = input.hostElement.nativeElement;
    }
    /**
     * @hidden
     */
    isSelected(radioValue) {
        return this.filtersByField(this.column.field).some(({ value }) => value === radioValue);
    }
    /**
     * @hidden
     */
    onShiftTab(e) {
        if ((!this.menuTabbingService || !this.menuTabbingService.isColumnMenu) && this.filterService.menuTabbingService.lastFocusable) {
            e.preventDefault();
            this.filterService.menuTabbingService.lastFocusable.focus();
        }
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BooleanFilterMenuComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BooleanFilterMenuComponent, isStandalone: true, selector: "kendo-grid-boolean-filter-menu", inputs: { filter: "filter", filterService: "filterService", menuTabbingService: "menuTabbingService" }, host: { properties: { "class.k-filtercell": "this.hostClasses" } }, viewQueries: [{ propertyName: "radioButtons", predicate: BooleanFilterRadioButtonDirective, descendants: true }], usesInheritance: true, ngImport: i0, template: `
        <ul class="k-radio-list k-reset">
            <li *ngFor="let item of items">
                <kendo-radiobutton
                    kendoFilterMenuRadioButton
                    [columnLabel]="columnLabel"
                    #input
                    [name]="idPrefix"
                    [checked]="isSelected(item.value)"
                    [attr.id]="radioId(item.value)"
                    (change)="onChange(item.value, input)"
                    (keydown.shift.tab)="onShiftTab($event)"
                ></kendo-radiobutton>
                <label class="k-radio-label" [attr.for]="radioId(item.value)">{{item.text}}</label>
            </li>
        </ul>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: RadioButtonComponent, selector: "kendo-radiobutton", inputs: ["checked"], outputs: ["checkedChange"], exportAs: ["kendoRadioButton"] }, { kind: "directive", type: BooleanFilterRadioButtonDirective, selector: "[kendoFilterMenuRadioButton]", inputs: ["columnLabel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BooleanFilterMenuComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-boolean-filter-menu',
                    template: `
        <ul class="k-radio-list k-reset">
            <li *ngFor="let item of items">
                <kendo-radiobutton
                    kendoFilterMenuRadioButton
                    [columnLabel]="columnLabel"
                    #input
                    [name]="idPrefix"
                    [checked]="isSelected(item.value)"
                    [attr.id]="radioId(item.value)"
                    (change)="onChange(item.value, input)"
                    (keydown.shift.tab)="onShiftTab($event)"
                ></kendo-radiobutton>
                <label class="k-radio-label" [attr.for]="radioId(item.value)">{{item.text}}</label>
            </li>
        </ul>
    `,
                    standalone: true,
                    imports: [NgFor, RadioButtonComponent, BooleanFilterRadioButtonDirective]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; }, propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-filtercell']
            }], filter: [{
                type: Input
            }], filterService: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }], radioButtons: [{
                type: ViewChildren,
                args: [BooleanFilterRadioButtonDirective]
            }] } });

/**
 * @hidden
 *
 * > List the following components as `entryComponents` in the GridModule.
 */
const filterMenuComponentFactory = (type) => ({
    "boolean": BooleanFilterMenuComponent,
    "date": DateFilterMenuComponent,
    "numeric": NumericFilterMenuComponent,
    "text": StringFilterMenuComponent
}[type]);

/**
 * @hidden
 */
class FilterMenuHostDirective extends FilterHostDirective {
    filterService;
    menuTabbingService;
    constructor(host, resolver) {
        super(host, resolver);
    }
    componentType() {
        if (isPresent(this.column) && !isNullOrEmptyString(this.column.filter)) {
            return filterMenuComponentFactory(this.column.filter);
        }
        return StringFilterMenuComponent;
    }
    initComponent(ctx) {
        super.initComponent(ctx);
        this.component.instance.filterService = this.filterService;
        this.component.instance.menuTabbingService = this.menuTabbingService;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterMenuHostDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: FilterMenuHostDirective, isStandalone: true, selector: "[kendoFilterMenuHost]", inputs: { filterService: "filterService", menuTabbingService: "menuTabbingService" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterMenuHostDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoFilterMenuHost]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.ComponentFactoryResolver }]; }, propDecorators: { filterService: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }] } });

const isNoValueOperator = operator => (operator === "isnull"
    || operator === "isnotnull"
    || operator === "isempty"
    || operator === "isnotempty");
const validFilters = ({ value, operator }) => !isNullOrEmptyString(value) || isNoValueOperator(operator);
const trimFilters = filter => {
    filter.filters = filter.filters.filter(validFilters);
    return filter;
};
const findParent = (filters, field, parent) => {
    return filters.reduce((acc, filter) => {
        if (acc) {
            return acc;
        }
        if (filter.filters) {
            return findParent(filter.filters, field, filter);
        }
        else if (filter.field === field) {
            return parent;
        }
        return acc;
    }, undefined);
};
const parentLogicOfDefault = (filter, field, def = "and") => {
    const parent = findParent(((filter || {}).filters || []), field);
    return isPresent(parent) ? parent.logic : def;
};
/**
 * @hidden
 */
class FilterMenuContainerComponent {
    parentService;
    childService;
    ctx;
    cd;
    close = new EventEmitter();
    /**
     * The column with which the filter is associated.
     * @type {ColumnComponent}
     */
    column;
    /**
     * @hidden
     */
    isLast;
    /**
     * @hidden
     */
    isExpanded;
    /**
     * @hidden
     */
    menuTabbingService;
    /**
     * The current root filter.
     * @type {CompositeFilterDescriptor}
     */
    set filter(value) {
        this._filter = cloneFilters(value);
    }
    get filter() {
        return this._filter;
    }
    /**
     * @hidden
     */
    actionsClass = 'k-actions k-actions-stretched k-actions-horizontal';
    get childFilter() {
        if (!isPresent(this._childFilter)) {
            this._childFilter = {
                filters: filtersByField(this.filter, (this.column || {}).field),
                logic: parentLogicOfDefault(this.filter, (this.column || {}).field)
            };
        }
        return this._childFilter;
    }
    resetButton;
    filterButton;
    _childFilter;
    subscription;
    _templateContext = {};
    _filter;
    constructor(parentService, childService, ctx, cd, menuTabbingService) {
        this.parentService = parentService;
        this.childService = childService;
        this.ctx = ctx;
        this.cd = cd;
        this.menuTabbingService = menuTabbingService;
    }
    ngOnInit() {
        this.subscription = this.childService.changes.subscribe(filter => this._childFilter = filter);
        this.subscription.add(this.ctx.localization.changes.subscribe(() => this.cd.markForCheck()));
    }
    ngAfterViewChecked() {
        if (!this.menuTabbingService.isColumnMenu || (this.isLast && this.isExpanded)) {
            this.menuTabbingService.lastFocusable = this.disabled ?
                this.resetButton.nativeElement : this.filterButton.nativeElement;
        }
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        this.menuTabbingService.lastFocusable = undefined;
    }
    get disabled() {
        return !this.childFilter.filters.some(validFilters);
    }
    get templateContext() {
        this._templateContext.column = this.column;
        this._templateContext.filter = this.childFilter;
        this._templateContext.filterService = this.childService;
        this._templateContext["$implicit"] = this.childFilter;
        return this._templateContext;
    }
    get hasTemplate() {
        return isPresent(this.column) && isPresent(this.column.filterMenuTemplateRef);
    }
    submit() {
        const filter = trimFilters(this.childFilter);
        if (filter.filters.length) {
            const root = this.filter || {
                filters: [],
                logic: "and"
            };
            removeFilter(root, this.column.field);
            root.filters.push(filter);
            this.parentService.filter(root);
        }
        this.close.emit();
        return false;
    }
    reset() {
        const root = this.filter || {
            filters: [],
            logic: "and"
        };
        removeFilter(root, this.column.field);
        this.parentService.filter(root);
        this.close.emit();
    }
    onTab(e, buttonType) {
        if (this.menuTabbingService.firstFocusable && (!this.menuTabbingService.isColumnMenu || this.isLast)) {
            e.preventDefault();
            if (buttonType === 'reset') {
                // eslint-disable-next-line no-unused-expressions
                this.menuTabbingService.firstFocusable.focus();
            }
            else {
                this.disabled ? this.menuTabbingService.firstFocusable.focus() : this.resetButton.nativeElement.focus();
            }
        }
    }
    get clearText() {
        return this.ctx.localization.get("filterClearButton");
    }
    get filterText() {
        return this.ctx.localization.get("filterFilterButton");
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterMenuContainerComponent, deps: [{ token: FilterService, skipSelf: true }, { token: FilterService }, { token: ContextService }, { token: i0.ChangeDetectorRef }, { token: MenuTabbingService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: FilterMenuContainerComponent, isStandalone: true, selector: "kendo-grid-filter-menu-container", inputs: { column: "column", isLast: "isLast", isExpanded: "isExpanded", menuTabbingService: "menuTabbingService", filter: "filter", actionsClass: "actionsClass" }, outputs: { close: "close" }, providers: [
            FilterService,
            MenuTabbingService
        ], viewQueries: [{ propertyName: "resetButton", first: true, predicate: ["resetButton"], descendants: true }, { propertyName: "filterButton", first: true, predicate: ["filterButton"], descendants: true }], ngImport: i0, template: `
        <form (submit)="submit()" (reset)="reset()"
            class="k-filter-menu">
            <div class="k-filter-menu-container">
                <ng-container [ngSwitch]="hasTemplate">
                    <ng-container *ngSwitchCase="false">
                        <ng-container
                            kendoFilterMenuHost
                            [filterService]="childService"
                            [column]="column"
                            [filter]="childFilter"
                            [menuTabbingService]="menuTabbingService">
                        </ng-container>
                    </ng-container>
                    <ng-container *ngSwitchCase="true">
                        <ng-template
                            *ngIf="column.filterMenuTemplateRef"
                            [ngTemplateOutlet]="column.filterMenuTemplateRef"
                            [ngTemplateOutletContext]="templateContext"
                            >
                        </ng-template>
                    </ng-container>
                </ng-container>
                <div [ngClass]="actionsClass">
                    <button #filterButton
                        type="submit"
                        class="k-button k-button-solid-primary k-button-solid k-button-md k-rounded-md k-button-rectangle"
                        [disabled]="disabled"
                        (keydown.tab)="onTab($event, 'filter')">{{filterText}}</button>
                    <button
                        #resetButton
                        type="reset"
                        class="k-button k-button-solid-base k-button-solid k-button-md k-rounded-md k-button-rectangle"
                        (keydown.tab)="onTab($event, 'reset')">{{clearText}}</button>
                </div>
            </div>
        </form>
    `, isInline: true, dependencies: [{ kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i4.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i4.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i4.NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: ["ngFormOptions"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: FilterMenuHostDirective, selector: "[kendoFilterMenuHost]", inputs: ["filterService", "menuTabbingService"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterMenuContainerComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        FilterService,
                        MenuTabbingService
                    ],
                    selector: 'kendo-grid-filter-menu-container',
                    template: `
        <form (submit)="submit()" (reset)="reset()"
            class="k-filter-menu">
            <div class="k-filter-menu-container">
                <ng-container [ngSwitch]="hasTemplate">
                    <ng-container *ngSwitchCase="false">
                        <ng-container
                            kendoFilterMenuHost
                            [filterService]="childService"
                            [column]="column"
                            [filter]="childFilter"
                            [menuTabbingService]="menuTabbingService">
                        </ng-container>
                    </ng-container>
                    <ng-container *ngSwitchCase="true">
                        <ng-template
                            *ngIf="column.filterMenuTemplateRef"
                            [ngTemplateOutlet]="column.filterMenuTemplateRef"
                            [ngTemplateOutletContext]="templateContext"
                            >
                        </ng-template>
                    </ng-container>
                </ng-container>
                <div [ngClass]="actionsClass">
                    <button #filterButton
                        type="submit"
                        class="k-button k-button-solid-primary k-button-solid k-button-md k-rounded-md k-button-rectangle"
                        [disabled]="disabled"
                        (keydown.tab)="onTab($event, 'filter')">{{filterText}}</button>
                    <button
                        #resetButton
                        type="reset"
                        class="k-button k-button-solid-base k-button-solid k-button-md k-rounded-md k-button-rectangle"
                        (keydown.tab)="onTab($event, 'reset')">{{clearText}}</button>
                </div>
            </div>
        </form>
    `,
                    standalone: true,
                    imports: [FormsModule, NgSwitch, NgSwitchCase, FilterMenuHostDirective, NgIf, NgTemplateOutlet, NgClass]
                }]
        }], ctorParameters: function () { return [{ type: FilterService, decorators: [{
                    type: SkipSelf
                }] }, { type: FilterService }, { type: ContextService }, { type: i0.ChangeDetectorRef }, { type: MenuTabbingService }]; }, propDecorators: { close: [{
                type: Output
            }], column: [{
                type: Input
            }], isLast: [{
                type: Input
            }], isExpanded: [{
                type: Input
            }], menuTabbingService: [{
                type: Input
            }], filter: [{
                type: Input
            }], actionsClass: [{
                type: Input
            }], resetButton: [{
                type: ViewChild,
                args: ['resetButton', { static: false }]
            }], filterButton: [{
                type: ViewChild,
                args: ['filterButton', { static: false }]
            }] } });

let id$1 = 0;
const getId$1 = (gridId) => `${gridId}-filter-menu-${id$1++}`;
/**
 * @hidden
 */
class FilterMenuComponent {
    filterService;
    popupService;
    ctx;
    navigationService;
    renderer;
    cdr;
    idService;
    filterIcon = filterIcon;
    /**
     * The column with which the filter is associated.
     * @type {ColumnComponent}
     */
    column;
    /**
     * The current root filter.
     * @type {CompositeFilterDescriptor}
     */
    filter;
    anchor;
    template;
    tabIndex = '-1';
    popupRef;
    popupSubs;
    constructor(filterService, popupService, ctx, navigationService, renderer, cdr, idService) {
        this.filterService = filterService;
        this.popupService = popupService;
        this.ctx = ctx;
        this.navigationService = navigationService;
        this.renderer = renderer;
        this.cdr = cdr;
        this.idService = idService;
    }
    ngOnDestroy() {
        this.cleanUp();
    }
    get hasFilters() {
        return filtersByField(this.filter, (this.column || {}).field).length > 0;
    }
    /**
     * @hidden
     */
    get filterLabel() {
        const localizationMsg = this.ctx.localization.get('filterMenuTitle') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    /**
     * @hidden
     */
    get isNavigable() {
        return this.navigationService.tableEnabled;
    }
    toggle(anchor, template) {
        this.popupRef = this.popupService.open(anchor, template, this.popupRef);
        // Needed as changes to 'popupRef' are not reflected
        // automatically when the Popup is closed by clicking outside the anchor
        const ariaRoot = this.isNavigable ? anchor.closest('.k-table-th') : anchor;
        if (this.popupRef) {
            this.popupSubs?.unsubscribe();
            this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
                this.close();
                this.updateAria(ariaRoot);
            });
            this.popupSubs.add(this.popupRef.popup.instance.close.subscribe(() => {
                this.popupRef = null;
                this.updateAria(ariaRoot);
            }));
            const popupAriaElement = this.popupRef.popupElement.querySelector('.k-grid-filter-popup');
            if (popupAriaElement) {
                const popupId = getId$1(this.idService?.gridId());
                this.renderer.setAttribute(popupAriaElement, 'id', popupId);
                this.renderer.setAttribute(popupAriaElement, 'role', 'dialog');
                this.renderer.setAttribute(popupAriaElement, 'aria-label', this.filterLabel);
                ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-controls', popupId);
                ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-expanded', 'true');
            }
        }
        else {
            if (this.navigationService.tableEnabled) {
                this.navigationService.focusCell(0, this.column.leafIndex);
            }
            else {
                this.anchor.nativeElement.focus();
            }
        }
        return false;
    }
    close() {
        this.cleanUp();
        if (this.navigationService.tableEnabled) {
            this.navigationService.focusCell(0, this.column.leafIndex);
        }
        else {
            this.anchor.nativeElement.focus();
        }
    }
    updateAria(ariaRoot) {
        ariaRoot && this.renderer.removeAttribute(ariaRoot, 'aria-controls');
        ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-expanded', 'false');
    }
    cleanUp() {
        this.popupService.destroy();
        this.popupRef = null;
        this.popupSubs?.unsubscribe();
        this.popupSubs = null;
        this.cdr.markForCheck();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterMenuComponent, deps: [{ token: FilterService }, { token: SinglePopupService }, { token: ContextService }, { token: NavigationService }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: IdService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: FilterMenuComponent, isStandalone: true, selector: "kendo-grid-filter-menu", inputs: { column: "column", filter: "filter", tabIndex: "tabIndex" }, viewQueries: [{ propertyName: "anchor", first: true, predicate: ["anchor"], descendants: true, static: true }, { propertyName: "template", first: true, predicate: ["template"], descendants: true, read: TemplateRef, static: true }], ngImport: i0, template: `
        <a #anchor
            class="k-grid-filter-menu k-grid-header-menu"
            [class.k-active]="hasFilters"
            [tabindex]="tabIndex"
            (click)="toggle(anchor, template)"
            (keydown.enter)="$event.stopImmediatePropagation()"
            href="#"
            [attr.title]="filterLabel"
            [attr.aria-haspopup]="isNavigable ? undefined : 'dialog'"
            [attr.aria-expanded]="isNavigable ? undefined : false">
            <kendo-icon-wrapper
                name="filter"
                [svgIcon]="filterIcon"></kendo-icon-wrapper>
        </a>
        <ng-template #template>
            <kendo-grid-filter-menu-container
                [column]="column"
                [filter]="filter"
                (close)="close()"
                (keydown.escape)="close()"
                (keydown.enter)="$event.stopImmediatePropagation()"
                >
            </kendo-grid-filter-menu-container>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "component", type: FilterMenuContainerComponent, selector: "kendo-grid-filter-menu-container", inputs: ["column", "isLast", "isExpanded", "menuTabbingService", "filter", "actionsClass"], outputs: ["close"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterMenuComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-filter-menu',
                    template: `
        <a #anchor
            class="k-grid-filter-menu k-grid-header-menu"
            [class.k-active]="hasFilters"
            [tabindex]="tabIndex"
            (click)="toggle(anchor, template)"
            (keydown.enter)="$event.stopImmediatePropagation()"
            href="#"
            [attr.title]="filterLabel"
            [attr.aria-haspopup]="isNavigable ? undefined : 'dialog'"
            [attr.aria-expanded]="isNavigable ? undefined : false">
            <kendo-icon-wrapper
                name="filter"
                [svgIcon]="filterIcon"></kendo-icon-wrapper>
        </a>
        <ng-template #template>
            <kendo-grid-filter-menu-container
                [column]="column"
                [filter]="filter"
                (close)="close()"
                (keydown.escape)="close()"
                (keydown.enter)="$event.stopImmediatePropagation()"
                >
            </kendo-grid-filter-menu-container>
        </ng-template>
    `,
                    standalone: true,
                    imports: [IconWrapperComponent, FilterMenuContainerComponent]
                }]
        }], ctorParameters: function () { return [{ type: FilterService }, { type: SinglePopupService }, { type: ContextService }, { type: NavigationService }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: IdService, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { column: [{
                type: Input
            }], filter: [{
                type: Input
            }], anchor: [{
                type: ViewChild,
                args: ['anchor', { static: true }]
            }], template: [{
                type: ViewChild,
                args: ['template', { static: true, read: TemplateRef }]
            }], tabIndex: [{
                type: Input
            }] } });

const EMPTY_FILTER_OPERATORS = ['isnull', 'isnotnull', 'isempty', 'isnotempty'];
/**
 * @hidden
 */
class FilterCellWrapperComponent extends FilterInputWrapperComponent {
    get hostClasses() {
        return true;
    }
    get overrideBaseClasses() {
        return false;
    }
    showOperators = true;
    get showButton() {
        const filter = this.currentFilter;
        return isPresent(filter) && (!isNullOrEmptyString(filter.value) ||
            EMPTY_FILTER_OPERATORS.indexOf(String(filter.operator)) >= 0);
    }
    constructor(filterService) {
        super(filterService);
    }
    filterChange(filter) {
        this.applyFilter(filter);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterCellWrapperComponent, deps: [{ token: FilterService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: FilterCellWrapperComponent, isStandalone: true, selector: "kendo-grid-filter-wrapper-cell", inputs: { showOperators: "showOperators" }, host: { properties: { "class.k-filtercell-wrapper": "this.hostClasses", "class.k-filtercell": "this.overrideBaseClasses" } }, usesInheritance: true, ngImport: i0, template: `
        <ng-content></ng-content>
        <kendo-grid-filter-cell-operators
            [showOperators]="showOperators"
            [column]="column"
            [operators]="operators"
            (clear)="onClear()"
            [showButton]="showButton"
            [(value)]="currentOperator">
        </kendo-grid-filter-cell-operators>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterCellOperatorsComponent, selector: "kendo-grid-filter-cell-operators", inputs: ["operators", "showButton", "showOperators", "value", "column"], outputs: ["valueChange", "clear"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterCellWrapperComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-filter-wrapper-cell',
                    template: `
        <ng-content></ng-content>
        <kendo-grid-filter-cell-operators
            [showOperators]="showOperators"
            [column]="column"
            [operators]="operators"
            (clear)="onClear()"
            [showButton]="showButton"
            [(value)]="currentOperator">
        </kendo-grid-filter-cell-operators>
    `,
                    standalone: true,
                    imports: [FilterCellOperatorsComponent]
                }]
        }], ctorParameters: function () { return [{ type: FilterService }]; }, propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-filtercell-wrapper']
            }], overrideBaseClasses: [{
                type: HostBinding,
                args: ['class.k-filtercell']
            }], showOperators: [{
                type: Input
            }] } });

// eslint-disable no-access-missing-member
const stringOperators = localizeOperators({
    "filterContainsOperator": "contains",
    "filterNotContainsOperator": "doesnotcontain",
    "filterEqOperator": "eq",
    "filterNotEqOperator": "neq",
    "filterStartsWithOperator": "startswith",
    "filterEndsWithOperator": "endswith",
    "filterIsNullOperator": "isnull",
    "filterIsNotNullOperator": "isnotnull",
    "filterIsEmptyOperator": "isempty",
    "filterIsNotEmptyOperator": "isnotempty"
});
/**
 * @hidden
 */
class AutoCompleteFilterCellComponent extends BaseFilterCellComponent {
    ctx;
    showOperators = true;
    column;
    data;
    set valueField(value) {
        this._valueField = value;
    }
    get valueField() {
        return this._valueField ? this._valueField : this.column.field;
    }
    get currentFilter() {
        return this.filterByField(this.column.field);
    }
    get currentOperator() {
        return this.currentFilter ? this.currentFilter.operator : "contains";
    }
    size = 'medium';
    _valueField;
    subs;
    constructor(filterService, column, ctx, sizingOptionsService) {
        super(filterService);
        this.ctx = ctx;
        this.defaultOperators = stringOperators(this.ctx.localization);
        this.column = column;
        this.subs = sizingOptionsService.changes.subscribe(size => this.size = size);
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AutoCompleteFilterCellComponent, deps: [{ token: FilterService }, { token: ColumnComponent }, { token: ContextService }, { token: SizingOptionsService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: AutoCompleteFilterCellComponent, isStandalone: true, selector: "kendo-grid-autocomplete-filter-cell", inputs: { showOperators: "showOperators", column: "column", data: "data", valueField: "valueField" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [showOperators]="showOperators">
            <kendo-autocomplete
                kendoFilterInput
                [data]="data"
                [size]="size"
                [valueField]="valueField"
                [value]="currentFilter?.value">
            </kendo-autocomplete>
        </kendo-grid-filter-wrapper-cell>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterCellWrapperComponent, selector: "kendo-grid-filter-wrapper-cell", inputs: ["showOperators"] }, { kind: "component", type: AutoCompleteComponent, selector: "kendo-autocomplete", inputs: ["highlightFirst", "showStickyHeader", "focusableId", "data", "value", "valueField", "placeholder", "adaptiveMode", "title", "subtitle", "popupSettings", "listHeight", "loading", "clearButton", "suggest", "disabled", "itemDisabled", "readonly", "tabindex", "tabIndex", "filterable", "virtual", "size", "rounded", "fillMode", "inputAttributes"], outputs: ["valueChange", "filterChange", "open", "opened", "close", "closed", "focus", "blur", "inputFocus", "inputBlur"], exportAs: ["kendoAutoComplete"] }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AutoCompleteFilterCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-autocomplete-filter-cell',
                    template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [showOperators]="showOperators">
            <kendo-autocomplete
                kendoFilterInput
                [data]="data"
                [size]="size"
                [valueField]="valueField"
                [value]="currentFilter?.value">
            </kendo-autocomplete>
        </kendo-grid-filter-wrapper-cell>
    `,
                    standalone: true,
                    imports: [FilterCellWrapperComponent, AutoCompleteComponent, FilterInputDirective]
                }]
        }], ctorParameters: function () { return [{ type: FilterService }, { type: ColumnComponent }, { type: ContextService }, { type: SizingOptionsService }]; }, propDecorators: { showOperators: [{
                type: Input
            }], column: [{
                type: Input
            }], data: [{
                type: Input
            }], valueField: [{
                type: Input
            }] } });

/**
 * Represents a Boolean filter-cell component.
 * See the article about the [built-in filter components](slug:filter_row#toc-built-in-filter-row-components).
 *
 * @example
 *
 * ```html
 * <kendo-grid-column field="Discontinued">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-boolean-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *     </kendo-grid-boolean-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class BooleanFilterCellComponent extends BooleanFilterComponent {
    cd;
    /**
     * @hidden
     */
    size = 'medium';
    subs;
    constructor(filterService, ctx, cd, sizingService) {
        super(filterService, ctx);
        this.cd = cd;
        this.subs = sizingService.changes.subscribe((size) => this.size = size);
    }
    ngOnDestroy() {
        this.subs && this.subs.unsubscribe();
    }
    localizationChange() {
        super.localizationChange();
        this.cd.markForCheck();
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('booleanFilterCellLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BooleanFilterCellComponent, deps: [{ token: FilterService }, { token: ContextService }, { token: i0.ChangeDetectorRef }, { token: SizingOptionsService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BooleanFilterCellComponent, isStandalone: true, selector: "kendo-grid-boolean-filter-cell", usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [showOperators]="false"
            [defaultOperator]="operator">
            <kendo-dropdownlist
                kendoFilterInput
                kendoGridFocusable
                [size]="size"
                [columnLabel]="columnLabel"
                [defaultItem]="defaultItem"
                [data]="items"
                textField="text"
                valueField="value"
                [popupSettings]="{ width: 'auto' }"
                [valuePrimitive]="true"
                [value]="currentFilter?.value">
            </kendo-dropdownlist>
        </kendo-grid-filter-wrapper-cell>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterCellWrapperComponent, selector: "kendo-grid-filter-wrapper-cell", inputs: ["showOperators"] }, { kind: "component", type: DropDownListComponent, selector: "kendo-dropdownlist", inputs: ["customIconClass", "showStickyHeader", "icon", "svgIcon", "loading", "data", "value", "textField", "valueField", "adaptiveMode", "title", "subtitle", "popupSettings", "listHeight", "defaultItem", "disabled", "itemDisabled", "readonly", "filterable", "virtual", "ignoreCase", "delay", "valuePrimitive", "tabindex", "tabIndex", "size", "rounded", "fillMode", "leftRightArrowsNavigation", "id"], outputs: ["valueChange", "filterChange", "selectionChange", "open", "opened", "close", "closed", "focus", "blur"], exportAs: ["kendoDropDownList"] }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: ["kendoGridFocusable"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BooleanFilterCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-boolean-filter-cell',
                    template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [showOperators]="false"
            [defaultOperator]="operator">
            <kendo-dropdownlist
                kendoFilterInput
                kendoGridFocusable
                [size]="size"
                [columnLabel]="columnLabel"
                [defaultItem]="defaultItem"
                [data]="items"
                textField="text"
                valueField="value"
                [popupSettings]="{ width: 'auto' }"
                [valuePrimitive]="true"
                [value]="currentFilter?.value">
            </kendo-dropdownlist>
        </kendo-grid-filter-wrapper-cell>
    `,
                    standalone: true,
                    imports: [FilterCellWrapperComponent, DropDownListComponent, FilterInputDirective, FocusableDirective]
                }]
        }], ctorParameters: function () { return [{ type: FilterService }, { type: ContextService }, { type: i0.ChangeDetectorRef }, { type: SizingOptionsService }]; } });

/**
 * Represents a [DatePicker](slug:overview_datepicker) filter-cell component.
 * See the article about the [built-in filter components](slug:filter_row#toc-built-in-filter-row-components).
 *
 * @example
 *
 * ```html
 * <kendo-grid-column field="FirstOrderedOn">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-date-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *     </kendo-grid-date-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class DateFilterCellComponent extends DateFilterComponent {
    ctx;
    /**
     *  Represents a [DatePicker](slug:overview_datepicker) filter-cell component.
     * [See example](slug:filter_row#toc-built-in-filter-row-components).
     * @example
     *
     * ```html
     * <kendo-grid-column field="Discontinued">
     *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
     *     <kendo-grid-date-filter-cell
     *       [column]="column"
     *       [filter]="filter">
     *     </kendo-grid-date-filter-cell>
     *   </ng-template>
     * </kendo-grid-column>
     * ```
     * @type {boolean}
     * @default true
     */
    showOperators = true;
    subs;
    constructor(filterService, ctx, sizingService) {
        super(filterService, ctx);
        this.ctx = ctx;
        this.subs = sizingService.changes.subscribe((size) => this.size = size);
    }
    ngOnDestroy() {
        this.subs && this.subs.unsubscribe();
    }
    /**
     * @hidden
     */
    messageFor(key) {
        return this.ctx.localization.get(key);
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DateFilterCellComponent, deps: [{ token: FilterService }, { token: ContextService }, { token: SizingOptionsService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DateFilterCellComponent, isStandalone: true, selector: "kendo-grid-date-filter-cell", inputs: { showOperators: "showOperators" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
        >
            <kendo-datepicker
                kendoFilterInput
                kendoGridFocusable
                [columnLabel]="columnLabel"
                [value]="currentFilter?.value"
                [format]="format"
                [size]="size"
                [formatPlaceholder]="formatPlaceholder"
                [placeholder]="placeholder"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [min]="min"
                [max]="max"
                [weekNumber]="weekNumber"
            >
                <kendo-datepicker-messages
                    [toggle]="messageFor('filterDateToggle')"
                    [today]="messageFor('filterDateToday')"
                >
                </kendo-datepicker-messages>
            </kendo-datepicker>
        </kendo-grid-filter-wrapper-cell>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterCellWrapperComponent, selector: "kendo-grid-filter-wrapper-cell", inputs: ["showOperators"] }, { kind: "component", type: DatePickerComponent, selector: "kendo-datepicker", inputs: ["focusableId", "cellTemplate", "clearButton", "inputAttributes", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "navigationItemTemplate", "weekDaysFormat", "showOtherMonthDays", "activeView", "bottomView", "topView", "calendarType", "animateCalendarNavigation", "disabled", "readonly", "readOnlyInput", "popupSettings", "navigation", "min", "max", "incompleteDateValidation", "autoCorrectParts", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "autoFill", "focusedDate", "value", "format", "twoDigitYearMax", "formatPlaceholder", "placeholder", "tabindex", "tabIndex", "disabledDates", "title", "subtitle", "rangeValidation", "disabledDatesValidation", "weekNumber", "size", "rounded", "fillMode", "adaptiveMode"], outputs: ["valueChange", "focus", "blur", "open", "close", "escape"], exportAs: ["kendo-datepicker"] }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: ["kendoGridFocusable"] }, { kind: "component", type: DatePickerCustomMessagesComponent, selector: "kendo-datepicker-messages" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DateFilterCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-date-filter-cell',
                    template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
        >
            <kendo-datepicker
                kendoFilterInput
                kendoGridFocusable
                [columnLabel]="columnLabel"
                [value]="currentFilter?.value"
                [format]="format"
                [size]="size"
                [formatPlaceholder]="formatPlaceholder"
                [placeholder]="placeholder"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [min]="min"
                [max]="max"
                [weekNumber]="weekNumber"
            >
                <kendo-datepicker-messages
                    [toggle]="messageFor('filterDateToggle')"
                    [today]="messageFor('filterDateToday')"
                >
                </kendo-datepicker-messages>
            </kendo-datepicker>
        </kendo-grid-filter-wrapper-cell>
    `,
                    standalone: true,
                    imports: [FilterCellWrapperComponent, DatePickerComponent, FilterInputDirective, FocusableDirective, DatePickerCustomMessagesComponent]
                }]
        }], ctorParameters: function () { return [{ type: FilterService }, { type: ContextService }, { type: SizingOptionsService }]; }, propDecorators: { showOperators: [{
                type: Input
            }] } });

/**
 * Represents a string filter-cell component
 * See the article about the [built-in filter components](slug:filter_row#toc-built-in-filter-row-components).
 *
 * @example
 * ```html
 * <kendo-grid-column field="ProductName" title="Product Name">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-string-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *     </kendo-grid-string-filter-cell>
 *  </ng-template>
 * </kendo-grid-column>
 * ```
 */
class StringFilterCellComponent extends StringFilterComponent {
    /**
     * Determines the delay time (in milliseconds) before the filter value is submitted.
     * A value of `0` indicates no delay.
     * @type {boolean}
     * @default 500
     */
    filterDelay = 500;
    /**
     * Determines if the drop-down filter operators will be displayed.
     * @type {boolean}
     * @default true
     */
    showOperators = true;
    /**
     * The placeholder text for the filter input.
     * @type {string}
     */
    placeholder;
    subs;
    constructor(filterService, ctx, sizingService) {
        super(filterService, ctx);
        this.subs = sizingService.changes.subscribe((size) => this.size = size);
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StringFilterCellComponent, deps: [{ token: FilterService }, { token: ContextService }, { token: SizingOptionsService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: StringFilterCellComponent, isStandalone: true, selector: "kendo-grid-string-filter-cell", inputs: { filterDelay: "filterDelay", showOperators: "showOperators", placeholder: "placeholder" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators">
            <kendo-textbox
                kendoTextBox
                [size]="size"
                kendoGridFocusable
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [placeholder]="placeholder"
                [ngModel]="currentFilter?.value ?? null"
            ></kendo-textbox>
        </kendo-grid-filter-wrapper-cell>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterCellWrapperComponent, selector: "kendo-grid-filter-wrapper-cell", inputs: ["showOperators"] }, { kind: "component", type: TextBoxComponent, selector: "kendo-textbox", inputs: ["focusableId", "title", "type", "disabled", "readonly", "tabindex", "value", "selectOnFocus", "showSuccessIcon", "showErrorIcon", "clearButton", "successIcon", "successSvgIcon", "errorIcon", "errorSvgIcon", "clearButtonIcon", "clearButtonSvgIcon", "size", "rounded", "fillMode", "tabIndex", "placeholder", "maxlength", "inputAttributes"], outputs: ["valueChange", "inputFocus", "inputBlur", "focus", "blur"], exportAs: ["kendoTextBox"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: ["kendoGridFocusable"] }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i4.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StringFilterCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-string-filter-cell',
                    template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators">
            <kendo-textbox
                kendoTextBox
                [size]="size"
                kendoGridFocusable
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [placeholder]="placeholder"
                [ngModel]="currentFilter?.value ?? null"
            ></kendo-textbox>
        </kendo-grid-filter-wrapper-cell>
    `,
                    standalone: true,
                    imports: [FilterCellWrapperComponent, TextBoxComponent, FocusableDirective, FilterInputDirective, FormsModule]
                }]
        }], ctorParameters: function () { return [{ type: FilterService }, { type: ContextService }, { type: SizingOptionsService }]; }, propDecorators: { filterDelay: [{
                type: Input
            }], showOperators: [{
                type: Input
            }], placeholder: [{
                type: Input
            }] } });

/**
 * Represents a numeric filter-cell component.
 * See the article about the [built-in filter components](slug:filter_row#toc-built-in-filter-row-components).
 *
 * @example
 * ```html
 * <kendo-grid-column field="UnitPrice">
 *   <ng-template kendoGridFilterCellTemplate let-filter let-column="column">
 *     <kendo-grid-numeric-filter-cell
 *       [column]="column"
 *       [filter]="filter">
 *     </kendo-grid-numeric-filter-cell>
 *   </ng-template>
 * </kendo-grid-column>
 * ```
 */
class NumericFilterCellComponent extends NumericFilterComponent {
    ctx;
    /**
     * Determines the delay time (in milliseconds) before the filter value is submitted.
     * A value of `0` indicates no delay. The default value is `500`.
     * @type {boolean}\
     * @default 500
     */
    filterDelay = 500;
    /**
     * Determines if the drop-down filter operators will be displayed.
     * The default value is `true`.
     * @type {boolean}
     * @default true
     */
    showOperators = true;
    /**
    * The placeholder text for the filter input.
    * @type {string}
    */
    placeholder;
    subs;
    constructor(filterService, ctx, sizingService) {
        super(filterService, ctx);
        this.ctx = ctx;
        this.subs = sizingService.changes.subscribe((size) => this.size = size);
    }
    ngOnDestroy() {
        this.subs && this.subs.unsubscribe();
    }
    /**
     * @hidden
     */
    messageFor(key) {
        return this.ctx.localization.get(key);
    }
    /**
     * @hidden
     */
    get columnLabel() {
        const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NumericFilterCellComponent, deps: [{ token: FilterService }, { token: ContextService }, { token: SizingOptionsService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: NumericFilterCellComponent, isStandalone: true, selector: "kendo-grid-numeric-filter-cell", inputs: { filterDelay: "filterDelay", showOperators: "showOperators", placeholder: "placeholder" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
        >
            <kendo-numerictextbox
                kendoGridFocusable
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [autoCorrect]="true"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [size]="size"
                [step]="step"
                [placeholder]="placeholder"
            >
                <kendo-numerictextbox-messages
                    [increment]="messageFor('filterNumericIncrement')"
                    [decrement]="messageFor('filterNumericDecrement')"
                >
                </kendo-numerictextbox-messages>
            </kendo-numerictextbox>
        </kendo-grid-filter-wrapper-cell>
    `, isInline: true, dependencies: [{ kind: "component", type: FilterCellWrapperComponent, selector: "kendo-grid-filter-wrapper-cell", inputs: ["showOperators"] }, { kind: "component", type: NumericTextBoxComponent, selector: "kendo-numerictextbox", inputs: ["focusableId", "disabled", "readonly", "title", "autoCorrect", "format", "max", "min", "decimals", "placeholder", "step", "spinners", "rangeValidation", "tabindex", "tabIndex", "changeValueOnScroll", "selectOnFocus", "value", "maxlength", "size", "rounded", "fillMode", "inputAttributes"], outputs: ["valueChange", "focus", "blur", "inputFocus", "inputBlur"], exportAs: ["kendoNumericTextBox"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: ["kendoGridFocusable"] }, { kind: "directive", type: FilterInputDirective, selector: "[kendoFilterInput]", inputs: ["filterDelay", "columnLabel", "value"] }, { kind: "component", type: NumericTextBoxCustomMessagesComponent, selector: "kendo-numerictextbox-messages" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NumericFilterCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-numeric-filter-cell',
                    template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
        >
            <kendo-numerictextbox
                kendoGridFocusable
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [autoCorrect]="true"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [size]="size"
                [step]="step"
                [placeholder]="placeholder"
            >
                <kendo-numerictextbox-messages
                    [increment]="messageFor('filterNumericIncrement')"
                    [decrement]="messageFor('filterNumericDecrement')"
                >
                </kendo-numerictextbox-messages>
            </kendo-numerictextbox>
        </kendo-grid-filter-wrapper-cell>
    `,
                    standalone: true,
                    imports: [FilterCellWrapperComponent, NumericTextBoxComponent, FocusableDirective, FilterInputDirective, NumericTextBoxCustomMessagesComponent]
                }]
        }], ctorParameters: function () { return [{ type: FilterService }, { type: ContextService }, { type: SizingOptionsService }]; }, propDecorators: { filterDelay: [{
                type: Input
            }], showOperators: [{
                type: Input
            }], placeholder: [{
                type: Input
            }] } });

/**
 * @hidden
 *
 * > List the following components in the GridModule as `entryComponents`.
 */
const filterComponentFactory = (type) => ({
    "boolean": BooleanFilterCellComponent,
    "date": DateFilterCellComponent,
    "numeric": NumericFilterCellComponent,
    "text": StringFilterCellComponent
}[type]);

/**
 * @hidden
 */
class FilterCellHostDirective extends FilterHostDirective {
    constructor(host, resolver) {
        super(host, resolver);
    }
    componentType() {
        if (!isNullOrEmptyString(this.column.filter)) {
            return filterComponentFactory(this.column.filter);
        }
        return StringFilterCellComponent;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterCellHostDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: FilterCellHostDirective, isStandalone: true, selector: "[kendoFilterCellHost]", usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterCellHostDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoFilterCellHost]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.ComponentFactoryResolver }]; } });

/**
 * @hidden
 */
class FilterCellComponent {
    hostRole = 'gridcell';
    column;
    get filter() {
        return this._filter;
    }
    set filter(value) {
        this._filter = cloneFilters(value);
    }
    size = 'medium';
    _templateContext = {};
    _filter;
    get templateContext() {
        this._templateContext.column = this.column;
        this._templateContext.filter = this.filter;
        this._templateContext['$implicit'] = this.filter;
        return this._templateContext;
    }
    get hasTemplate() {
        return isPresent(this.column.filterCellTemplateRef);
    }
    get isFilterable() {
        return isPresent(this.column) && !isNullOrEmptyString(this.column.field) && this.column.filterable;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterCellComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: FilterCellComponent, isStandalone: true, selector: "[kendoGridFilterCell]", inputs: { column: "column", filter: "filter", size: "size" }, host: { properties: { "attr.role": "this.hostRole" } }, ngImport: i0, template: `
        <ng-container *ngIf="isFilterable">
            <ng-container [ngSwitch]="hasTemplate">
                <ng-container *ngSwitchCase="false">
                    <ng-container kendoFilterCellHost [column]="column" [filter]="filter"></ng-container>
                </ng-container>
                <ng-container *ngSwitchCase="true">
                    <ng-template
                        *ngIf="column.filterCellTemplateRef"
                        [ngTemplateOutlet]="column.filterCellTemplateRef"
                        [ngTemplateOutletContext]="templateContext">
                    </ng-template>
                </ng-container>
            </ng-container>
        </ng-container>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: FilterCellHostDirective, selector: "[kendoFilterCellHost]" }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridFilterCell]',
                    template: `
        <ng-container *ngIf="isFilterable">
            <ng-container [ngSwitch]="hasTemplate">
                <ng-container *ngSwitchCase="false">
                    <ng-container kendoFilterCellHost [column]="column" [filter]="filter"></ng-container>
                </ng-container>
                <ng-container *ngSwitchCase="true">
                    <ng-template
                        *ngIf="column.filterCellTemplateRef"
                        [ngTemplateOutlet]="column.filterCellTemplateRef"
                        [ngTemplateOutletContext]="templateContext">
                    </ng-template>
                </ng-container>
            </ng-container>
        </ng-container>
    `,
                    standalone: true,
                    imports: [NgIf, NgSwitch, NgSwitchCase, FilterCellHostDirective, NgTemplateOutlet]
                }]
        }], propDecorators: { hostRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], column: [{
                type: Input
            }], filter: [{
                type: Input
            }], size: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class FilterRowComponent {
    ctx;
    columnInfoService;
    columns = [];
    filter;
    groups = [];
    detailTemplate;
    logicalRowIndex;
    lockedColumnsCount;
    filterRowClass = true;
    constructor(ctx, columnInfoService) {
        this.ctx = ctx;
        this.columnInfoService = columnInfoService;
    }
    addStickyStyles(column) {
        const sticky = column.sticky ? this.columnInfoService.stickyColumnsStyles(column) : null;
        return { ...sticky, ...column.filterStyle };
    }
    filterLabel(column) {
        const localizationMsg = this.ctx.localization.get('filterInputLabel') || '';
        const columnName = column.title || column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    getLogicalColIndex(columnIndex) {
        const colIndex = this.lockedColumnsCount + columnIndex;
        return this.detailTemplate?.templateRef ? colIndex + 1 : colIndex;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterRowComponent, deps: [{ token: ContextService }, { token: ColumnInfoService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: FilterRowComponent, isStandalone: true, selector: "[kendoGridFilterRow]", inputs: { columns: "columns", filter: "filter", groups: "groups", detailTemplate: "detailTemplate", logicalRowIndex: "logicalRowIndex", lockedColumnsCount: "lockedColumnsCount" }, host: { properties: { "class.k-filter-row": "this.filterRowClass" } }, ngImport: i0, template: `
        <td
            class="k-table-td k-group-cell k-table-group-td"
            *ngFor="let g of groups"
            role="presentation">
        </td>
        <td
            class="k-table-td k-hierarchy-cell"
            *ngIf="detailTemplate?.templateRef"
            role="presentation">
        </td>
        <td *ngFor="let column of columns; let columnIndex = index"
            class="k-table-td"
            [class.k-grid-header-sticky]="column.sticky"
            [ngStyle]="addStickyStyles(column)"
            [ngClass]="column.filterClass"
            [attr.aria-label]="filterLabel($any(column))"
            kendoGridFilterCell
                [column]="$any(column)"
                [filter]="filter"
            kendoGridLogicalCell
                [logicalRowIndex]="logicalRowIndex"
                [logicalColIndex]="getLogicalColIndex(columnIndex)"
      ></td>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: FilterCellComponent, selector: "[kendoGridFilterCell]", inputs: ["column", "filter", "size"] }, { kind: "directive", type: LogicalCellDirective, selector: "[kendoGridLogicalCell]", inputs: ["logicalColIndex", "logicalRowIndex", "logicalSlaveCell", "colIndex", "colSpan", "rowSpan", "groupItem", "dataRowIndex", "dataItem", "detailExpandCell", "headerLabelText"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterRowComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridFilterRow]',
                    template: `
        <td
            class="k-table-td k-group-cell k-table-group-td"
            *ngFor="let g of groups"
            role="presentation">
        </td>
        <td
            class="k-table-td k-hierarchy-cell"
            *ngIf="detailTemplate?.templateRef"
            role="presentation">
        </td>
        <td *ngFor="let column of columns; let columnIndex = index"
            class="k-table-td"
            [class.k-grid-header-sticky]="column.sticky"
            [ngStyle]="addStickyStyles(column)"
            [ngClass]="column.filterClass"
            [attr.aria-label]="filterLabel($any(column))"
            kendoGridFilterCell
                [column]="$any(column)"
                [filter]="filter"
            kendoGridLogicalCell
                [logicalRowIndex]="logicalRowIndex"
                [logicalColIndex]="getLogicalColIndex(columnIndex)"
      ></td>
    `,
                    standalone: true,
                    imports: [NgFor, NgIf, FilterCellComponent, LogicalCellDirective, NgStyle, NgClass]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }, { type: ColumnInfoService }]; }, propDecorators: { columns: [{
                type: Input
            }], filter: [{
                type: Input
            }], groups: [{
                type: Input
            }], detailTemplate: [{
                type: Input
            }], logicalRowIndex: [{
                type: Input
            }], lockedColumnsCount: [{
                type: Input
            }], filterRowClass: [{
                type: HostBinding,
                args: ['class.k-filter-row']
            }] } });

/**
 * @hidden
 */
class ColumnMenuChooserItemCheckedDirective {
    host;
    kendoColumnMenuChooserItemChecked;
    checkbox;
    checkedChangeSub = new Subscription();
    constructor(host) {
        this.host = host;
    }
    ngAfterViewInit() {
        this.checkedChangeSub.add(this.checkbox.checkedStateChange.subscribe(() => {
            this.kendoColumnMenuChooserItemChecked = this.checkbox.checkedState === true;
        }));
    }
    ngOnDestroy() {
        this.checkedChangeSub.unsubscribe();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuChooserItemCheckedDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: ColumnMenuChooserItemCheckedDirective, isStandalone: true, selector: "[kendoColumnMenuChooserItemChecked]", inputs: { kendoColumnMenuChooserItemChecked: "kendoColumnMenuChooserItemChecked" }, host: { properties: { "attr.aria-checked": "this.kendoColumnMenuChooserItemChecked" } }, queries: [{ propertyName: "checkbox", first: true, predicate: CheckBoxComponent, descendants: true }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuChooserItemCheckedDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoColumnMenuChooserItemChecked]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { kendoColumnMenuChooserItemChecked: [{
                type: HostBinding,
                args: ['attr.aria-checked']
            }, {
                type: Input
            }], checkbox: [{
                type: ContentChild,
                args: [CheckBoxComponent]
            }] } });

/**
 * Represents the service that is passed to the
 * [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" [columnMenu]="true">
 *    <ng-template kendoGridColumnMenuTemplate let-service="service">
 *       <span class="k-icon k-font-icon k-i-x" (click)="service.close()" </span>
 *       <kendo-grid-columnmenu-sort [service]="service">
 *       </kendo-grid-columnmenu-sort>
 *    </ng-template>
 *    <kendo-grid-column field="Field1"></kendo-grid-column>
 * </kendo-grid>
 *
 * ```
 */
class ColumnMenuService {
    /**
     * @hidden
     */
    menuTabbingService;
    /**
     * @hidden
     */
    closeMenu = new EventEmitter();
    /**
     * @hidden
     */
    column;
    /**
     * @hidden
     */
    sort;
    /**
     * @hidden
     */
    filter;
    /**
     * @hidden
     */
    sortable;
    /**
     * Closes the column menu.
     */
    close() {
        this.closeMenu.emit();
    }
    /**
     * @hidden
     */
    columnMenuContainer;
    /**
     * @hidden
     */
    constructor(menuTabbingService) {
        this.menuTabbingService = menuTabbingService;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuService, deps: [{ token: MenuTabbingService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: MenuTabbingService }]; } });

/**
 * @hidden
 */
class ColumnListKeyboardNavigation {
    renderer;
    items;
    activeIndex = 0;
    constructor(renderer) {
        this.renderer = renderer;
    }
    next() {
        this.toggle(this.activeIndex, false);
        this.activeIndex = Math.min(this.activeIndex + 1, this.items.length - 1);
        this.toggle(this.activeIndex, true);
    }
    prev() {
        this.toggle(this.activeIndex, false);
        this.activeIndex = Math.max(this.activeIndex - 1, 0);
        this.toggle(this.activeIndex, true);
    }
    toggle(index, active) {
        const element = this.items[index]?.host.nativeElement;
        element && this.renderer.setAttribute(this.items[index].host.nativeElement, 'tabindex', active ? '0' : '-1');
        active && element && element.focus();
    }
    toggleCheckedState() {
        this.items[this.activeIndex].host.nativeElement.firstElementChild.click();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnListKeyboardNavigation, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnListKeyboardNavigation });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnListKeyboardNavigation, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; } });

/**
 * @hidden
 */
class ColumnListComponent {
    element;
    ngZone;
    renderer;
    listNavigationService;
    get className() {
        return true;
    }
    isChecked(checkbox) {
        return checkbox.checked;
    }
    reset = new EventEmitter();
    apply = new EventEmitter();
    columnChange = new EventEmitter();
    set columns(value) {
        this._columns = value.filter(column => column.includeInChooser !== false);
        this.allColumns = value;
        this.updateColumnState();
    }
    get columns() {
        return this._columns;
    }
    autoSync = true;
    ariaLabel;
    allowHideAll = false;
    applyText;
    resetText;
    actionsClass = 'k-actions k-actions-stretched k-actions-horizontal';
    isLast;
    isExpanded;
    service;
    resetButton;
    applyButton;
    options;
    checkboxes;
    hasLocked;
    hasVisibleLocked;
    unlockedCount = 0;
    hasUnlockedFiltered;
    hasFiltered;
    _columns;
    allColumns;
    domSubscriptions = new Subscription();
    constructor(element, ngZone, renderer, listNavigationService) {
        this.element = element;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.listNavigationService = listNavigationService;
    }
    ngOnInit() {
        if (!this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.domSubscriptions.add(this.renderer.listen(this.element.nativeElement, 'click', (e) => {
                this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                    const closestItem = e.target.closest('.k-column-list-item');
                    if (closestItem) {
                        const checkboxElement = closestItem.querySelector('.k-checkbox-wrap');
                        const checkbox = this.checkboxes.find(checkBox => checkBox.hostElement.nativeElement === checkboxElement);
                        const index = parseInt(checkboxElement.firstElementChild.getAttribute('data-index'), 10);
                        if (this.autoSync) {
                            if (!this.columns[index]) {
                                return;
                            }
                            const column = this.columns[index];
                            const hidden = !checkbox.checkedState;
                            if (Boolean(column.hidden) !== hidden) {
                                this.ngZone.run(() => {
                                    column.hidden = hidden;
                                    this.columnChange.emit([column]);
                                });
                            }
                        }
                        else {
                            this.updateDisabled();
                        }
                        if (index !== this.listNavigationService.activeIndex) {
                            this.listNavigationService.toggle(this.listNavigationService.activeIndex, false);
                            this.listNavigationService.activeIndex = index;
                            this.listNavigationService.toggle(index, true);
                        }
                    }
                });
            }));
            this.domSubscriptions.add(this.renderer.listen(this.element.nativeElement, 'keydown', this.onKeydown));
        });
    }
    ngAfterViewInit() {
        this.listNavigationService.items = this.options.toArray();
        this.listNavigationService.toggle(0, true);
        this.ngZone.onStable.pipe(take(1)).subscribe(() => this.updateDisabled());
    }
    ngOnChanges(changes) {
        if (!this.service) {
            return;
        }
        if (changes['isLast'] && this.isLast) {
            this.service.menuTabbingService.lastFocusable = this.applyButton.nativeElement;
        }
        if (changes['isExpanded'] && this.isExpanded && this.isLast && this.applyButton) {
            this.service.menuTabbingService.lastFocusable = this.applyButton.nativeElement;
        }
    }
    ngOnDestroy() {
        this.domSubscriptions.unsubscribe();
    }
    isDisabled(column) {
        return !(this.allowHideAll || this.hasFiltered || column.hidden || this.columns.find(current => current !== column && !current.hidden)) ||
            (this.hasVisibleLocked && !this.hasUnlockedFiltered && this.unlockedCount === 1 && !column.locked && !column.hidden);
    }
    cancelChanges() {
        this.checkboxes.forEach((element, index) => {
            element.checkedState = !this.columns[index].hidden;
        });
        this.updateDisabled();
        this.reset.emit();
    }
    applyChanges() {
        const changed = [];
        this.checkboxes.forEach((item, index) => {
            const column = this.columns[index];
            const hidden = !item.checkedState;
            if (Boolean(column.hidden) !== hidden) {
                column.hidden = hidden;
                changed.push(column);
            }
        });
        this.updateDisabled();
        this.apply.emit(changed);
    }
    onTab(e) {
        if (this.isLast) {
            e.preventDefault();
            if (this.service) {
                this.service.menuTabbingService.firstFocusable.focus();
            }
            else {
                this.listNavigationService.toggle(this.listNavigationService.activeIndex, true);
            }
        }
    }
    onKeydown = (e) => {
        if (e.keyCode !== Keys.Tab) {
            e.preventDefault();
        }
        if (e.keyCode === Keys.ArrowDown) {
            this.listNavigationService.next();
        }
        else if (e.keyCode === Keys.ArrowUp) {
            this.listNavigationService.prev();
        }
        else if (e.keyCode === Keys.Space && e.target.classList.contains('k-column-list-item')) {
            this.listNavigationService.toggleCheckedState();
        }
    };
    updateDisabled() {
        if (this.allowHideAll && !this.hasLocked) {
            return;
        }
        const checkedItems = [];
        this.checkboxes.forEach((checkbox, index) => {
            if (checkbox.checkedState) {
                checkedItems.push({ checkbox, index });
            }
            this.setDisabledState(checkbox, false);
        });
        if (!this.allowHideAll && checkedItems.length === 1 && !this.hasFiltered) {
            this.setDisabledState(checkedItems[0].checkbox, true);
        }
        else if (this.hasLocked && !this.hasUnlockedFiltered) {
            const columns = this.columns;
            const checkedUnlocked = checkedItems.filter(item => !columns[item.index].locked);
            if (checkedUnlocked.length === 1) {
                this.setDisabledState(checkedUnlocked[0].checkbox, true);
            }
        }
    }
    updateColumnState() {
        this.hasLocked = this.allColumns.filter(column => column.locked && (!column.hidden || column.includeInChooser !== false)).length > 0;
        this.hasVisibleLocked = this.allColumns.filter(column => column.locked && !column.hidden).length > 0;
        this.unlockedCount = this.columns.filter(column => !column.locked && !column.hidden).length;
        const filteredColumns = this.allColumns.filter(column => column.includeInChooser === false && !column.hidden);
        if (filteredColumns.length) {
            this.hasFiltered = filteredColumns.length > 0;
            this.hasUnlockedFiltered = filteredColumns.filter(column => !column.locked).length > 0;
        }
        else {
            this.hasFiltered = false;
            this.hasUnlockedFiltered = false;
        }
    }
    setDisabledState(checkbox, disabled) {
        this.ngZone.run(() => checkbox.disabled = disabled);
        const checkboxElement = checkbox.hostElement.nativeElement;
        const parentElement = checkboxElement.parentElement;
        const classCommand = disabled ? 'addClass' : 'removeClass';
        const attributeCommand = disabled ? 'setAttribute' : 'removeAttribute';
        this.renderer[classCommand](parentElement, 'k-disabled');
        this.renderer[attributeCommand](parentElement, 'aria-disabled', disabled ? 'true' : undefined);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnListComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: ColumnListKeyboardNavigation }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnListComponent, isStandalone: true, selector: "kendo-grid-columnlist", inputs: { columns: "columns", autoSync: "autoSync", ariaLabel: "ariaLabel", allowHideAll: "allowHideAll", applyText: "applyText", resetText: "resetText", actionsClass: "actionsClass", isLast: "isLast", isExpanded: "isExpanded", service: "service" }, outputs: { reset: "reset", apply: "apply", columnChange: "columnChange" }, host: { properties: { "class.k-column-list-wrapper": "this.className" } }, providers: [ColumnListKeyboardNavigation], viewQueries: [{ propertyName: "resetButton", first: true, predicate: ["resetButton"], descendants: true }, { propertyName: "applyButton", first: true, predicate: ["applyButton"], descendants: true }, { propertyName: "options", predicate: ColumnMenuChooserItemCheckedDirective, descendants: true }, { propertyName: "checkboxes", predicate: CheckBoxComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
        <div 
            class="k-column-list"
            role="listbox"
            aria-multiselectable="true"
            [attr.aria-label]="ariaLabel">
            <label 
                *ngFor="let column of columns; let index = index;" 
                class='k-column-list-item'
                [kendoColumnMenuChooserItemChecked]="!column.hidden"
                role="option">
                <kendo-checkbox
                    [inputAttributes]="{'data-index': index.toString()}"
                    [checkedState]="!column.hidden"
                    [disabled]="isDisabled(column)"
                ></kendo-checkbox>
                <span class="k-checkbox-label">{{ column.displayTitle }}</span>
            </label>
        </div>
        <div [ngClass]="actionsClass" *ngIf="!autoSync">
            <button
                #applyButton
                type="button"
                class="k-button k-button-solid-primary k-button-solid k-button-md k-rounded-md k-button-rectangle"
                (click)="applyChanges()"
                (keydown.enter)="$event.preventDefault(); $event.stopPropagation; applyChanges();"
                (keydown.space)="$event.preventDefault(); $event.stopPropagation; applyChanges();">{{ applyText }}</button>
            <button
                #resetButton
                type="button"
                (keydown.tab)="onTab($event)"
                class="k-button k-button-solid-base k-button-solid k-button-md k-rounded-md k-button-rectangle"
                (click)="cancelChanges()"
                (keydown.enter)="$event.preventDefault(); $event.stopPropagation; cancelChanges();"
                (keydown.space)="$event.preventDefault(); $event.stopPropagation; cancelChanges();">{{ resetText }}</button>
        </div>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: ColumnMenuChooserItemCheckedDirective, selector: "[kendoColumnMenuChooserItemChecked]", inputs: ["kendoColumnMenuChooserItemChecked"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: CheckBoxComponent, selector: "kendo-checkbox", inputs: ["checkedState", "rounded"], outputs: ["checkedStateChange"], exportAs: ["kendoCheckBox"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnlist',
                    providers: [ColumnListKeyboardNavigation],
                    template: `
        <div 
            class="k-column-list"
            role="listbox"
            aria-multiselectable="true"
            [attr.aria-label]="ariaLabel">
            <label 
                *ngFor="let column of columns; let index = index;" 
                class='k-column-list-item'
                [kendoColumnMenuChooserItemChecked]="!column.hidden"
                role="option">
                <kendo-checkbox
                    [inputAttributes]="{'data-index': index.toString()}"
                    [checkedState]="!column.hidden"
                    [disabled]="isDisabled(column)"
                ></kendo-checkbox>
                <span class="k-checkbox-label">{{ column.displayTitle }}</span>
            </label>
        </div>
        <div [ngClass]="actionsClass" *ngIf="!autoSync">
            <button
                #applyButton
                type="button"
                class="k-button k-button-solid-primary k-button-solid k-button-md k-rounded-md k-button-rectangle"
                (click)="applyChanges()"
                (keydown.enter)="$event.preventDefault(); $event.stopPropagation; applyChanges();"
                (keydown.space)="$event.preventDefault(); $event.stopPropagation; applyChanges();">{{ applyText }}</button>
            <button
                #resetButton
                type="button"
                (keydown.tab)="onTab($event)"
                class="k-button k-button-solid-base k-button-solid k-button-md k-rounded-md k-button-rectangle"
                (click)="cancelChanges()"
                (keydown.enter)="$event.preventDefault(); $event.stopPropagation; cancelChanges();"
                (keydown.space)="$event.preventDefault(); $event.stopPropagation; cancelChanges();">{{ resetText }}</button>
        </div>
    `,
                    standalone: true,
                    imports: [NgFor, ColumnMenuChooserItemCheckedDirective, NgIf, NgClass, CheckBoxComponent]
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: ColumnListKeyboardNavigation }]; }, propDecorators: { className: [{
                type: HostBinding,
                args: ["class.k-column-list-wrapper"]
            }], reset: [{
                type: Output
            }], apply: [{
                type: Output
            }], columnChange: [{
                type: Output
            }], columns: [{
                type: Input
            }], autoSync: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], allowHideAll: [{
                type: Input
            }], applyText: [{
                type: Input
            }], resetText: [{
                type: Input
            }], actionsClass: [{
                type: Input
            }], isLast: [{
                type: Input
            }], isExpanded: [{
                type: Input
            }], service: [{
                type: Input
            }], resetButton: [{
                type: ViewChild,
                args: ['resetButton', { static: false }]
            }], applyButton: [{
                type: ViewChild,
                args: ['applyButton', { static: false }]
            }], options: [{
                type: ViewChildren,
                args: [ColumnMenuChooserItemCheckedDirective]
            }], checkboxes: [{
                type: ViewChildren,
                args: [CheckBoxComponent]
            }] } });

/**
 * Represents the component for toggling visibility of the Grid columns visibility. [See example](slug:columnmenu_grid#toc-using-standalone-column-chooser).
 * To show and hide the columns without including the column chooser item in the [Column Menu](slug:columnmenu_grid),
 * add the component inside the [ToolbarTemplate](slug:toolbartemplate_grid) directive.
 *
 * @example
 * ```html
 * <kendo-grid [data]="data">
 *   <ng-template kendoGridToolbarTemplate>
 *     <kendo-grid-column-chooser></kendo-grid-column-chooser>
 *   </ng-template>
 *   <kendo-grid-column field="ProductID"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class ColumnChooserComponent {
    ctx;
    columnInfoService;
    popupService;
    ngZone;
    renderer;
    changeDetector;
    /**
     * @hidden
     */
    columnsIcon = columnsIcon;
    /**
     * Specifies if the changes in the visibility of the column will be immediately applied.
     *
     * @default false
     */
    autoSync = false;
    /**
     * Specifies if all columns can be hidden.
     *
     * @default true
     */
    allowHideAll = true;
    anchor;
    columnList;
    get columns() {
        return this.columnInfoService.leafNamedColumns;
    }
    popupRef;
    popupId;
    closeClick;
    escapeListener;
    constructor(ctx, columnInfoService, popupService, ngZone, renderer, changeDetector) {
        this.ctx = ctx;
        this.columnInfoService = columnInfoService;
        this.popupService = popupService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.changeDetector = changeDetector;
    }
    ngOnDestroy() {
        this.close();
    }
    /**
     * @hidden
     */
    toggle(anchor, template) {
        if (!this.popupRef) {
            const direction = this.ctx.localization.rtl ? 'right' : 'left';
            this.popupRef = this.popupService.open({
                anchor: anchor.element,
                content: template,
                positionMode: 'absolute',
                anchorAlign: { vertical: 'bottom', horizontal: direction },
                popupAlign: { vertical: 'top', horizontal: direction }
            });
            const popupElement = this.popupRef?.popupElement;
            if (popupElement) {
                const popupId = `k-${guid()}`;
                const popupAriaElement = popupElement.querySelector('.k-popup');
                this.ngZone.runOutsideAngular(() => {
                    this.escapeListener = this.renderer.listen(popupAriaElement, 'keydown', (e) => {
                        if (e.keyCode === Keys.Escape) {
                            this.close(true);
                        }
                    });
                });
                this.renderer.setAttribute(popupElement, 'dir', this.ctx.localization.rtl ? 'rtl' : 'ltr');
                this.renderer.setAttribute(popupAriaElement, 'id', popupId);
                this.renderer.setAttribute(popupAriaElement, 'role', 'dialog');
                this.popupId = popupId;
            }
            if (!isDocumentAvailable()) {
                return;
            }
            this.ngZone.runOutsideAngular(() => this.closeClick = this.renderer.listen('document', 'click', ({ target }) => {
                if (!closest(target, node => node === this.popupRef.popupElement || node === anchor.element)) {
                    this.ngZone.run(() => {
                        this.close();
                    });
                }
            }));
        }
        else {
            this.close();
        }
    }
    /**
     * @hidden
     */
    onApply(changed) {
        this.close(true);
        if (changed.length) {
            this.changeDetector.markForCheck();
            this.columnInfoService.changeVisibility(changed);
        }
    }
    /**
     * @hidden
     */
    onChange(changed) {
        this.changeDetector.markForCheck();
        this.columnInfoService.changeVisibility(changed);
    }
    /**
     * @hidden
     */
    onShiftTab(e) {
        if (e.target.matches('.k-column-list-item')) {
            e.preventDefault();
            this.columnList.resetButton.nativeElement.focus();
        }
    }
    close(focusAnchor = false) {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
            this.changeDetector.markForCheck();
            this.escapeListener && this.escapeListener();
        }
        this.detachClose();
        focusAnchor && this.anchor.element.focus();
    }
    detachClose() {
        if (this.closeClick) {
            this.closeClick();
            this.closeClick = null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnChooserComponent, deps: [{ token: ContextService }, { token: ColumnInfoService }, { token: i5.PopupService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnChooserComponent, isStandalone: true, selector: "kendo-grid-column-chooser", inputs: { autoSync: "autoSync", allowHideAll: "allowHideAll" }, viewQueries: [{ propertyName: "anchor", first: true, predicate: ["anchor"], descendants: true }, { propertyName: "columnList", first: true, predicate: ["columnList"], descendants: true }], ngImport: i0, template: `
        <button #anchor
            kendoButton
            type="button"
            (click)="toggle(anchor, template)"
            fillMode="flat"
            [attr.title]="ctx.localization.get('columns')"
            icon="columns"
            [svgIcon]="columnsIcon"
            [attr.aria-haspopup]="'dialog'"
            [attr.aria-expanded]="!!(popupRef)"
            [attr.aria-controls]="!!(popupRef) ? popupId : undefined"></button>
        <ng-template #template>
            <span class='k-column-chooser-title'>{{ ctx.localization.get('columns') }}</span>
            <kendo-grid-columnlist
                #columnList
                [columns]="columns"
                [ariaLabel]="ctx.localization.get('columns')"
                [isLast]="true"
                [applyText]="ctx.localization.get('columnsApply')"
                [resetText]="ctx.localization.get('columnsReset')"
                [autoSync]="autoSync"
                [allowHideAll]="allowHideAll"
                (apply)="onApply($event)"
                (columnChange)="onChange($event)"
                (keydown.shift.tab)="onShiftTab($event)">
            </kendo-grid-columnlist>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "component", type: ColumnListComponent, selector: "kendo-grid-columnlist", inputs: ["columns", "autoSync", "ariaLabel", "allowHideAll", "applyText", "resetText", "actionsClass", "isLast", "isExpanded", "service"], outputs: ["reset", "apply", "columnChange"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnChooserComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-column-chooser',
                    template: `
        <button #anchor
            kendoButton
            type="button"
            (click)="toggle(anchor, template)"
            fillMode="flat"
            [attr.title]="ctx.localization.get('columns')"
            icon="columns"
            [svgIcon]="columnsIcon"
            [attr.aria-haspopup]="'dialog'"
            [attr.aria-expanded]="!!(popupRef)"
            [attr.aria-controls]="!!(popupRef) ? popupId : undefined"></button>
        <ng-template #template>
            <span class='k-column-chooser-title'>{{ ctx.localization.get('columns') }}</span>
            <kendo-grid-columnlist
                #columnList
                [columns]="columns"
                [ariaLabel]="ctx.localization.get('columns')"
                [isLast]="true"
                [applyText]="ctx.localization.get('columnsApply')"
                [resetText]="ctx.localization.get('columnsReset')"
                [autoSync]="autoSync"
                [allowHideAll]="allowHideAll"
                (apply)="onApply($event)"
                (columnChange)="onChange($event)"
                (keydown.shift.tab)="onShiftTab($event)">
            </kendo-grid-columnlist>
        </ng-template>
    `,
                    standalone: true,
                    imports: [ButtonComponent, ColumnListComponent]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }, { type: ColumnInfoService }, { type: i5.PopupService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { autoSync: [{
                type: Input
            }], allowHideAll: [{
                type: Input
            }], anchor: [{
                type: ViewChild,
                args: ['anchor']
            }], columnList: [{
                type: ViewChild,
                args: ['columnList']
            }] } });

/**
 * @hidden
 */
class ColumnMenuItemBase {
    /**
     * Represents the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) class.
     * Requires a mandatory input.
     */
    service;
    hostClass = true;
    ngOnInit() {
        if (isDevMode() && !this.service) {
            throw new Error(ColumnMenuErrorMessages.serviceInput);
        }
    }
    /**
     * @hidden
     */
    close() {
        this.service.close();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuItemBase, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnMenuItemBase, selector: "kendo-grid-column-menu-item-base", inputs: { service: "service" }, host: { properties: { "class.k-columnmenu-item-wrapper": "this.hostClass" } }, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuItemBase, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-column-menu-item-base',
                    template: ``
                }]
        }], propDecorators: { service: [{
                type: Input
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-columnmenu-item-wrapper']
            }] } });

/**
 * @hidden
 */
const hasFilter = (settings, column) => settings.filter !== false && column.field && column.filterable;
/**
 * @hidden
 */
const hasSort = (settings, column) => settings.sort !== false && column.field && column.sortable;
/**
 * @hidden
 */
const hasLock = (settings, column) => settings.lock && column.lockable && !(column.parent && !column.parent.isSpanColumn);
/**
 * @hidden
 */
const hasStick = (settings, column) => settings.stick && column.stickable && !(column.parent && !column.parent.isSpanColumn);
/**
 * @hidden
 */
const hasPosition = (settings, column) => settings.setColumnPosition && (column.stickable || column.lockable) && !(column.parent && !column.parent.isSpanColumn);
/**
 * @hidden
 */
const hasColumnChooser = (settings) => settings.columnChooser !== false;
/**
 * @hidden
 */
const hasAutoSizeColumn = (settings) => settings.autoSizeColumn;
/**
* @hidden
*/
const hasAutoSizeAllColumns = (settings) => settings.autoSizeAllColumns;
/**
 * @hidden
 */
const autoSizeColumn = (grid, service, column) => {
    // eslint-disable-next-line no-unused-expressions
    column ? grid.autoFitColumn(column) : grid.autoFitColumns();
    service.close();
};
/**
 * @hidden
 */
const hasItems = (settings, column) => hasAutoSizeAllColumns(settings) ||
    hasColumnChooser(settings) ||
    hasFilter(settings, column) ||
    hasAutoSizeColumn(settings) ||
    hasLock(settings, column) ||
    hasSort(settings, column);

/**
 * Represents the content template of the
 * [`ColumnMenuItemComponent`]({% slug api_grid_columnmenuitemcomponent %}) component.
 * Provides an option for specifying the content of a column item.
 * To define the content template, nest an `<ng-template>` tag with the
 * `kendoGridColumnMenuItemContentTemplate` directive inside a `<kendo-grid-columnmenu-item>`.
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" [columnMenu]="true" ...>
 *   <ng-template kendoGridColumnMenuTemplate>
 *     <kendo-grid-columnmenu-item text="Item Text" [expanded]="true">
 *       <ng-template kendoGridColumnMenuItemContentTemplate>
 *         Item Content
 *       </ng-template>
 *     </kendo-grid-columnmenu-item>
 *   </ng-template>
 *   <kendo-grid-column field="Field1"></kendo-grid-column>
 *   ...
 * </kendo-grid>
 * ```
 */
class ColumnMenuItemContentTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuItemContentTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: ColumnMenuItemContentTemplateDirective, isStandalone: true, selector: "[kendoGridColumnMenuItemContentTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuItemContentTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridColumnMenuItemContentTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents an item that can be placed inside a
 * [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 *
 * @example
 * ```html
 * <kendo-grid [columnMenu]="true" ...>
 *   <ng-template kendoGridColumnMenuTemplate let-service="service" let-column="column">
 *     <kendo-grid-columnmenu-item text="Fit column"></kendo-grid-columnmenu-item>
 *   </ng-template>
 * </kendo-grid>
 * ```
 */
class ColumnMenuItemComponent {
    /**
     * Fires when the item is clicked.
     */
    itemClick = new EventEmitter();
    /**
     * Fires when the content is expanded.
     */
    expand = new EventEmitter();
    /**
     * Fires when the content is collapsed.
     */
    collapse = new EventEmitter();
    /**
     * Specifies the name of the [font icon]({% slug icons %}#toc-list-of-font-icons)
     * that will be rendered for the item.
     */
    icon;
    /**
     * Specifies the name of the [SVG icon]({% slug svgicon_list %})
     * that will be rendered for the item.
     */
    svgIcon;
    /**
     * Specifies the item text.
     */
    text;
    /**
     * Specifies if the item is selected.
     */
    selected;
    /**
     * Specifies if the item is disabled.
     */
    disabled;
    /**
     * Specifies if the item is expanded.
     */
    expanded;
    /**
     * Represents the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) class.
     * Required to include the item in the column menu keyboard navigation sequence.
     */
    service;
    contentTemplate;
    contentState = 'collapsed';
    contentId;
    chevronUpIcon = chevronUpIcon;
    chevronDownIcon = chevronDownIcon;
    get expandedIcon() {
        return this.expanded ? 'arrow-chevron-up' : 'arrow-chevron-down';
    }
    get expandedSvgIcon() {
        return this.expanded ? this.chevronUpIcon : this.chevronDownIcon;
    }
    ngAfterViewInit() {
        this.contentTemplate && (this.contentId = `k-${guid()}`);
    }
    ngOnChanges(changes) {
        if (changes.expanded) {
            this.updateContentState();
        }
    }
    /**
     * @hidden
     */
    onClick(e) {
        this.itemClick.emit(e);
        if (this.contentTemplate) {
            this.expanded = !this.expanded;
            this.updateContentState();
            if (this.expanded) {
                this.expand.emit();
            }
            else {
                this.collapse.emit();
            }
        }
    }
    updateContentState() {
        this.contentState = this.expanded ? 'expanded' : 'collapsed';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnMenuItemComponent, isStandalone: true, selector: "kendo-grid-columnmenu-item", inputs: { icon: "icon", svgIcon: "svgIcon", text: "text", selected: "selected", disabled: "disabled", expanded: "expanded", service: "service" }, outputs: { itemClick: "itemClick", expand: "expand", collapse: "collapse" }, queries: [{ propertyName: "contentTemplate", first: true, predicate: ColumnMenuItemContentTemplateDirective, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
        <div *ngIf="contentTemplate; else content" class="k-expander">
            <ng-container [ngTemplateOutlet]="content"></ng-container>
        </div>

        <ng-template #content>
            <div
                class="k-columnmenu-item"
                (click)="onClick($event)"
                (keydown.enter)="onClick($event)"
                [class.k-selected]="selected"
                [class.k-disabled]="disabled"
                role="button"
                [attr.aria-expanded]="expanded"
                [attr.aria-controls]="expanded ? contentId : undefined">
                <kendo-icon-wrapper
                    [name]="icon"
                    [svgIcon]="svgIcon"></kendo-icon-wrapper>
                {{ text }}
                <span *ngIf="contentTemplate" class="k-spacer"></span>
                <span *ngIf="contentTemplate" class="k-expander-indicator">
                    <kendo-icon-wrapper
                        [name]="expandedIcon"
                        [svgIcon]="expandedSvgIcon">
                    </kendo-icon-wrapper>
                </span>
            </div>
            <div *ngIf="contentTemplate" [attr.id]="contentId" [@state]="contentState" [style.overflow]="'hidden'" class="k-columnmenu-item-content">
                <ng-container [ngTemplateOutlet]="contentTemplate.templateRef">
                </ng-container>
            </div>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], animations: [
            trigger('state', [
                state('collapsed', style({ display: 'none' })),
                state('expanded', style({ display: 'block' })),
                transition('collapsed => expanded', [
                    style({
                        height: '0px',
                        display: 'block'
                    }),
                    animate('100ms ease-in', style({
                        height: '*'
                    }))
                ]),
                transition('expanded => collapsed', [
                    style({
                        height: '*'
                    }),
                    animate('100ms ease-in', style({
                        height: '0px'
                    }))
                ])
            ])
        ] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuItemComponent, decorators: [{
            type: Component,
            args: [{
                    animations: [
                        trigger('state', [
                            state('collapsed', style({ display: 'none' })),
                            state('expanded', style({ display: 'block' })),
                            transition('collapsed => expanded', [
                                style({
                                    height: '0px',
                                    display: 'block'
                                }),
                                animate('100ms ease-in', style({
                                    height: '*'
                                }))
                            ]),
                            transition('expanded => collapsed', [
                                style({
                                    height: '*'
                                }),
                                animate('100ms ease-in', style({
                                    height: '0px'
                                }))
                            ])
                        ])
                    ],
                    selector: 'kendo-grid-columnmenu-item',
                    template: `
        <div *ngIf="contentTemplate; else content" class="k-expander">
            <ng-container [ngTemplateOutlet]="content"></ng-container>
        </div>

        <ng-template #content>
            <div
                class="k-columnmenu-item"
                (click)="onClick($event)"
                (keydown.enter)="onClick($event)"
                [class.k-selected]="selected"
                [class.k-disabled]="disabled"
                role="button"
                [attr.aria-expanded]="expanded"
                [attr.aria-controls]="expanded ? contentId : undefined">
                <kendo-icon-wrapper
                    [name]="icon"
                    [svgIcon]="svgIcon"></kendo-icon-wrapper>
                {{ text }}
                <span *ngIf="contentTemplate" class="k-spacer"></span>
                <span *ngIf="contentTemplate" class="k-expander-indicator">
                    <kendo-icon-wrapper
                        [name]="expandedIcon"
                        [svgIcon]="expandedSvgIcon">
                    </kendo-icon-wrapper>
                </span>
            </div>
            <div *ngIf="contentTemplate" [attr.id]="contentId" [@state]="contentState" [style.overflow]="'hidden'" class="k-columnmenu-item-content">
                <ng-container [ngTemplateOutlet]="contentTemplate.templateRef">
                </ng-container>
            </div>
        </ng-template>
    `,
                    standalone: true,
                    imports: [IconWrapperComponent, NgIf, NgTemplateOutlet]
                }]
        }], propDecorators: { itemClick: [{
                type: Output
            }], expand: [{
                type: Output
            }], collapse: [{
                type: Output
            }], icon: [{
                type: Input
            }], svgIcon: [{
                type: Input
            }], text: [{
                type: Input
            }], selected: [{
                type: Input
            }], disabled: [{
                type: Input
            }], expanded: [{
                type: Input
            }], service: [{
                type: Input
            }], contentTemplate: [{
                type: ContentChild,
                args: [ColumnMenuItemContentTemplateDirective]
            }] } });

/**
 * Represents the column-menu item for resizing all columns to the minimum possible width so that they fit the widest header or cell content without wrapping.
 * [See example](slug:columnmenu_grid#toc-autosize-all-columns-item).
 *
 * The component can be placed inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * To register the component as a known column menu item, set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by
 * the template to the `service` input of the `kendo-grid-columnmenu-autosize-all-columns` component. [See example](slug:columnmenu_grid#toc-customizing-the-content).
 *
 * @example
 * ```html
 * <kendo-grid [columnMenu]="true" ...>
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-autosize-all-columns [service]="service">
 *     </kendo-grid-columnmenu-autosize-all-columns>
 *   </ng-template>
 * </kendo-grid>
 * ```
 */
class ColumnMenuAutoSizeAllColumnsComponent extends ColumnMenuItemBase {
    ctx;
    displayInlineFlexIcon = displayInlineFlexIcon;
    constructor(ctx) {
        super();
        this.ctx = ctx;
    }
    ngOnInit() {
        const isVirtualColumns = this.ctx.grid.columnMenuTemplate && this.ctx.grid.virtualColumns;
        if (isVirtualColumns && isDevMode()) {
            console.warn(ColumnMenuErrorMessages.autoSizeAllColumns);
        }
    }
    /**
     * Resizes all columns to the minimum possible width so that they fit the widest header or cell content without wrapping.
     */
    autoSizeAllColumns() {
        autoSizeColumn(this.ctx.grid, this.service);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuAutoSizeAllColumnsComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnMenuAutoSizeAllColumnsComponent, isStandalone: true, selector: "kendo-grid-columnmenu-autosize-all-columns", usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-columnmenu-item
            *ngIf="!this.ctx.grid.virtualColumns"
            [text]="ctx.localization.get('autosizeAllColumns')"
            icon="display-inline-flex"
            [svgIcon]="displayInlineFlexIcon"
            (itemClick)="autoSizeAllColumns()"
        ></kendo-grid-columnmenu-item>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "text", "selected", "disabled", "expanded", "service"], outputs: ["itemClick", "expand", "collapse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuAutoSizeAllColumnsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-autosize-all-columns',
                    template: `
        <kendo-grid-columnmenu-item
            *ngIf="!this.ctx.grid.virtualColumns"
            [text]="ctx.localization.get('autosizeAllColumns')"
            icon="display-inline-flex"
            [svgIcon]="displayInlineFlexIcon"
            (itemClick)="autoSizeAllColumns()"
        ></kendo-grid-columnmenu-item>
    `,
                    standalone: true,
                    imports: [NgIf, ColumnMenuItemComponent]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * Represents the column-menu item for resizing the specified column to the minimum possible width so that it fits the header or cell content without wrapping.
 * [See example](slug:columnmenu_grid#toc-autosize-column-item).
 * The component can be placed inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * [See example](slug:columnmenu_grid#toc-customizing-the-content).
 *
 * You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) and `column` that are passed by
 * the template to the `service` and `column` input of the `kendo-grid-columnmenu-autosize-column` component.
 *
 * @example
 * ```html
 * <kendo-grid [columnMenu]="true" ...>
 *   <ng-template kendoGridColumnMenuTemplate let-service="service" let-column="column">
 *     <kendo-grid-columnmenu-autosize-column [column]="column" [service]="service">
 *     </kendo-grid-columnmenu-autosize-column>
 *   </ng-template>
 * </kendo-grid>
 * ```
 */
class ColumnMenuAutoSizeColumnComponent extends ColumnMenuItemBase {
    ctx;
    /**
     * The Grid column instance which will be resized through the auto size column option.
     */
    column;
    maxWidthIcon = maxWidthIcon;
    constructor(ctx) {
        super();
        this.ctx = ctx;
    }
    ngOnInit() {
        const isVirtualColumns = this.ctx.grid.columnMenuTemplate && this.ctx.grid.virtualColumns;
        if (isVirtualColumns && isDevMode()) {
            console.warn(ColumnMenuErrorMessages.autoSizeColumn);
        }
    }
    /**
     * Resizes a specified column to the minimum possible width so that it fits the widest header or cell content without wrapping.
     */
    autoSizeColumn() {
        autoSizeColumn(this.ctx.grid, this.service, this.column);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuAutoSizeColumnComponent, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnMenuAutoSizeColumnComponent, isStandalone: true, selector: "kendo-grid-columnmenu-autosize-column", inputs: { column: "column" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-columnmenu-item
            *ngIf="!this.ctx.grid.virtualColumns"
            class="k-grid-columnmenu-autosize-column"
            [text]="ctx.localization.get('autosizeThisColumn')"
            icon="max-width"
            [svgIcon]="maxWidthIcon"
            (itemClick)="autoSizeColumn()"
        ></kendo-grid-columnmenu-item>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "text", "selected", "disabled", "expanded", "service"], outputs: ["itemClick", "expand", "collapse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuAutoSizeColumnComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-autosize-column',
                    template: `
        <kendo-grid-columnmenu-item
            *ngIf="!this.ctx.grid.virtualColumns"
            class="k-grid-columnmenu-autosize-column"
            [text]="ctx.localization.get('autosizeThisColumn')"
            icon="max-width"
            [svgIcon]="maxWidthIcon"
            (itemClick)="autoSizeColumn()"
        ></kendo-grid-columnmenu-item>
    `,
                    standalone: true,
                    imports: [NgIf, ColumnMenuItemComponent]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }]; }, propDecorators: { column: [{
                type: Input
            }] } });

/**
 * Represents the column-menu item for selecting columns in the Grid. [See example](slug:columnmenu_grid#toc-column-chooser-item).
 *
 * The component can be placed inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * To register the component as a known column menu item, set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by
 * the template to the service input of the `kendo-grid-columnmenu-chooser` component. [See example](slug:columnmenu_grid#toc-customizing-the-content).
 *
 * @example
 * ```html
 * <kendo-grid [columnMenu]="true" ...>
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-chooser [service]="service"> </kendo-grid-columnmenu-chooser>
 *   </ng-template>
 * </kendo-grid>
 * ```
 */
class ColumnMenuChooserComponent extends ColumnMenuItemBase {
    ctx;
    columnInfoService;
    changeDetector;
    hostElement;
    /**
     * Fires when the content is expanded.
     */
    expand = new EventEmitter();
    /**
     * Fires when the content is collapsed.
     */
    collapse = new EventEmitter();
    /**
     * Specifies if the content is expanded.
     * @default false
     */
    expanded = false;
    /**
     * @hidden
     */
    isLast = false;
    /**
     * @hidden
     */
    actionsClass = 'k-actions k-actions-stretched k-actions-horizontal';
    get columns() {
        return this.columnInfoService.leafNamedColumns;
    }
    columnsIcon = columnsIcon;
    constructor(ctx, columnInfoService, changeDetector, hostElement) {
        super();
        this.ctx = ctx;
        this.columnInfoService = columnInfoService;
        this.changeDetector = changeDetector;
        this.hostElement = hostElement;
    }
    /**
     * @hidden
     */
    onApply(changed) {
        this.close();
        if (changed.length) {
            this.changeDetector.markForCheck();
            this.columnInfoService.changeVisibility(changed);
        }
    }
    /**
     * @hidden
     */
    onCollapse() {
        this.expanded = false;
        if (this.isLast) {
            this.service.menuTabbingService.lastFocusable = this.hostElement.nativeElement.querySelector('.k-columnmenu-item');
        }
        this.collapse.emit();
    }
    /**
     * @hidden
     */
    onExpand() {
        this.expanded = true;
        this.expand.emit();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuChooserComponent, deps: [{ token: ContextService }, { token: ColumnInfoService }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnMenuChooserComponent, isStandalone: true, selector: "kendo-grid-columnmenu-chooser", inputs: { expanded: "expanded", isLast: "isLast" }, outputs: { expand: "expand", collapse: "collapse" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('columns')"
            icon="columns"
            [svgIcon]="columnsIcon"
            [expanded]="expanded"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-columnlist
                    [applyText]="ctx.localization.get('columnsApply')"
                    [resetText]="ctx.localization.get('columnsReset')"
                    [ariaLabel]="ctx.localization.get('columns')"
                    [columns]="columns"
                    [autoSync]="false"
                    [allowHideAll]="false"
                    [actionsClass]="actionsClass"
                    [isLast]="isLast"
                    [isExpanded]="expanded"
                    [service]="service"
                    (apply)="onApply($event)">
                </kendo-grid-columnlist>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `, isInline: true, dependencies: [{ kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "text", "selected", "disabled", "expanded", "service"], outputs: ["itemClick", "expand", "collapse"] }, { kind: "directive", type: ColumnMenuItemContentTemplateDirective, selector: "[kendoGridColumnMenuItemContentTemplate]" }, { kind: "component", type: ColumnListComponent, selector: "kendo-grid-columnlist", inputs: ["columns", "autoSync", "ariaLabel", "allowHideAll", "applyText", "resetText", "actionsClass", "isLast", "isExpanded", "service"], outputs: ["reset", "apply", "columnChange"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuChooserComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-chooser',
                    template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('columns')"
            icon="columns"
            [svgIcon]="columnsIcon"
            [expanded]="expanded"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-columnlist
                    [applyText]="ctx.localization.get('columnsApply')"
                    [resetText]="ctx.localization.get('columnsReset')"
                    [ariaLabel]="ctx.localization.get('columns')"
                    [columns]="columns"
                    [autoSync]="false"
                    [allowHideAll]="false"
                    [actionsClass]="actionsClass"
                    [isLast]="isLast"
                    [isExpanded]="expanded"
                    [service]="service"
                    (apply)="onApply($event)">
                </kendo-grid-columnlist>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `,
                    standalone: true,
                    imports: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnListComponent]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }, { type: ColumnInfoService }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }]; }, propDecorators: { expand: [{
                type: Output
            }], collapse: [{
                type: Output
            }], expanded: [{
                type: Input
            }], isLast: [{
                type: Input
            }] } });

/**
 * Represents the column-menu item that sticks or unsticks columns in the Grid.
 * [See example](slug:columnmenu_grid#toc-stick-and-unstick-items).
 *
 * The component can be placed inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * To register the component as a known column menu item, set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by
 * the template to the service input of the `kendo-grid-columnmenu-lock` component. [See example](slug:columnmenu_grid#toc-customizing-the-content).
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" [columnMenu]="true">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *      <kendo-grid-columnmenu-stick [service]="service">
 *      </kendo-grid-columnmenu-stick>
 *   </ng-template>
 * </kendo-grid>
 *
 * ```
 */
class ColumnMenuStickComponent extends ColumnMenuItemBase {
    ctx;
    columnInfoService;
    changeDetector;
    stickIcon = stickIcon;
    unstickIcon = unstickIcon;
    constructor(ctx, columnInfoService, changeDetector) {
        super();
        this.ctx = ctx;
        this.columnInfoService = columnInfoService;
        this.changeDetector = changeDetector;
    }
    get text() {
        return this.ctx.localization.get(this.sticky ? 'unstick' : 'stick');
    }
    get icon() {
        return this.sticky ? 'unstick' : 'stick';
    }
    get svgIcon() {
        return this.sticky ? this.unstickIcon : this.stickIcon;
    }
    get disabled() {
        return !this.sticky && this.columnInfoService.unlockedRootCount < 2;
    }
    /**
     * @hidden
     */
    toggleColumn() {
        this.toggleHierarchy(!this.sticky);
        this.close();
        this.changeDetector.markForCheck();
    }
    toggleHierarchy(sticky) {
        let root = this.service.column;
        while (root.parent) {
            root = root.parent;
        }
        const columns = [root];
        const allChanged = [];
        while (columns.length) {
            const column = columns.shift();
            column.sticky = sticky;
            allChanged.push(column);
            if (column.hasChildren) {
                columns.push(...column.childrenArray);
            }
        }
        this.columnInfoService.changeStuck(allChanged);
    }
    get sticky() {
        return this.service.column.sticky;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuStickComponent, deps: [{ token: ContextService }, { token: ColumnInfoService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnMenuStickComponent, isStandalone: true, selector: "kendo-grid-columnmenu-stick", usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-columnmenu-item
           [text]="text"
           [icon]="icon"
           [svgIcon]="svgIcon"
           (itemClick)="toggleColumn()"
           [disabled]="disabled">
        </kendo-grid-columnmenu-item>
    `, isInline: true, dependencies: [{ kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "text", "selected", "disabled", "expanded", "service"], outputs: ["itemClick", "expand", "collapse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuStickComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-stick',
                    template: `
        <kendo-grid-columnmenu-item
           [text]="text"
           [icon]="icon"
           [svgIcon]="svgIcon"
           (itemClick)="toggleColumn()"
           [disabled]="disabled">
        </kendo-grid-columnmenu-item>
    `,
                    standalone: true,
                    imports: [ColumnMenuItemComponent]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }, { type: ColumnInfoService }, { type: i0.ChangeDetectorRef }]; } });

/**
 * Represents the column-menu item for locking and unlocking columns in the Grid. [See example](slug:columnmenu_grid#toc-lock-and-unlock-items).
 *
 * The component can be placed inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * To register the component as a known column menu item, set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by
 * the template to the service input of the `kendo-grid-columnmenu-lock` component. [See example](slug:columnmenu_grid#toc-customizing-the-content).
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" [columnMenu]="true" ...>
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-lock [service]="service">
 *     </kendo-grid-columnmenu-lock>
 *   </ng-template>
 * </kendo-grid>
 * ```
 */
class ColumnMenuLockComponent extends ColumnMenuItemBase {
    ctx;
    columnInfoService;
    changeDetector;
    constructor(ctx, columnInfoService, changeDetector) {
        super();
        this.ctx = ctx;
        this.columnInfoService = columnInfoService;
        this.changeDetector = changeDetector;
    }
    get text() {
        return this.ctx.localization.get(this.locked ? 'unlock' : 'lock');
    }
    get icon() {
        return this.locked ? 'unlock' : 'lock';
    }
    unlockIcon = unlockIcon;
    lockIcon = lockIcon;
    get svgIcon() {
        return this.locked ? this.unlockIcon : this.lockIcon;
    }
    get disabled() {
        return !this.locked && this.columnInfoService.unlockedRootCount < 2;
    }
    /**
     * @hidden
     */
    toggleColumn() {
        this.toggleHierarchy(!this.locked);
        this.close();
        this.changeDetector.markForCheck();
    }
    toggleHierarchy(locked) {
        let root = this.service.column;
        while (root.parent) {
            root = root.parent;
        }
        const columns = [root];
        const allChanged = [];
        while (columns.length) {
            const column = columns.shift();
            column.locked = locked;
            allChanged.push(column);
            if (column.hasChildren) {
                columns.push(...column.childrenArray);
            }
        }
        this.columnInfoService.changeLocked(allChanged);
    }
    get locked() {
        return this.service.column.locked;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuLockComponent, deps: [{ token: ContextService }, { token: ColumnInfoService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnMenuLockComponent, isStandalone: true, selector: "kendo-grid-columnmenu-lock", usesInheritance: true, ngImport: i0, template: `
       <kendo-grid-columnmenu-item
            [text]="text"
            [icon]="icon"
            [svgIcon]="svgIcon"
            (itemClick)="toggleColumn()"
            [disabled]="disabled">
       </kendo-grid-columnmenu-item>
    `, isInline: true, dependencies: [{ kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "text", "selected", "disabled", "expanded", "service"], outputs: ["itemClick", "expand", "collapse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuLockComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-lock',
                    template: `
       <kendo-grid-columnmenu-item
            [text]="text"
            [icon]="icon"
            [svgIcon]="svgIcon"
            (itemClick)="toggleColumn()"
            [disabled]="disabled">
       </kendo-grid-columnmenu-item>
    `,
                    standalone: true,
                    imports: [ColumnMenuItemComponent]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }, { type: ColumnInfoService }, { type: i0.ChangeDetectorRef }]; } });

/**
 * Represents the column-menu item which combines the lock and sticky column functionalities.
 *
 * The component can be placed inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * To register the component as a known column menu item, set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by
 * the template to the service input of the `kendo-grid-columnmenu-position` component. [See example](slug:columnmenu_grid#toc-set-column-position-item).
 *
 * @example
 * ```html
 * <kendo-grid [data]="data" [columnMenu]="true" ...>
 *   <ng-template kendoGridColumnMenuTemplate let-service="service" let-column="column">
 *     <kendo-grid-columnmenu-position [service]="service" [showLock]="true" [showStick]="true">
 *     </kendo-grid-columnmenu-position>
 *   </ng-template>
 * </kendo-grid>
 * ```
 */
class ColumnMenuPositionComponent extends ColumnMenuItemBase {
    ctx;
    hostElement;
    /**
     * Fires when the content is expanded.
     */
    expand = new EventEmitter();
    /**
     * Fires when the content is collapsed.
     */
    collapse = new EventEmitter();
    /**
     * Specifies if the content is expanded.
     * @default false
     */
    expanded = false;
    /**
     * Specifies if the lock column item is displayed.
     */
    showLock;
    /**
     * Specifies if the stick column item is displayed.
     */
    showStick;
    /**
     * @hidden
     */
    actionsClass = 'k-actions';
    /**
     * @hidden
     */
    set isLast(value) {
        this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
        this._isLast = value;
    }
    /**
     * @hidden
     */
    get isLast() {
        return this._isLast;
    }
    setColumnPositionIcon = setColumnPositionIcon;
    _isLast = false;
    constructor(ctx, hostElement) {
        super();
        this.ctx = ctx;
        this.hostElement = hostElement;
    }
    /**
     * @hidden
     */
    onTab(e, isLastItem) {
        if (this.isLast && isLastItem) {
            e.preventDefault();
            e.stopImmediatePropagation();
            if (this.service) {
                this.service.menuTabbingService.firstFocusable.focus();
            }
        }
    }
    /**
     * @hidden
     */
    onCollapse() {
        this.expanded = false;
        if (this.isLast) {
            this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
        }
        this.collapse.emit();
    }
    /**
     * @hidden
     */
    onExpand() {
        this.expanded = true;
        if (this.isLast) {
            this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
        }
        this.expand.emit();
    }
    getLastFocusableItem() {
        const menuItems = this.hostElement.nativeElement.querySelectorAll('.k-columnmenu-item');
        const lastFocusableIndex = this.expanded ? menuItems.length - 1 : 0;
        return menuItems[lastFocusableIndex];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuPositionComponent, deps: [{ token: ContextService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnMenuPositionComponent, isStandalone: true, selector: "kendo-grid-columnmenu-position", inputs: { expanded: "expanded", showLock: "showLock", showStick: "showStick", isLast: "isLast" }, outputs: { expand: "expand", collapse: "collapse" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('setColumnPosition')"
            icon="set-column-position"
            [svgIcon]="setColumnPositionIcon"
            [expanded]="expanded"
            (keydown.tab)="onTab($event, !expanded)"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-columnmenu-lock
                    *ngIf="showLock"
                    (keydown.tab)="onTab($event, !showStick)"
                    [service]="service">
                </kendo-grid-columnmenu-lock>
                <kendo-grid-columnmenu-stick
                    *ngIf="showStick"
                    (keydown.tab)="onTab($event, true)"
                    [service]="service">
                </kendo-grid-columnmenu-stick>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `, isInline: true, dependencies: [{ kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "text", "selected", "disabled", "expanded", "service"], outputs: ["itemClick", "expand", "collapse"] }, { kind: "directive", type: ColumnMenuItemContentTemplateDirective, selector: "[kendoGridColumnMenuItemContentTemplate]" }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: ColumnMenuLockComponent, selector: "kendo-grid-columnmenu-lock" }, { kind: "component", type: ColumnMenuStickComponent, selector: "kendo-grid-columnmenu-stick" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuPositionComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-position',
                    template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('setColumnPosition')"
            icon="set-column-position"
            [svgIcon]="setColumnPositionIcon"
            [expanded]="expanded"
            (keydown.tab)="onTab($event, !expanded)"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-columnmenu-lock
                    *ngIf="showLock"
                    (keydown.tab)="onTab($event, !showStick)"
                    [service]="service">
                </kendo-grid-columnmenu-lock>
                <kendo-grid-columnmenu-stick
                    *ngIf="showStick"
                    (keydown.tab)="onTab($event, true)"
                    [service]="service">
                </kendo-grid-columnmenu-stick>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `,
                    standalone: true,
                    imports: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, NgIf, ColumnMenuLockComponent, ColumnMenuStickComponent]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }, { type: i0.ElementRef }]; }, propDecorators: { expand: [{
                type: Output
            }], collapse: [{
                type: Output
            }], expanded: [{
                type: Input
            }], showLock: [{
                type: Input
            }], showStick: [{
                type: Input
            }], isLast: [{
                type: Input
            }] } });

/**
 * Represents the column-menu item for editing column filters in the Grid. [See example](slug:columnmenu_grid#toc-filter-item).
 *
 * The component can be placed inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * To register the component as a known column menu item, set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by
 * the template to the service input of the `kendo-grid-columnmenu-filter` component. [See example](slug:columnmenu_grid#toc-customizing-the-content).
 *
 * @example
 * ```html
 * <kendo-grid [columnMenu]="true" ...>
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-filter [service]="service">
 *     </kendo-grid-columnmenu-filter>
 *   </ng-template>
 * </kendo-grid>
 * ```
 */
class ColumnMenuFilterComponent extends ColumnMenuItemBase {
    ctx;
    hostElement;
    /**
     * Fires when the content is expanded.
     */
    expand = new EventEmitter();
    /**
     * Fires when the content is collapsed.
     */
    collapse = new EventEmitter();
    /**
     * Specifies if the content is expanded.
     * @default false
     */
    expanded = false;
    /**
     * @hidden
     */
    isLast = false;
    /**
     * @hidden
     */
    actionsClass = 'k-actions k-actions-stretched k-actions-horizontal';
    filterIcon = filterIcon;
    constructor(ctx, hostElement) {
        super();
        this.ctx = ctx;
        this.hostElement = hostElement;
    }
    /**
     * @hidden
     */
    onCollapse() {
        this.expanded = false;
        if (this.isLast) {
            this.service.menuTabbingService.lastFocusable = this.hostElement.nativeElement.querySelector('.k-columnmenu-item');
        }
        this.collapse.emit();
    }
    /**
     * @hidden
     */
    onExpand() {
        this.expanded = true;
        this.expand.emit();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuFilterComponent, deps: [{ token: ContextService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnMenuFilterComponent, isStandalone: true, selector: "kendo-grid-columnmenu-filter", inputs: { expanded: "expanded", isLast: "isLast" }, outputs: { expand: "expand", collapse: "collapse" }, usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('filter')"
            icon="filter"
            [svgIcon]="filterIcon"
            [expanded]="expanded"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-filter-menu-container
                    [column]="service.column"
                    [menuTabbingService]="service.menuTabbingService"
                    [filter]="service.filter"
                    [actionsClass]="actionsClass"
                    [isLast]="isLast"
                    [isExpanded]="expanded"
                    (keydown.shift.tab)="$event.stopImmediatePropagation()"
                    (close)="close()">
                </kendo-grid-filter-menu-container>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `, isInline: true, dependencies: [{ kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "text", "selected", "disabled", "expanded", "service"], outputs: ["itemClick", "expand", "collapse"] }, { kind: "directive", type: ColumnMenuItemContentTemplateDirective, selector: "[kendoGridColumnMenuItemContentTemplate]" }, { kind: "component", type: FilterMenuContainerComponent, selector: "kendo-grid-filter-menu-container", inputs: ["column", "isLast", "isExpanded", "menuTabbingService", "filter", "actionsClass"], outputs: ["close"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-filter',
                    template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('filter')"
            icon="filter"
            [svgIcon]="filterIcon"
            [expanded]="expanded"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-filter-menu-container
                    [column]="service.column"
                    [menuTabbingService]="service.menuTabbingService"
                    [filter]="service.filter"
                    [actionsClass]="actionsClass"
                    [isLast]="isLast"
                    [isExpanded]="expanded"
                    (keydown.shift.tab)="$event.stopImmediatePropagation()"
                    (close)="close()">
                </kendo-grid-filter-menu-container>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `,
                    standalone: true,
                    imports: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, FilterMenuContainerComponent]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }, { type: i0.ElementRef }]; }, propDecorators: { expand: [{
                type: Output
            }], collapse: [{
                type: Output
            }], expanded: [{
                type: Input
            }], isLast: [{
                type: Input
            }] } });

class ColumnMenuItemDirective {
    hostElement;
    renderer;
    ngZone;
    /**
     * The reference to the Grid column menu item. Required to include the item in the built-in keyboard navigation.
     */
    menuItemComponent;
    firstFocusableElement;
    lastFocusableElement;
    /**
     * @hidden
     */
    set isFirst(value) {
        if (value) {
            const focusableElement = this.columnMenuItems[0];
            this.menuItemComponent.service.menuTabbingService.firstFocusable = focusableElement;
            this.ngZone.runOutsideAngular(() => {
                const firstItemKeydownSub = this.renderer.listen(focusableElement, 'keydown', this.onTab);
                this.subs.add(firstItemKeydownSub);
            });
        }
        this._isFirst = value;
    }
    /**
     * @hidden
     */
    get isFirst() {
        return this._isFirst;
    }
    /**
     * @hidden
     */
    set isLast(value) {
        if (!this.columnMenuItems) {
            return;
        }
        if (value) {
            const lastFocusableElement = this.getLastColumnMenuItem();
            this.menuItemComponent.service.menuTabbingService.lastFocusable = lastFocusableElement;
            this.ngZone.runOutsideAngular(() => {
                const lastItemKeydownSub = this.renderer.listen(lastFocusableElement, 'keydown', this.onTab);
                this.subs.add(lastItemKeydownSub);
            });
            if (this.isExpandableItem()) {
                this.menuItemComponent.isLast = true;
            }
        }
        this._isLast = value;
    }
    /**
     * @hidden
     */
    get isLast() {
        return this._isLast;
    }
    _isFirst = false;
    _isLast = false;
    columnMenuItems;
    subs = new Subscription();
    constructor(hostElement, renderer, ngZone) {
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.ngZone = ngZone;
    }
    ngAfterViewInit() {
        this.columnMenuItems = this.hostElement.nativeElement.querySelectorAll('.k-columnmenu-item');
        [].slice.apply(this.columnMenuItems).forEach(el => this.renderer.setAttribute(el, 'tabindex', '0'));
        if (this.menuItemComponent instanceof ColumnMenuFilterComponent) {
            this.menuItemComponent.service.menuTabbingService.isColumnMenu = true;
        }
        this.menuItemComponent.service?.columnMenuContainer.templateMenuItems.push(this);
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    onTab = (e) => {
        if (e.keyCode !== Keys.Tab) {
            return;
        }
        if (this.isFirst && e.shiftKey && e.target === this.columnMenuItems[0]) {
            e.preventDefault();
            this.menuItemComponent.service.menuTabbingService.lastFocusable.focus();
        }
        if (this.isLast && !e.shiftKey) {
            const lastColumnMenuItem = this.getLastColumnMenuItem();
            const isExpanded = this.menuItemComponent.expanded;
            if (lastColumnMenuItem === e.target && !isExpanded) {
                e.preventDefault();
                this.menuItemComponent.service.menuTabbingService.firstFocusable.focus();
            }
        }
    };
    getLastColumnMenuItem() {
        return (this.columnMenuItems.length === 1 ? this.columnMenuItems[0] : this.columnMenuItems[1]);
    }
    isExpandableItem() {
        return this.menuItemComponent instanceof ColumnMenuFilterComponent ||
            this.menuItemComponent instanceof ColumnMenuChooserComponent ||
            this.menuItemComponent instanceof ColumnMenuPositionComponent;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuItemDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: ColumnMenuItemDirective, isStandalone: true, selector: "[kendoGridColumnMenuItem]", inputs: { menuItemComponent: ["kendoGridColumnMenuItem", "menuItemComponent"] }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridColumnMenuItem]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }]; }, propDecorators: { menuItemComponent: [{
                type: Input,
                args: ['kendoGridColumnMenuItem']
            }] } });

/**
 * @hidden
 */
class ColumnMenuContainerComponent {
    service;
    ngZone;
    columnMenuItems;
    templateMenuItems = [];
    constructor(service, ngZone) {
        this.service = service;
        this.ngZone = ngZone;
        service.columnMenuContainer = this;
    }
    ngAfterViewInit() {
        if (this.columnMenuItems.length) {
            this.columnMenuItems.first.isFirst = true;
            this.columnMenuItems.last.isLast = true;
        }
        else if (this.templateMenuItems.length) {
            this.templateMenuItems[0].isFirst = true;
            this.templateMenuItems[this.templateMenuItems.length - 1].isLast = true;
        }
        else {
            return;
        }
        this.ngZone.onStable.pipe(take(1)).subscribe(() => this.service.menuTabbingService.firstFocusable.focus());
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuContainerComponent, deps: [{ token: ColumnMenuService }, { token: NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnMenuContainerComponent, isStandalone: true, selector: "kendo-grid-columnmenu-container", queries: [{ propertyName: "columnMenuItems", predicate: ColumnMenuItemDirective, descendants: true }], ngImport: i0, template: `
        <ng-content></ng-content>
    `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-container',
                    template: `
        <ng-content></ng-content>
    `,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ColumnMenuService }, { type: i0.NgZone, decorators: [{
                    type: Inject,
                    args: [NgZone]
                }] }]; }, propDecorators: { columnMenuItems: [{
                type: ContentChildren,
                args: [ColumnMenuItemDirective, { descendants: true }]
            }] } });

/**
 * @hidden
 */
class SortService {
    changes = new Subject();
    sort(value) {
        this.changes.next(value);
    }
}

/**
 * @hidden
 */
const DEFAULTS = {
    allowUnsort: true,
    mode: 'single',
    showIndexes: true,
    initialDirection: 'asc',
    multiSortKey: 'none'
};
/**
 * @hidden
 */
const normalize$1 = (...settings) => Object.assign({}, DEFAULTS, ...settings);

/**
 * Represents the column-menu item for sorting Grid columns.
 * [See example](slug:columnmenu_grid#toc-sort-item).
 *
 * The component can be placed inside a [ColumnMenuTemplate]({% slug api_grid_columnmenutemplatedirective %}) directive.
 * To register the component as a known column menu item, set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by
 * the template to the service input of the `kendo-grid-columnmenu-sort` component. [See example](slug:columnmenu_grid#toc-customizing-the-content).
 *
 * You have to set the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) that is passed by
 * the template to the service input of the `kendo-grid-columnmenu-sort` component.
 *
 * @example
 * ```html
 * <kendo-grid [kendoGridBinding]="data" [sortable]="true" [columnMenu]="true">
 *   <ng-template kendoGridColumnMenuTemplate let-service="service">
 *     <kendo-grid-columnmenu-sort [service]="service">
 *     </kendo-grid-columnmenu-sort>
 *   </ng-template>
 * </kendo-grid>
 * ```
 */
class ColumnMenuSortComponent extends ColumnMenuItemBase {
    ctx;
    sortService;
    renderer;
    sortAscSmallIcon = sortAscSmallIcon;
    sortDescSmallIcon = sortDescSmallIcon;
    constructor(ctx, sortService, renderer) {
        super();
        this.ctx = ctx;
        this.sortService = sortService;
        this.renderer = renderer;
    }
    get sortedAsc() {
        const descriptor = this.descriptor;
        return descriptor && (!descriptor.dir || descriptor.dir === 'asc');
    }
    get sortedDesc() {
        const descriptor = this.descriptor;
        return descriptor && descriptor.dir === 'desc';
    }
    /**
     * @hidden
     */
    toggleSort(dir) {
        const field = this.service.column.field;
        const { mode, allowUnsort } = normalize$1(this.service.sortable);
        const descriptor = this.descriptor;
        const sort = mode === 'multiple' ? this.service.sort.filter(s => s.field !== field) : [];
        if (descriptor && descriptor.dir === dir) {
            if (!allowUnsort) {
                return;
            }
        }
        else {
            sort.push({ field, dir });
        }
        this.sortService.sort(sort);
        this.close();
    }
    get descriptor() {
        return [].concat(this.service.sort || []).find(s => s.field === this.service.column.field);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuSortComponent, deps: [{ token: ContextService }, { token: SortService }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnMenuSortComponent, isStandalone: true, selector: "kendo-grid-columnmenu-sort", usesInheritance: true, ngImport: i0, template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('sortAscending')"
            icon="sort-asc-small"
            [svgIcon]="sortAscSmallIcon"
            (itemClick)="toggleSort('asc')"
            [selected]="sortedAsc">
        </kendo-grid-columnmenu-item>
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('sortDescending')"
            icon="sort-desc-small"
            [svgIcon]="sortDescSmallIcon"
            (itemClick)="toggleSort('desc')"
            [selected]="sortedDesc">
        </kendo-grid-columnmenu-item>
    `, isInline: true, dependencies: [{ kind: "component", type: ColumnMenuItemComponent, selector: "kendo-grid-columnmenu-item", inputs: ["icon", "svgIcon", "text", "selected", "disabled", "expanded", "service"], outputs: ["itemClick", "expand", "collapse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuSortComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnmenu-sort',
                    template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('sortAscending')"
            icon="sort-asc-small"
            [svgIcon]="sortAscSmallIcon"
            (itemClick)="toggleSort('asc')"
            [selected]="sortedAsc">
        </kendo-grid-columnmenu-item>
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('sortDescending')"
            icon="sort-desc-small"
            [svgIcon]="sortDescSmallIcon"
            (itemClick)="toggleSort('desc')"
            [selected]="sortedDesc">
        </kendo-grid-columnmenu-item>
    `,
                    standalone: true,
                    imports: [ColumnMenuItemComponent]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }, { type: SortService }, { type: i0.Renderer2 }]; } });

const POPUP_CLASSES = 'k-grid-columnmenu-popup k-column-menu';
let id = 0;
const getId = (gridId) => `${gridId}-column-menu-${id++}`;
/**
 * Represents the [column menu](slug:columnmenu_grid#toc-customizing-the-position) component.
 * ```html
 * <kendo-grid ...>
 *   <kendo-grid-column field="ProductName" [columnMenu]="false">
 *     <ng-template kendoGridHeaderTemplate let-column>
 *        <kendo-grid-column-menu [column]="column"> </kendo-grid-column-menu>
 *     </ng-template>
 *   </kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class ColumnMenuComponent {
    navigationService;
    popupService;
    service;
    ctx;
    renderer;
    cdr;
    columnInfoService;
    idService;
    /**
     * @hidden
     */
    standalone = true;
    /**
     * The Grid column instance to control with the menu.
     */
    column;
    /**
     * The settings for the Column Menu.
     */
    settings = {};
    /**
     * The descriptors by which the data will be sorted.
     * Typically bound to the same value as [GridComponent.sort]({% slug api_grid_gridcomponent %}#toc-sort).
     */
    sort;
    /**
     * The descriptor by which the data will be filtered.
     * Typically bound to the same value as [GridComponent.filter]({% slug api_grid_gridcomponent %}#toc-filter).
     */
    filter;
    /**
     * @hidden
     */
    sortable = true;
    /**
     * @hidden
     */
    columnMenuTemplate;
    /**
     * @hidden
     */
    tabIndex = '-1';
    anchor;
    template;
    defaultTemplate;
    tabbedInterfaceTemplate;
    tabStrip;
    /**
     * @hidden
     */
    columnsIcon = columnsIcon;
    /**
     * @hidden
     */
    actionsClass = 'k-actions';
    /**
     * @hidden
     */
    slidersIcon = slidersIcon;
    /**
     * @hidden
     */
    filterIcon = filterIcon;
    /**
     * @hidden
     */
    expandedFilter = false;
    /**
     * @hidden
     */
    expandedColumns = false;
    /**
     * @hidden
     */
    expandedPosition = false;
    /**
     * @hidden
     */
    get showGeneralTab() {
        return this.hasSort
            || this.hasLock
            || this.hasStick
            || this.hasPosition
            || this.hasAutoSizeColumn
            || this.hasAutoSizeAllColumns;
    }
    moreVerticalIcon = moreVerticalIcon;
    popupRef;
    closeSubscription;
    popupSubs;
    constructor(navigationService, popupService, service, ctx, renderer, cdr, columnInfoService, idService) {
        this.navigationService = navigationService;
        this.popupService = popupService;
        this.service = service;
        this.ctx = ctx;
        this.renderer = renderer;
        this.cdr = cdr;
        this.columnInfoService = columnInfoService;
        this.idService = idService;
        this.closeSubscription = service.closeMenu.subscribe(this.close.bind(this, true));
    }
    /**
     * @hidden
     */
    get isActive() {
        return (this.hasFilter && filtersByField(this.filter, this.column.field).length > 0) ||
            (!this.sortable && this.hasSort && this.sort.find(descriptor => descriptor.field === this.column.field));
    }
    /**
     * @hidden
     */
    get hasFilter() {
        return hasFilter(this.settings, this.column);
    }
    /**
     * @hidden
     */
    get isNavigable() {
        return this.navigationService.tableEnabled;
    }
    /**
     * @hidden
     */
    get hasSort() {
        return hasSort(this.settings, this.column);
    }
    /**
     * @hidden
     */
    get hasColumnChooser() {
        return hasColumnChooser(this.settings);
    }
    /**
     * @hidden
     */
    onApply(changed) {
        this.close(true);
        if (changed.length) {
            this.cdr.markForCheck();
            this.columnInfoService.changeVisibility(changed);
        }
    }
    /**
     * @hidden
     */
    get hasAutoSizeColumn() {
        return hasAutoSizeColumn(this.settings);
    }
    /**
     * @hidden
     */
    get hasAutoSizeAllColumns() {
        return hasAutoSizeAllColumns(this.settings);
    }
    /**
     * @hidden
     */
    get hasLock() {
        return hasLock(this.settings, this.column);
    }
    /**
     * @hidden
     */
    get hasStick() {
        return hasStick(this.settings, this.column);
    }
    /**
     * @hidden
     */
    get hasPosition() {
        return hasPosition(this.settings, this.column);
    }
    /**
     * @hidden
     */
    get columns() {
        return this.columnInfoService.leafNamedColumns;
    }
    ngAfterViewInit() {
        if (this.ctx.grid.virtualColumns && isDevMode()) {
            if (this.settings.autoSizeAllColumns) {
                this.settings.autoSizeAllColumns = false;
                console.warn(ColumnMenuErrorMessages.autoSizeAllColumns);
            }
            if (this.settings.autoSizeColumn) {
                this.settings.autoSizeColumn = false;
                console.warn(ColumnMenuErrorMessages.autoSizeColumn);
            }
        }
        this.service.menuTabbingService.isTabbedInterface = this.settings.view === 'tabbed' ? true : false;
    }
    ngOnChanges() {
        this.service.column = this.column;
        this.service.sort = this.sort;
        this.service.filter = this.filter;
        this.service.sortable = this.sortable;
    }
    ngOnDestroy() {
        this.close();
        this.closeSubscription.unsubscribe();
        this.popupSubs?.unsubscribe();
        this.closeSubscription = this.popupSubs = null;
    }
    /**
     * @hidden
     */
    toggle(e, anchor, template) {
        if (e) {
            e.preventDefault();
            e instanceof KeyboardEvent && e.stopImmediatePropagation();
        }
        this.expandedFilter = this.getExpandedState(this.settings.filter);
        this.expandedColumns = this.getExpandedState(this.settings.columnChooser);
        this.expandedPosition = this.getExpandedState(this.settings.setColumnPosition);
        this.popupRef = this.popupService.open(anchor, template, this.popupRef, POPUP_CLASSES);
        // Needed as changes to 'popupRef' and 'popupId' are not reflected
        // automatically when the Popup is closed by clicking outside the anchor
        const ariaRoot = this.isNavigable ? anchor.closest('.k-table-th') : anchor;
        if (this.popupRef) {
            this.popupSubs?.unsubscribe();
            this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
                this.popupSubs?.unsubscribe();
                this.popupSubs = null;
                this.close(true);
                this.updateAria(ariaRoot);
            });
            this.popupSubs.add(this.popupRef.popup.instance.close.subscribe(() => {
                this.popupSubs?.unsubscribe();
                this.popupSubs = this.popupRef = null;
                this.updateAria(ariaRoot);
            }));
            const popupAriaElement = this.popupRef.popupElement.querySelector('.k-grid-columnmenu-popup');
            if (popupAriaElement) {
                const popupId = getId(this.idService?.gridId());
                this.renderer.setAttribute(popupAriaElement, 'id', popupId);
                this.renderer.setAttribute(popupAriaElement, 'role', 'dialog');
                this.renderer.setAttribute(popupAriaElement, 'aria-label', this.columnMenuTitle);
                ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-controls', popupId);
                ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-expanded', 'true');
            }
            if (this.settings.view === 'tabbed') {
                this.renderer.addClass(popupAriaElement, 'k-column-menu-tabbed');
                this.renderer.addClass(popupAriaElement, 'k-column-menu');
                this.cdr.detectChanges();
                this.tabStrip?.selectTab(0);
            }
        }
        else {
            if (this.navigationService.tableEnabled) {
                this.navigationService.focusCell(0, this.column.leafIndex);
            }
            else {
                this.anchor.nativeElement.focus();
            }
        }
    }
    /**
     * @hidden
     */
    close(triggerFocus = false) {
        this.popupService.destroy();
        this.popupRef = null;
        this.cdr.markForCheck();
        if (!triggerFocus) {
            return;
        }
        if (this.navigationService.tableEnabled) {
            this.navigationService.focusCell(0, this.column.leafIndex);
        }
        else {
            this.anchor.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    get columnMenuTitle() {
        const localizationMsg = this.ctx.localization.get('columnMenu') || '';
        const columnName = this.column.title || this.column.field;
        return replaceMessagePlaceholder(localizationMsg, 'columnName', columnName);
    }
    getExpandedState(menuItemSettings) {
        return typeof (menuItemSettings) === 'object' ? menuItemSettings.expanded : false;
    }
    updateAria(ariaRoot) {
        ariaRoot && this.renderer.removeAttribute(ariaRoot, 'aria-controls');
        ariaRoot && this.renderer.setAttribute(ariaRoot, 'aria-expanded', 'false');
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuComponent, deps: [{ token: NavigationService }, { token: SinglePopupService }, { token: ColumnMenuService }, { token: ContextService }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: ColumnInfoService }, { token: IdService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ColumnMenuComponent, isStandalone: true, selector: "kendo-grid-column-menu", inputs: { standalone: "standalone", column: "column", settings: "settings", sort: "sort", filter: "filter", sortable: "sortable", columnMenuTemplate: "columnMenuTemplate", tabIndex: "tabIndex" }, host: { properties: { "class.k-grid-column-menu-standalone": "this.standalone" } }, providers: [
            ColumnMenuService,
            MenuTabbingService
        ], viewQueries: [{ propertyName: "anchor", first: true, predicate: ["anchor"], descendants: true, static: true }, { propertyName: "template", first: true, predicate: ["template"], descendants: true, read: TemplateRef, static: true }, { propertyName: "defaultTemplate", first: true, predicate: ["defaultTemplate"], descendants: true, read: TemplateRef, static: true }, { propertyName: "tabbedInterfaceTemplate", first: true, predicate: ["tabbedInterfaceTemplate"], descendants: true, read: TemplateRef, static: true }, { propertyName: "tabStrip", first: true, predicate: TabStripComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
        <a #anchor
            class="k-grid-header-menu k-grid-column-menu"
            [ngClass]="{ 'k-active': isActive }"
            (click)="toggle($event, anchor, template)"
            (keydown.enter)="$event.stopImmediatePropagation()"
            href="#"
            [tabindex]="tabIndex"
            [attr.title]="columnMenuTitle"
            [attr.aria-expanded]="isNavigable ? undefined: false"
            [attr.aria-haspopup]="isNavigable ? undefined : 'dialog'">
            <kendo-icon-wrapper
                name="more-vertical"
                [svgIcon]="moreVerticalIcon"></kendo-icon-wrapper>
        </a>
        <ng-template #template>
            <kendo-grid-columnmenu-container
                (keydown.escape)="close(true)"
                (keydown.enter)="$event.stopImmediatePropagation()">
                <ng-container
                    [ngTemplateOutlet]="this.column.columnMenuTemplateRef || this.columnMenuTemplate || (this.settings.view === 'tabbed' ? this.tabbedInterfaceTemplate : this.defaultTemplate)"
                    [ngTemplateOutletContext]="{ service: service, column: column }">
                </ng-container>
            </kendo-grid-columnmenu-container>
        </ng-template>
        <ng-template #defaultTemplate>
            <kendo-grid-columnmenu-container
                (keydown.escape)="close(true)"
                (keydown.enter)="$event.stopImmediatePropagation()">
                <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" *ngIf="hasSort" [service]="service">
                </kendo-grid-columnmenu-sort>
                <kendo-grid-columnmenu-lock #lockItem *ngIf="hasLock && !hasPosition" [kendoGridColumnMenuItem]="lockItem" [service]="service">
                </kendo-grid-columnmenu-lock>
                <kendo-grid-columnmenu-stick #stickItem *ngIf="hasStick && !hasPosition" [kendoGridColumnMenuItem]="stickItem" [service]="service">
                </kendo-grid-columnmenu-stick>
                <kendo-grid-columnmenu-position
                    #positionItem
                    *ngIf="hasPosition"
                    [showLock]="hasLock"
                    [showStick]="hasStick"
                    [kendoGridColumnMenuItem]="positionItem"
                    [service]="service"
                    [expanded]="expandedPosition">
                </kendo-grid-columnmenu-position>
                <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasColumnChooser || hasAutoSizeColumn || hasAutoSizeAllColumns" class="k-separator"></span>
                <kendo-grid-columnmenu-chooser
                    #chooserItem
                    *ngIf="hasColumnChooser"
                    [kendoGridColumnMenuItem]="chooserItem"
                    [service]="service"
                    [expanded]="expandedColumns">
                </kendo-grid-columnmenu-chooser>
                <kendo-grid-columnmenu-autosize-column
                    #autoSizeColumnItem
                    *ngIf="hasAutoSizeColumn"
                    [service]="service"
                    [kendoGridColumnMenuItem]="autoSizeColumnItem"
                    [column]="column"
                >
                </kendo-grid-columnmenu-autosize-column>

                <kendo-grid-columnmenu-autosize-all-columns
                    #autoSizeAllColumnsItem
                    *ngIf="hasAutoSizeAllColumns"
                    [service]="service"
                    [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                >
                </kendo-grid-columnmenu-autosize-all-columns>
                <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasColumnChooser || hasAutoSizeColumn || hasAutoSizeAllColumns" class="k-separator"></span>
                <kendo-grid-columnmenu-filter
                    #filterItem
                    *ngIf="hasFilter"
                    [kendoGridColumnMenuItem]="filterItem"
                    [service]="service"
                    [expanded]="expandedFilter">
                </kendo-grid-columnmenu-filter>
            </kendo-grid-columnmenu-container>
        </ng-template>
        <ng-template #tabbedInterfaceTemplate>
            <kendo-tabstrip #tabstrip
                (keydown.escape)="close(true)">
                <kendo-tabstrip-tab *ngIf="hasFilter">
                    <ng-template kendoTabTitle>
                        <kendo-icon-wrapper
                            [attr.title]="ctx.localization.get('columnMenuFilterTabTitle')"
                            name="filter"
                            [svgIcon]="filterIcon">
                        </kendo-icon-wrapper>
                    </ng-template>
                    <ng-template kendoTabContent>
                        <kendo-grid-filter-menu-container
                            [column]="service.column"
                            [menuTabbingService]="service.menuTabbingService"
                            [filter]="service.filter"
                            [actionsClass]="actionsClass"
                            (keydown.shift.tab)="$event.stopImmediatePropagation()"
                            (close)="close()">
                        </kendo-grid-filter-menu-container>
                    </ng-template>
                </kendo-tabstrip-tab>
                <kendo-tabstrip-tab *ngIf="showGeneralTab">
                    <ng-template kendoTabTitle>
                        <kendo-icon-wrapper
                            [attr.title]="ctx.localization.get('columnMenuGeneralTabTitle')"
                            name="sliders"
                            [svgIcon]="slidersIcon">
                        </kendo-icon-wrapper>
                    </ng-template>
                    <ng-template kendoTabContent>
                        <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" *ngIf="hasSort" [service]="service">
                        </kendo-grid-columnmenu-sort>
                        <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasSort && (hasLock || hasStick || hasPosition || hasAutoSizeColumn || hasAutoSizeAllColumns)" class="k-separator"></span>
                        <kendo-grid-columnmenu-lock #lockItem *ngIf="hasLock && !hasPosition" [kendoGridColumnMenuItem]="lockItem" [service]="service">
                        </kendo-grid-columnmenu-lock>
                        <kendo-grid-columnmenu-stick #stickItem *ngIf="hasStick && !hasPosition" [kendoGridColumnMenuItem]="stickItem" [service]="service">
                        </kendo-grid-columnmenu-stick>
                        <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="(hasLock || hasStick) && !hasPosition && (hasAutoSizeColumn || hasAutoSizeAllColumns)" class="k-separator"></span>
                        <kendo-grid-columnmenu-position
                            #positionItem
                            *ngIf="hasPosition"
                            [showLock]="hasLock"
                            [showStick]="hasStick"
                            [kendoGridColumnMenuItem]="positionItem"
                            [service]="service"
                            [expanded]="expandedPosition">
                        </kendo-grid-columnmenu-position>
                        <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasPosition && (hasAutoSizeColumn || hasAutoSizeAllColumns)" class="k-separator"></span>
                        <kendo-grid-columnmenu-autosize-column
                            #autoSizeColumnItem
                            *ngIf="hasAutoSizeColumn"
                            [service]="service"
                            [kendoGridColumnMenuItem]="autoSizeColumnItem"
                            [column]="column"
                        >
                        </kendo-grid-columnmenu-autosize-column>
                        <kendo-grid-columnmenu-autosize-all-columns
                            #autoSizeAllColumnsItem
                            *ngIf="hasAutoSizeAllColumns"
                            [service]="service"
                            [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                        >
                        </kendo-grid-columnmenu-autosize-all-columns>
                    </ng-template>
                </kendo-tabstrip-tab>
                <kendo-tabstrip-tab *ngIf="hasColumnChooser">
                    <ng-template kendoTabTitle>
                        <kendo-icon-wrapper
                            [attr.title]="ctx.localization.get('columnMenuColumnsTabTitle')"
                            name="columns"
                            [svgIcon]="columnsIcon">
                        </kendo-icon-wrapper>
                    </ng-template>
                    <ng-template kendoTabContent>
                        <kendo-grid-columnlist
                            [applyText]="ctx.localization.get('columnsApply')"
                            [resetText]="ctx.localization.get('columnsReset')"
                            [columns]="columns"
                            [autoSync]="false"
                            [allowHideAll]="false"
                            [actionsClass]="actionsClass"
                            [service]="service"
                            (apply)="onApply($event)">
                        </kendo-grid-columnlist>
                    </ng-template>
                </kendo-tabstrip-tab>
            </kendo-tabstrip>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "component", type: ColumnMenuContainerComponent, selector: "kendo-grid-columnmenu-container" }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: ColumnMenuSortComponent, selector: "kendo-grid-columnmenu-sort" }, { kind: "directive", type: ColumnMenuItemDirective, selector: "[kendoGridColumnMenuItem]", inputs: ["kendoGridColumnMenuItem"] }, { kind: "component", type: ColumnMenuLockComponent, selector: "kendo-grid-columnmenu-lock" }, { kind: "component", type: ColumnMenuStickComponent, selector: "kendo-grid-columnmenu-stick" }, { kind: "component", type: ColumnMenuPositionComponent, selector: "kendo-grid-columnmenu-position", inputs: ["expanded", "showLock", "showStick", "isLast"], outputs: ["expand", "collapse"] }, { kind: "component", type: ColumnMenuChooserComponent, selector: "kendo-grid-columnmenu-chooser", inputs: ["expanded", "isLast"], outputs: ["expand", "collapse"] }, { kind: "component", type: ColumnMenuAutoSizeColumnComponent, selector: "kendo-grid-columnmenu-autosize-column", inputs: ["column"] }, { kind: "component", type: ColumnMenuAutoSizeAllColumnsComponent, selector: "kendo-grid-columnmenu-autosize-all-columns" }, { kind: "component", type: ColumnMenuFilterComponent, selector: "kendo-grid-columnmenu-filter", inputs: ["expanded", "isLast"], outputs: ["expand", "collapse"] }, { kind: "component", type: TabStripComponent, selector: "kendo-tabstrip", inputs: ["height", "animate", "tabAlignment", "tabPosition", "keepTabContent", "closable", "scrollable", "closeIcon", "closeIconClass", "closeSVGIcon", "showContentArea"], outputs: ["tabSelect", "tabClose", "tabScroll"], exportAs: ["kendoTabStrip"] }, { kind: "component", type: TabStripTabComponent, selector: "kendo-tabstrip-tab", inputs: ["title", "disabled", "cssClass", "cssStyle", "selected", "closable", "closeIcon", "closeIconClass", "closeSVGIcon"], exportAs: ["kendoTabStripTab"] }, { kind: "directive", type: TabTitleDirective, selector: "[kendoTabTitle]" }, { kind: "directive", type: TabContentDirective, selector: "[kendoTabContent]" }, { kind: "component", type: FilterMenuContainerComponent, selector: "kendo-grid-filter-menu-container", inputs: ["column", "isLast", "isExpanded", "menuTabbingService", "filter", "actionsClass"], outputs: ["close"] }, { kind: "component", type: ColumnListComponent, selector: "kendo-grid-columnlist", inputs: ["columns", "autoSync", "ariaLabel", "allowHideAll", "applyText", "resetText", "actionsClass", "isLast", "isExpanded", "service"], outputs: ["reset", "apply", "columnChange"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnMenuComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        ColumnMenuService,
                        MenuTabbingService
                    ],
                    selector: 'kendo-grid-column-menu',
                    template: `
        <a #anchor
            class="k-grid-header-menu k-grid-column-menu"
            [ngClass]="{ 'k-active': isActive }"
            (click)="toggle($event, anchor, template)"
            (keydown.enter)="$event.stopImmediatePropagation()"
            href="#"
            [tabindex]="tabIndex"
            [attr.title]="columnMenuTitle"
            [attr.aria-expanded]="isNavigable ? undefined: false"
            [attr.aria-haspopup]="isNavigable ? undefined : 'dialog'">
            <kendo-icon-wrapper
                name="more-vertical"
                [svgIcon]="moreVerticalIcon"></kendo-icon-wrapper>
        </a>
        <ng-template #template>
            <kendo-grid-columnmenu-container
                (keydown.escape)="close(true)"
                (keydown.enter)="$event.stopImmediatePropagation()">
                <ng-container
                    [ngTemplateOutlet]="this.column.columnMenuTemplateRef || this.columnMenuTemplate || (this.settings.view === 'tabbed' ? this.tabbedInterfaceTemplate : this.defaultTemplate)"
                    [ngTemplateOutletContext]="{ service: service, column: column }">
                </ng-container>
            </kendo-grid-columnmenu-container>
        </ng-template>
        <ng-template #defaultTemplate>
            <kendo-grid-columnmenu-container
                (keydown.escape)="close(true)"
                (keydown.enter)="$event.stopImmediatePropagation()">
                <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" *ngIf="hasSort" [service]="service">
                </kendo-grid-columnmenu-sort>
                <kendo-grid-columnmenu-lock #lockItem *ngIf="hasLock && !hasPosition" [kendoGridColumnMenuItem]="lockItem" [service]="service">
                </kendo-grid-columnmenu-lock>
                <kendo-grid-columnmenu-stick #stickItem *ngIf="hasStick && !hasPosition" [kendoGridColumnMenuItem]="stickItem" [service]="service">
                </kendo-grid-columnmenu-stick>
                <kendo-grid-columnmenu-position
                    #positionItem
                    *ngIf="hasPosition"
                    [showLock]="hasLock"
                    [showStick]="hasStick"
                    [kendoGridColumnMenuItem]="positionItem"
                    [service]="service"
                    [expanded]="expandedPosition">
                </kendo-grid-columnmenu-position>
                <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasColumnChooser || hasAutoSizeColumn || hasAutoSizeAllColumns" class="k-separator"></span>
                <kendo-grid-columnmenu-chooser
                    #chooserItem
                    *ngIf="hasColumnChooser"
                    [kendoGridColumnMenuItem]="chooserItem"
                    [service]="service"
                    [expanded]="expandedColumns">
                </kendo-grid-columnmenu-chooser>
                <kendo-grid-columnmenu-autosize-column
                    #autoSizeColumnItem
                    *ngIf="hasAutoSizeColumn"
                    [service]="service"
                    [kendoGridColumnMenuItem]="autoSizeColumnItem"
                    [column]="column"
                >
                </kendo-grid-columnmenu-autosize-column>

                <kendo-grid-columnmenu-autosize-all-columns
                    #autoSizeAllColumnsItem
                    *ngIf="hasAutoSizeAllColumns"
                    [service]="service"
                    [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                >
                </kendo-grid-columnmenu-autosize-all-columns>
                <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasColumnChooser || hasAutoSizeColumn || hasAutoSizeAllColumns" class="k-separator"></span>
                <kendo-grid-columnmenu-filter
                    #filterItem
                    *ngIf="hasFilter"
                    [kendoGridColumnMenuItem]="filterItem"
                    [service]="service"
                    [expanded]="expandedFilter">
                </kendo-grid-columnmenu-filter>
            </kendo-grid-columnmenu-container>
        </ng-template>
        <ng-template #tabbedInterfaceTemplate>
            <kendo-tabstrip #tabstrip
                (keydown.escape)="close(true)">
                <kendo-tabstrip-tab *ngIf="hasFilter">
                    <ng-template kendoTabTitle>
                        <kendo-icon-wrapper
                            [attr.title]="ctx.localization.get('columnMenuFilterTabTitle')"
                            name="filter"
                            [svgIcon]="filterIcon">
                        </kendo-icon-wrapper>
                    </ng-template>
                    <ng-template kendoTabContent>
                        <kendo-grid-filter-menu-container
                            [column]="service.column"
                            [menuTabbingService]="service.menuTabbingService"
                            [filter]="service.filter"
                            [actionsClass]="actionsClass"
                            (keydown.shift.tab)="$event.stopImmediatePropagation()"
                            (close)="close()">
                        </kendo-grid-filter-menu-container>
                    </ng-template>
                </kendo-tabstrip-tab>
                <kendo-tabstrip-tab *ngIf="showGeneralTab">
                    <ng-template kendoTabTitle>
                        <kendo-icon-wrapper
                            [attr.title]="ctx.localization.get('columnMenuGeneralTabTitle')"
                            name="sliders"
                            [svgIcon]="slidersIcon">
                        </kendo-icon-wrapper>
                    </ng-template>
                    <ng-template kendoTabContent>
                        <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" *ngIf="hasSort" [service]="service">
                        </kendo-grid-columnmenu-sort>
                        <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasSort && (hasLock || hasStick || hasPosition || hasAutoSizeColumn || hasAutoSizeAllColumns)" class="k-separator"></span>
                        <kendo-grid-columnmenu-lock #lockItem *ngIf="hasLock && !hasPosition" [kendoGridColumnMenuItem]="lockItem" [service]="service">
                        </kendo-grid-columnmenu-lock>
                        <kendo-grid-columnmenu-stick #stickItem *ngIf="hasStick && !hasPosition" [kendoGridColumnMenuItem]="stickItem" [service]="service">
                        </kendo-grid-columnmenu-stick>
                        <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="(hasLock || hasStick) && !hasPosition && (hasAutoSizeColumn || hasAutoSizeAllColumns)" class="k-separator"></span>
                        <kendo-grid-columnmenu-position
                            #positionItem
                            *ngIf="hasPosition"
                            [showLock]="hasLock"
                            [showStick]="hasStick"
                            [kendoGridColumnMenuItem]="positionItem"
                            [service]="service"
                            [expanded]="expandedPosition">
                        </kendo-grid-columnmenu-position>
                        <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasPosition && (hasAutoSizeColumn || hasAutoSizeAllColumns)" class="k-separator"></span>
                        <kendo-grid-columnmenu-autosize-column
                            #autoSizeColumnItem
                            *ngIf="hasAutoSizeColumn"
                            [service]="service"
                            [kendoGridColumnMenuItem]="autoSizeColumnItem"
                            [column]="column"
                        >
                        </kendo-grid-columnmenu-autosize-column>
                        <kendo-grid-columnmenu-autosize-all-columns
                            #autoSizeAllColumnsItem
                            *ngIf="hasAutoSizeAllColumns"
                            [service]="service"
                            [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                        >
                        </kendo-grid-columnmenu-autosize-all-columns>
                    </ng-template>
                </kendo-tabstrip-tab>
                <kendo-tabstrip-tab *ngIf="hasColumnChooser">
                    <ng-template kendoTabTitle>
                        <kendo-icon-wrapper
                            [attr.title]="ctx.localization.get('columnMenuColumnsTabTitle')"
                            name="columns"
                            [svgIcon]="columnsIcon">
                        </kendo-icon-wrapper>
                    </ng-template>
                    <ng-template kendoTabContent>
                        <kendo-grid-columnlist
                            [applyText]="ctx.localization.get('columnsApply')"
                            [resetText]="ctx.localization.get('columnsReset')"
                            [columns]="columns"
                            [autoSync]="false"
                            [allowHideAll]="false"
                            [actionsClass]="actionsClass"
                            [service]="service"
                            (apply)="onApply($event)">
                        </kendo-grid-columnlist>
                    </ng-template>
                </kendo-tabstrip-tab>
            </kendo-tabstrip>
        </ng-template>
    `,
                    standalone: true,
                    imports: [
                        NgClass, IconWrapperComponent, ColumnMenuContainerComponent, NgTemplateOutlet, NgIf,
                        ColumnMenuSortComponent, ColumnMenuItemDirective, ColumnMenuLockComponent, ColumnMenuStickComponent,
                        ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuAutoSizeColumnComponent,
                        ColumnMenuAutoSizeAllColumnsComponent, ColumnMenuFilterComponent, TabStripComponent,
                        TabStripTabComponent, TabTitleDirective, TabContentDirective, FilterMenuContainerComponent, ColumnListComponent
                    ]
                }]
        }], ctorParameters: function () { return [{ type: NavigationService }, { type: SinglePopupService }, { type: ColumnMenuService }, { type: ContextService }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: ColumnInfoService }, { type: IdService, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { standalone: [{
                type: HostBinding,
                args: ['class.k-grid-column-menu-standalone']
            }, {
                type: Input
            }], column: [{
                type: Input
            }], settings: [{
                type: Input
            }], sort: [{
                type: Input
            }], filter: [{
                type: Input
            }], sortable: [{
                type: Input
            }], columnMenuTemplate: [{
                type: Input
            }], tabIndex: [{
                type: Input
            }], anchor: [{
                type: ViewChild,
                args: ['anchor', { static: true }]
            }], template: [{
                type: ViewChild,
                args: ['template', { static: true, read: TemplateRef }]
            }], defaultTemplate: [{
                type: ViewChild,
                args: ['defaultTemplate', { static: true, read: TemplateRef }]
            }], tabbedInterfaceTemplate: [{
                type: ViewChild,
                args: ['tabbedInterfaceTemplate', { static: true, read: TemplateRef }]
            }], tabStrip: [{
                type: ViewChild,
                args: [TabStripComponent]
            }] } });

/**
 * @hidden
 */
class ExcelService {
    saveToExcel = new EventEmitter();
    exportClick = new EventEmitter();
    save(component) {
        if (this.saveToExcel.observers.length === 0) {
            if (isDevMode()) {
                throw new Error(GridConfigurationErrorMessages.requiredModule('excel', 'ExcelModule', '<kendo-grid-excel>'));
            }
        }
        else {
            this.saveToExcel.emit(component);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExcelService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExcelService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExcelService, decorators: [{
            type: Injectable
        }] });

/**
 * Arguments for the `excelExport` event.
 */
class ExcelExportEvent extends PreventableEvent {
    workbook;
    constructor(workbook) {
        super();
        this.workbook = workbook;
    }
}

const fetchComponentData = (component) => {
    return {
        data: component.view.map(item => item),
        group: component.group
    };
};
const toExcelColumn = (column) => {
    return {
        title: column.title,
        field: column.field,
        locked: Boolean(column.locked),
        width: column.width,
        level: column.level,
        hidden: !column.isVisible,
        groupHeaderTemplate: column.groupHeaderTemplate,
        groupHeaderColumnTemplate: column.groupHeaderColumnTemplate,
        groupFooterTemplate: column.groupFooterTemplate,
        footerTemplate: column.footerTemplate
    };
};
const toExcelColumns = (columns) => {
    const result = [];
    sortColumns(columns)
        .forEach((column) => {
        if (column.isSpanColumn) {
            result.push(...toExcelColumns(column.childrenArray));
        }
        else {
            const excelColumn = toExcelColumn(column);
            if (column.isColumnGroup) {
                excelColumn.children = [excelColumn].concat(toExcelColumns(column.childrenArray));
            }
            result.push(excelColumn);
        }
    });
    return result;
};
const componentColumns = (component) => {
    const columns = toExcelColumns(component.columns.toArray());
    return orderBy(columns, [{ field: 'locked', dir: 'desc' }]);
};
/**
 * Configures the settings for the export of Grid in Excel ([see example]({% slug excelexport_grid %})).
 */
class ExcelComponent {
    ctx;
    zone;
    /**
     * Specifies the file name of the exported Excel file.
     * @default "Export.xlsx"
     */
    fileName = 'Export.xlsx';
    /**
     * Enables or disables column filtering in the Excel file. This behavior is different from the filtering feature of the Grid.
     */
    filterable;
    /**
     * The author of the workbook.
     */
    creator;
    /**
     * The date on which the workbook was created. Defaults to `new Date()`.
     */
    date;
    /**
     * If set to `true`, the content is forwarded to [proxyURL](#toc-proxyurl) even if the browser supports the saving of files locally.
     */
    forceProxy;
    /**
     * The URL of the server-side proxy which streams the file to the end user.
     *
     * Using a proxy is required if the browser is not capable of saving files locally.
     *
     * Optionally, set up a proxy to reduce memory usage. This avoids copying the file contents in memory,
     * but transmits it over the network instead. For this use case, set [forceProxy](#toc-forceproxy) to `true`
     * to skip client-side saving even in browser that support it.
     *
     * In the request body, the proxy receives a POST request with the specific parameters. [See example](slug:server_proxy#toc-implementations).
     * The proxy returns the decoded file with the `"Content-Disposition"` header set to `attachment; filename="<fileName.xslx>"`.
     *
     * For details on the server-side proxy usage and implementation, see the [File Saver]({% slug overview_filesaver %}) documentation.
     */
    proxyURL;
    /**
     * The function that is used to get the exported data options. By default, uses the current data and group of the Grid.
     * To export data that is different from the current Grid data, provide a custom function.
     */
    fetchData;
    /**
     * If the data is grouped, the options of the cells that are inserted before the data,
     * group, and footer cells to indicate the group hierarchy.
     */
    paddingCellOptions;
    /**
     * If the data is grouped, the options of the cells that are inserted before the
     * header cells to align the headers and the column values.
     */
    headerPaddingCellOptions;
    /**
     * Specifies if the groups in the Excel file are collapsible.
     */
    collapsible;
    /**
     * @hidden
     */
    columns = new QueryList();
    saveSubscription;
    dataSubscription;
    constructor(excelService, ctx, zone) {
        this.ctx = ctx;
        this.zone = zone;
        this.saveSubscription = excelService.saveToExcel.subscribe(this.save.bind(this));
    }
    ngOnDestroy() {
        this.saveSubscription.unsubscribe();
        if (this.dataSubscription) {
            this.dataSubscription.unsubscribe();
        }
    }
    save(component) {
        const data = (this.fetchData || fetchComponentData)(component);
        const exportData = (result) => {
            delete this.dataSubscription;
            this.exportData(component, result);
        };
        if (data instanceof Promise) {
            data.then(exportData);
        }
        else if (data instanceof Observable) {
            this.dataSubscription = data.pipe(take(1)).subscribe(exportData);
        }
        else {
            exportData(data);
        }
    }
    exportData(component, result) {
        const options = workbookOptions({
            columns: this.columns.length ? this.columns : componentColumns(component),
            data: result.data,
            group: result.group,
            filterable: this.filterable,
            creator: this.creator,
            date: this.date,
            paddingCellOptions: this.paddingCellOptions,
            headerPaddingCellOptions: this.headerPaddingCellOptions,
            rtl: this.ctx.localization.rtl,
            collapsible: this.collapsible
        });
        const args = new ExcelExportEvent(options);
        component.excelExport.emit(args);
        if (!args.isDefaultPrevented()) {
            this.zone.runOutsideAngular(() => this.saveFile(options));
        }
    }
    saveFile(options) {
        toDataURL(options).then((dataURL) => {
            saveAs(dataURL, this.fileName, {
                forceProxy: this.forceProxy,
                proxyURL: this.proxyURL
            });
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExcelComponent, deps: [{ token: ExcelService }, { token: ContextService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ExcelComponent, isStandalone: true, selector: "kendo-grid-excel", inputs: { fileName: "fileName", filterable: "filterable", creator: "creator", date: "date", forceProxy: "forceProxy", proxyURL: "proxyURL", fetchData: "fetchData", paddingCellOptions: "paddingCellOptions", headerPaddingCellOptions: "headerPaddingCellOptions", collapsible: "collapsible" }, queries: [{ propertyName: "columns", predicate: ColumnBase$1, descendants: true }], ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExcelComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-excel',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ExcelService }, { type: ContextService }, { type: i0.NgZone }]; }, propDecorators: { fileName: [{
                type: Input
            }], filterable: [{
                type: Input
            }], creator: [{
                type: Input
            }], date: [{
                type: Input
            }], forceProxy: [{
                type: Input
            }], proxyURL: [{
                type: Input
            }], fetchData: [{
                type: Input
            }], paddingCellOptions: [{
                type: Input
            }], headerPaddingCellOptions: [{
                type: Input
            }], collapsible: [{
                type: Input
            }], columns: [{
                type: ContentChildren,
                args: [ColumnBase$1, { descendants: true }]
            }] } });

/**
 * Represents the `export-to-Excel` command of the Grid. You can apply this
 * directive to any `button` element inside a
 * [ToolbarTemplate]({% slug api_grid_toolbartemplatedirective %}).
 * When the user clicks a button associated with the directive, the
 * [excelExport]({% slug api_grid_gridcomponent %}#toc-excelexport) event
 * fires ([see example]({% slug excelexport_grid %})).
 *
 * @example
 * ```html
 * <kendo-grid>
 *      <ng-template kendoGridToolbarTemplate>
 *          <button kendoGridExcelCommand>Export to Excel</button>
 *      </ng-template>
 *      <kendo-grid-excel fileName="Grid.xlsx">
 *      </kendo-grid-excel>
 * </kendo-grid>
 * ```
 */
class ExcelCommandDirective extends Button {
    excelService;
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.excelService.exportClick.emit();
    }
    /**
     * @hidden
     */
    get excelClass() {
        return true;
    }
    constructor(excelService, element, renderer, ctx, ngZone) {
        super(element, renderer, null, ctx.localization, ngZone);
        this.excelService = excelService;
        this.ngZone = ngZone;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExcelCommandDirective, deps: [{ token: ExcelService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ContextService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ExcelCommandDirective, isStandalone: true, selector: "[kendoGridExcelCommand]", host: { listeners: { "click": "onClick($event)" }, properties: { "class.k-grid-excel": "this.excelClass" } }, usesInheritance: true, ngImport: i0, template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExcelCommandDirective, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridExcelCommand]',
                    template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
                    standalone: true,
                    imports: [NgIf, IconWrapperComponent, NgClass]
                }]
        }], ctorParameters: function () { return [{ type: ExcelService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ContextService }, { type: i0.NgZone }]; }, propDecorators: { onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }], excelClass: [{
                type: HostBinding,
                args: ['class.k-grid-excel']
            }] } });

/**
 * @hidden
 */
class SuspendService {
    scroll = false;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SuspendService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SuspendService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SuspendService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
class PDFService {
    savePDF = new EventEmitter();
    drawPDF = new EventEmitter();
    exportClick = new EventEmitter();
    dataChanged = new EventEmitter();
    exporting;
    save(component) {
        this.emitEvent(this.savePDF, component);
    }
    draw(component, promise) {
        this.emitEvent(this.drawPDF, { component, promise });
    }
    /**
     * @hidden
     */
    emitEvent(emitter, args) {
        if (emitter.observers.length === 0) {
            if (isDevMode()) {
                throw new Error(GridConfigurationErrorMessages.requiredModule('PDF', 'PDFModule', '<kendo-grid-pdf>'));
            }
        }
        else {
            emitter.emit(args);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PDFService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PDFService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PDFService, decorators: [{
            type: Injectable
        }] });

/**
 * Represents the Kendo UI PDFMargin component for Angular.
 * The supported units are:
 * `"mm"`
 * `"cm"`
 * `"in"`
 * `"pt"` (default).
 * Numbers are considered to be points (`"pt"`).
 */
class PDFMarginComponent extends PDFExportMarginComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PDFMarginComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: PDFMarginComponent, isStandalone: true, selector: "kendo-grid-pdf-margin", usesInheritance: true, ngImport: i0, template: '', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PDFMarginComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-pdf-margin',
                    template: '',
                    standalone: true
                }]
        }] });

/**
 * Represents the PDF page template of the Grid that helps to customize the PDF pages. To define a page template,
 * nest an `<ng-template>` tag with the `kendoGridPDFTemplate` directive inside `<kendo-grid-pdf>` tag.
 *
 * The template context provides the following fields:
 * - `pageNumber`&mdash;Defines PDF page number.
 * - `totalPages`&mdash;Defines the total number of PDF pages.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData">
 *   ...
 *   <kendo-grid-pdf fileName="Products.pdf" paperSize="A4">
 *     <ng-template kendoGridPDFTemplate let-pageNumber="pageNumber" let-totalPages="totalPages">
 *         Page {{ pageNumber }} of {{ totalPages }}
 *     </ng-template>
 *   </kendo-grid-pdf>
 * </kendo-grid>
 * ```
 */
class PDFTemplateDirective extends PDFExportTemplateDirective {
    constructor(templateRef) {
        super(templateRef);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PDFTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: PDFTemplateDirective, isStandalone: true, selector: "[kendoGridPDFTemplate]", usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PDFTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridPDFTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * @hidden
 */
const HEADER_CLASS = 'k-grid-header';
/**
 * @hidden
 */
const FOOTER_CLASS = 'k-grid-footer';
const GRID_LIST = 'KENDO-GRID-LIST';
const TABLE = 'TABLE';
const matchesList = matchesNodeName(GRID_LIST);
const matchesTable = matchesNodeName(TABLE);
const suffix = (locked) => locked ? 'locked' : 'wrap';
/**
 * @hidden
 */
class GridQuery {
    element;
    headerWrap;
    list;
    footerWrap;
    constructor(element) {
        this.element = element;
        this.list = findElement(element, matchesList);
    }
    content(locked) {
        return findElement(this.list, matchesClasses(`k-grid-content${locked ? '-locked' : ''}`));
    }
    header(locked) {
        this.headerWrap = this.headerWrap || findElement(this.element, matchesClasses(HEADER_CLASS));
        return findElement(this.headerWrap, matchesClasses(`${HEADER_CLASS}-${suffix(locked)}`));
    }
    footer(locked) {
        this.footerWrap = this.footerWrap || findElement(this.element, matchesClasses(FOOTER_CLASS));
        return findElement(this.footerWrap, matchesClasses(`${FOOTER_CLASS}-${suffix(locked)}`));
    }
    table() {
        return findElement(this.element, matchesTable);
    }
}

const FIRST_CLASS = 'k-first';
const INPUTS = ['input', 'select', 'textarea', 'option'];
/** @hidden */
const cloneNode = (node) => {
    const clone = node.cloneNode(false);
    if (node._kendoExportVisual) {
        clone._kendoExportVisual = node._kendoExportVisual;
    }
    if (INPUTS.indexOf(String(node.nodeName).toLowerCase()) >= 0) {
        clone.removeAttribute("id");
        clone.removeAttribute("name");
        clone.value = node.value;
        clone.checked = node.checked;
        clone.selected = node.selected;
    }
    let child = node.firstChild;
    while (child) {
        clone.appendChild(cloneNode(child));
        child = child.nextSibling;
    }
    return clone;
};
const appendNodes = (element, nodes) => {
    const length = nodes.length;
    for (let idx = 0; idx < length; idx++) {
        element.appendChild(cloneNode(nodes[idx]));
    }
};
const wrapTable = (table, size) => {
    if (!isDocumentAvailable()) {
        return;
    }
    const wrapper = document.createElement('div');
    const classes = ['k-grid'];
    if (size && size !== 'none') {
        classes.push(`k-grid-${size === 'medium' ? 'md' : 'sm'}`);
    }
    wrapper.classList.add(...classes);
    wrapper.appendChild(table);
    return wrapper;
};
const createTableElement = (sources) => {
    const sourceCount = sources.length;
    const element = cloneNode(sources[0]);
    const rowsCount = element.rows.length;
    if (sourceCount > 1) {
        for (let rowIdx = 0; rowIdx < rowsCount; rowIdx++) {
            for (let sourceIdx = 1; sourceIdx < sourceCount; sourceIdx++) {
                appendNodes(element.rows[rowIdx], sources[sourceIdx].rows[rowIdx].cells);
            }
        }
    }
    return element;
};
const setFirstCellClass = (header, headers) => {
    if (headers.length > 1 && header.rows.length > 1) {
        for (let idx = 1; idx < header.rows.length; idx++) {
            const firstCellIndex = headers[0].rows[idx].cells.length;
            const cell = header.rows[idx].cells[firstCellIndex];
            if (String(cell.className).indexOf(FIRST_CLASS) === -1) {
                cell.className += ` ${FIRST_CLASS}`;
            }
        }
    }
};
const createTable = (colGroups, headers, bodies, footers, size) => {
    const table = document.createElement('table');
    const classes = ['k-table'];
    if (size && size !== 'none') {
        classes.push(`k-table-${size === 'medium' ? 'md' : 'sm'}`);
    }
    table.classList.add(...classes);
    const colGroup = colGroups[0].cloneNode(true);
    for (let idx = 1; idx < colGroups.length; idx++) {
        appendNodes(colGroup, colGroups[idx].querySelectorAll('col'));
    }
    const header = createTableElement(headers);
    const body = createTableElement(bodies);
    setFirstCellClass(header, headers);
    table.appendChild(colGroup);
    table.appendChild(header);
    table.appendChild(body);
    if (footers.length) {
        const footer = createTableElement(footers);
        table.appendChild(footer);
    }
    return wrapTable(table, size);
};
/**
 * @hidden
 */
const exportElement = (wrapper, size) => {
    const query = new GridQuery(wrapper);
    const content = query.content();
    let result;
    if (content) {
        const colGroups = [content.querySelector('colgroup')];
        const headers = [query.header().querySelector('thead')];
        const bodies = [content.querySelector('tbody')];
        const footer = query.footer();
        const footers = [];
        if (footer) {
            footers.push(footer.querySelector('tfoot'));
        }
        const lockedContent = query.content(true);
        if (lockedContent) {
            colGroups.unshift(lockedContent.querySelector('colgroup'));
            headers.unshift(query.header(true).querySelector('thead'));
            bodies.unshift(lockedContent.querySelector('tbody'));
            if (footer) {
                footers.unshift(query.footer(true).querySelector('tfoot'));
            }
        }
        result = createTable(colGroups, headers, bodies, footers, size);
    }
    else {
        result = wrapTable(query.table().cloneNode(true), size);
    }
    return result;
};

const createElement$1 = (tagName, className) => {
    const element = document.createElement(tagName);
    if (className) {
        element.className = className;
    }
    return element;
};
const createDiv = (className) => {
    return createElement$1('div', className);
};
/**
 * Configures the settings for the export of Grid in PDF ([see example]({% slug pdfexport_grid %})).
 */
class PDFComponent extends PDFExportComponent {
    pdfService;
    suspendService;
    ngZone;
    ctx;
    /**
     * Exports all Grid pages, starting from the first one.
     */
    allPages;
    /**
     * The delay in milliseconds before exporting the Grid content.
     * Useful for scenarios which involve exporting complex components used in the Grid
     * templates such as charts or data-bound components with asynchronous data retrieval ([see example]({% slug pdfexport_grid %}#toc-exporting-all-pages)).
     *
     * @default 0
     */
    delay = 0;
    columns = new QueryList();
    /**
     * @hidden
     */
    marginComponent;
    /**
     * @hidden
     */
    pageTemplateDirective;
    progress;
    component;
    container;
    skip;
    pageSize;
    originalHeight;
    originalOverflow;
    saveSubscription;
    drawSubscription;
    renderAllPages;
    originalColumns;
    constructor(pdfService, suspendService, ngZone, element, ctx) {
        super(element);
        this.pdfService = pdfService;
        this.suspendService = suspendService;
        this.ngZone = ngZone;
        this.ctx = ctx;
        this.saveSubscription = pdfService.savePDF.subscribe(this.savePDF.bind(this));
        this.drawSubscription = pdfService.drawPDF.subscribe(this.drawPDF.bind(this));
        this.reset = this.reset.bind(this);
        this.draw = this.draw.bind(this);
    }
    ngOnDestroy() {
        this.saveSubscription.unsubscribe();
        this.drawSubscription.unsubscribe();
        this.reset();
    }
    /**
     * @hidden
     */
    saveAs(_) {
        throw new Error(GridConfigurationErrorMessages.unsupportedMethod('saveAs', 'GridComponent.saveAsPDF'));
    }
    /**
     * @hidden
     */
    export() {
        throw new Error(GridConfigurationErrorMessages.unsupportedMethod('export', 'GridComponent.drawPDF'));
    }
    savePDF(component) {
        this.createPDF(component, this.draw);
    }
    drawPDF({ component, promise }) {
        this.createPDF(component, () => {
            this.createExportGroup(promise);
        });
    }
    createPDF(component, callback) {
        const pageSize = component.pageSize;
        const total = component.view.total;
        const columns = this.columns.toArray();
        if (columns.length) {
            this.originalColumns = component.columns.toArray();
        }
        this.component = component;
        this.suspendService.scroll = true;
        this.pdfService.exporting = true;
        this.initProgress();
        this.renderAllPages = this.allPages && pageSize < total;
        if (this.renderAllPages) {
            this.skip = component.skip;
            this.pageSize = pageSize;
            this.changePage(0, total, callback, columns);
        }
        else if (columns.length || component.virtualColumns) {
            this.changeColumns(columns, callback);
        }
        else {
            callback();
        }
    }
    initProgress() {
        if (!isDocumentAvailable()) {
            return;
        }
        const wrapperElement = this.component.wrapper.nativeElement;
        const progress = this.progress = createDiv('k-loading-pdf-mask');
        const overlay = cloneNode(wrapperElement);
        progress.appendChild(overlay);
        progress.appendChild(createDiv('k-loading-color'));
        progress.appendChild(createElement$1('span', 'k-i-loading k-icon'));
        this.originalHeight = wrapperElement.style.height;
        this.originalOverflow = wrapperElement.style.overflow;
        wrapperElement.style.height = wrapperElement.offsetHeight + 'px';
        wrapperElement.style.overflow = 'hidden';
        wrapperElement.appendChild(progress);
        this.applyScroll(overlay);
    }
    applyScroll(overlay) {
        const query = new GridQuery(this.component.wrapper.nativeElement);
        const content = query.content();
        if (content) {
            const overlayQuery = new GridQuery(overlay);
            const overlayContent = overlayQuery.content();
            overlayContent.scrollTop = content.scrollTop;
            overlayContent.scrollLeft = content.scrollLeft;
            overlayQuery.header().scrollLeft = query.header().scrollLeft;
            const footer = query.footer();
            if (footer) {
                overlayQuery.footer().scrollLeft = footer.scrollLeft;
            }
            const lockedContent = query.content(true);
            if (lockedContent) {
                const overlayLockedContent = overlayQuery.content(true);
                overlayLockedContent.scrollTop = lockedContent.scrollTop;
                overlayLockedContent.scrollLeft = lockedContent.scrollLeft;
            }
        }
    }
    draw() {
        this.createExportElement((element) => {
            this.save(element, this.fileName);
        });
    }
    createExportGroup(promise) {
        this.createExportElement((element) => {
            this.exportElement(element).then(group => promise.resolve(group));
        });
    }
    createExportElement(callback) {
        this.ngZone.runOutsideAngular(() => {
            const container = this.container = createDiv('k-grid-pdf-export-element');
            const element = exportElement(this.component.wrapper.nativeElement, this.ctx?.grid.size || 'medium');
            container.appendChild(element);
            document.body.appendChild(container);
            callback(element);
        });
    }
    drawOptions() {
        const options = super.drawOptions();
        options._destructive = true;
        return options;
    }
    cleanup() {
        super.cleanup();
        this.pdfService.exporting = false;
        if (this.component) {
            const originalColumns = this.originalColumns;
            delete this.originalColumns;
            if (this.renderAllPages) {
                this.changePage(this.skip, this.pageSize, this.reset, originalColumns);
            }
            else if (originalColumns || this.component.virtualColumns) {
                this.changeColumns(originalColumns, this.reset);
            }
            else {
                this.reset();
            }
        }
        else {
            this.reset();
        }
        this.removeContainer();
    }
    removeContainer() {
        if (this.container) {
            document.body.removeChild(this.container);
            delete this.container;
        }
    }
    changePage(skip, _take, callback, columns) {
        this.ngZone.run(() => {
            this.pdfService.dataChanged.pipe(take(1)).subscribe(() => {
                if ((columns && columns.length) || this.component.virtualColumns) {
                    this.changeColumns(columns, callback);
                }
                else {
                    this.onStable(callback);
                }
            });
            this.component.notifyPageChange('pdf', { skip: skip, take: _take });
        });
    }
    changeColumns(columns, callback) {
        this.ngZone.run(() => {
            this.onStable(callback);
            if (columns && columns.length) {
                this.component.columns.reset(columns);
            }
        });
    }
    reset() {
        this.suspendService.scroll = false;
        this.renderAllPages = false;
        if (!this.component) {
            return;
        }
        const wrapperElement = this.component.wrapper.nativeElement;
        wrapperElement.removeChild(this.progress);
        wrapperElement.style.height = this.originalHeight;
        wrapperElement.style.overflow = this.originalOverflow;
        delete this.progress;
        delete this.component;
    }
    onStable(callback) {
        // not sure if it is an actual scenario. occurs in the tests.
        // onStable is triggered in the same pass without the change detection.
        // thus, the callback is called before the changes are applied without the timeout.
        setTimeout(() => {
            let onStable = this.ngZone.onStable.asObservable().pipe(take(1));
            if (this.delay > 0) {
                onStable = onStable.pipe(delay(this.delay));
            }
            onStable.subscribe(callback);
        }, 0);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PDFComponent, deps: [{ token: PDFService }, { token: SuspendService }, { token: i0.NgZone }, { token: i0.ElementRef }, { token: ContextService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: PDFComponent, isStandalone: true, selector: "kendo-grid-pdf", inputs: { allPages: "allPages", delay: "delay" }, queries: [{ propertyName: "marginComponent", first: true, predicate: PDFMarginComponent, descendants: true }, { propertyName: "pageTemplateDirective", first: true, predicate: PDFTemplateDirective, descendants: true }, { propertyName: "columns", predicate: ColumnBase }], usesInheritance: true, ngImport: i0, template: '', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PDFComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-pdf',
                    template: '',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: PDFService }, { type: SuspendService }, { type: i0.NgZone }, { type: i0.ElementRef }, { type: ContextService, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { allPages: [{
                type: Input
            }], delay: [{
                type: Input
            }], columns: [{
                type: ContentChildren,
                args: [ColumnBase]
            }], marginComponent: [{
                type: ContentChild,
                args: [PDFMarginComponent, { static: false }]
            }], pageTemplateDirective: [{
                type: ContentChild,
                args: [PDFTemplateDirective, { static: false }]
            }] } });

/**
 * Represents the `export-to-PDF` command of the Grid.
 * You can apply this directive to any `button` element inside a
 * [ToolbarTemplate]({% slug api_grid_commandcolumncomponent %}).
 * When the user clicks a button that is associated with the directive, the
 * [pdfExport]({% slug api_grid_gridcomponent %}#toc-pdfexport) event
 * fires ([see example]({% slug pdfexport_grid %})).
 *
 * @example
 * ```html-no-run
 * <kendo-grid>
 *      <ng-template kendoGridToolbarTemplate>
 *          <button kendoGridPDFCommand>Export to PDF</button>
 *      </ng-template>
 *      <kendo-grid-pdf fileName="Grid.pdf">
 *      </kendo-grid-pdf>
 * </kendo-grid>
 * ```
 */
class PDFCommandDirective extends Button {
    pdfService;
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.pdfService.exportClick.emit();
    }
    /**
     * @hidden
     */
    get pdfClass() {
        return true;
    }
    constructor(pdfService, element, renderer, ctx, ngZone) {
        super(element, renderer, null, ctx.localization, ngZone);
        this.pdfService = pdfService;
        this.ngZone = ngZone;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PDFCommandDirective, deps: [{ token: PDFService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ContextService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: PDFCommandDirective, isStandalone: true, selector: "[kendoGridPDFCommand]", host: { listeners: { "click": "onClick($event)" }, properties: { "class.k-grid-pdf": "this.pdfClass" } }, usesInheritance: true, ngImport: i0, template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PDFCommandDirective, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridPDFCommand]',
                    template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
                    standalone: true,
                    imports: [NgIf, IconWrapperComponent, NgClass]
                }]
        }], ctorParameters: function () { return [{ type: PDFService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ContextService }, { type: i0.NgZone }]; }, propDecorators: { onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }], pdfClass: [{
                type: HostBinding,
                args: ['class.k-grid-pdf']
            }] } });

/**
 * @hidden
 */
const isFilterable = (settings) => settings !== false;
/**
 * @hidden
 */
const hasFilterMenu = (settings) => typeof settings === 'string' && settings.indexOf('menu') > -1;
/**
 * @hidden
 */
const hasFilterRow = (settings) => settings === true || (typeof settings === 'string' && settings.indexOf('row') > -1);

/**
 * @hidden
 */
class ColumnReorderService {
    changes = new EventEmitter();
    reorder(e) {
        this.changes.emit(e);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnReorderService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnReorderService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnReorderService, decorators: [{
            type: Injectable
        }] });

/**
 * Arguments for the `columnReorder` event.
 */
class ColumnReorderEvent extends PreventableEvent {
    /**
     * The reordered column.
     */
    column;
    /**
     * The new index of the column.
     * Relative to the collection of columns.
     */
    newIndex;
    /**
     * The original index of the column before reordering.
     * Relative to the collection of columns.
     */
    oldIndex;
    /**
     * @hidden
     */
    constructor({ column, newIndex, oldIndex }) {
        super();
        this.column = column;
        this.newIndex = newIndex;
        this.oldIndex = oldIndex;
    }
}

/**
 * @hidden
 */
const isLocked = column => column.parent ? isLocked(column.parent) : !!column.locked;
/**
 * @hidden
 */
const resizeArgs = (column, extra) => Object.assign({
    columns: leafColumns([column]),
    locked: isLocked(column)
}, extra);
/**
 * @hidden
 */
class ColumnResizingService {
    changes = new EventEmitter();
    column;
    resizedColumns;
    tables = [];
    batch = null;
    start(column) {
        this.trackColumns(column);
        const columns = (this.column.isColumnGroup ? [column] : [])
            .concat(leafColumns([column]));
        this.changes.emit({
            columns: columns,
            locked: isLocked(this.column),
            type: 'start'
        });
    }
    resizeColumns(deltaPercent) {
        const action = resizeArgs(this.column, {
            deltaPercent,
            type: 'resizeColumn'
        });
        this.changes.emit(action);
    }
    resizeTable(column, delta) {
        const action = resizeArgs(column, {
            delta,
            type: 'resizeTable'
        });
        this.changes.emit(action);
    }
    resizedColumn(state) {
        this.resizedColumns.push(state);
    }
    end() {
        this.changes.emit({
            columns: [],
            resizedColumns: this.resizedColumns,
            type: 'end'
        });
    }
    registerTable(tableMetadata) {
        this.tables.push(tableMetadata);
        const unregisterTable = () => {
            this.tables.splice(this.tables.indexOf(tableMetadata), 1);
        };
        return unregisterTable;
    }
    measureColumns(info) {
        if (this.batch !== null) {
            this.batch.push(...info);
        }
        else {
            this.autoFitBatch(info, () => this.end());
        }
    }
    autoFit(...columns) {
        const nonLockedColumns = columns.filter(column => !column.isLocked);
        this.autoFitStart(nonLockedColumns);
        this.autoFitBatch(this.batch, () => {
            if (nonLockedColumns.length < columns.length) {
                const lockedColumns = columns.filter(column => column.isLocked);
                this.autoFitStart(lockedColumns);
                this.autoFitBatch(this.batch, () => this.end());
            }
            else {
                this.end();
            }
        });
    }
    trackColumns(column) {
        this.resizedColumns = [];
        this.column = column;
    }
    autoFitStart(columns) {
        this.batch = [];
        this.resizedColumns = [];
        if (columns.length === 0) {
            return;
        }
        const locked = columns[0].isLocked;
        this.changes.emit({
            type: 'start',
            columns,
            locked
        });
        this.changes.emit({
            type: 'triggerAutoFit',
            columns,
            locked
        });
    }
    autoFitBatch(info, onComplete) {
        const locked = info.length > 0 ? info[0].column.isLocked : false;
        const observables = this.tables
            .filter(table => table.locked === locked)
            .map(table => table.autoFit(info));
        zip$1(...observables)
            .pipe(take(1))
            .subscribe(widths => {
            this.changes.emit({
                columns: info.map(i => i.column),
                type: 'autoFitComplete',
                widths,
                locked
            });
            if (onComplete) {
                onComplete();
            }
        });
        this.batch = null;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnResizingService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnResizingService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnResizingService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
const fromPercentage = (value, percent) => {
    const sign = percent < 0 ? -1 : 1;
    return Math.ceil((Math.abs(percent) / 100) * value) * sign;
};
/**
 * @hidden
 */
const toPercentage = (value, whole) => (value / whole) * 100;
/**
 * @hidden
 */
const headerWidth = (handle) => handle.nativeElement.parentElement.offsetWidth;
/**
 * @hidden
 */
const allLeafColumns = columns => expandColumns(columns)
    .filter(c => !c.isColumnGroup);
/**
 * @hidden
 */
const stopPropagation = ({ originalEvent: event }) => {
    event.stopPropagation();
    event.preventDefault();
};
/**
 * @hidden
 */
const createMoveStream = (service, draggable) => mouseDown => draggable.kendoDrag.pipe(takeUntil(draggable.kendoRelease.pipe(tap(() => service.end()))), map(({ pageX }) => ({
    originalX: mouseDown.pageX,
    pageX
})));
/**
 * @hidden
 */
const preventOnDblClick = release => mouseDown => of(mouseDown).pipe(delay(150), takeUntil(release));
/**
 * @hidden
 */
const isInSpanColumn = column => !!(column.parent && column.parent.isSpanColumn);
/**
 * @hidden
 *
 * Calculates the column index. If the column is stated in `SpanColumn`,
 * the index for all child columns equals the index of the first child.
 */
const indexOf = (target, list) => {
    let index = 0;
    let ignore = 0;
    let skip = 0;
    while (index < list.length) {
        const current = list[index];
        const isParentSpanColumn = isInSpanColumn(current);
        if (current === target) {
            break;
        }
        if ((ignore-- <= 0) && isParentSpanColumn) {
            ignore = current.parent.childColumns.length - 1;
            skip += ignore;
        }
        index++;
    }
    return index - skip;
};
/**
 * @hidden
 */
class ColumnHandleDirective {
    draggable;
    element;
    service;
    zone;
    cdr;
    ctx;
    columnInfoService;
    columns = [];
    column;
    get visible() {
        return this.column.resizable ? 'block' : 'none';
    }
    get leftStyle() {
        return isTruthy(this.rtl) ? 0 : null;
    }
    get rightStyle() {
        return isTruthy(this.rtl) ? null : 0;
    }
    subscriptions = new Subscription();
    rtl = false;
    autoFit() {
        const allLeafs = allLeafColumns(this.columns);
        const currentLeafs = leafColumns([this.column]).filter(column => isTruthy(column.resizable));
        const columnInfo = currentLeafs.map(column => {
            const isParentSpan = isInSpanColumn(column);
            const isLastInSpan = isParentSpan ? column.parent.childColumns.last === column : false;
            const index = indexOf(column, allLeafs);
            return {
                column,
                headerIndex: this.columnsForLevel(column.level).indexOf(column),
                index,
                isLastInSpan,
                isParentSpan,
                level: column.level
            };
        });
        currentLeafs.forEach(column => column.width = 0);
        this.service.measureColumns(columnInfo);
    }
    constructor(draggable, element, service, zone, cdr, ctx, columnInfoService) {
        this.draggable = draggable;
        this.element = element;
        this.service = service;
        this.zone = zone;
        this.cdr = cdr;
        this.ctx = ctx;
        this.columnInfoService = columnInfoService;
    }
    ngOnInit() {
        if (isBlank(this.column.width)) {
            this.column.implicitWidth = headerWidth(this.element);
        }
        const service = this.service.changes.pipe(filter(() => this.column.resizable), filter(e => isPresent(e.columns.find(column => column === this.column))));
        this.subscriptions.add(service.pipe(filter(e => e.type === 'start'))
            .subscribe(this.initState.bind(this)));
        this.subscriptions.add(service.pipe(filter(e => e.type === 'resizeColumn'))
            .subscribe(this.resize.bind(this)));
        this.subscriptions.add(this.service.changes.pipe(filter(e => e.type === 'start'), filter(this.shouldUpdate.bind(this)), take(1) //on first resize only
        ).subscribe(this.initColumnWidth.bind(this)));
        this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(tap(stopPropagation), tap(() => this.service.start(this.column)), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.service, this.draggable)))
            .subscribe(({ pageX, originalX }) => {
            const delta = pageX - originalX;
            const percent = toPercentage(delta, this.column.resizeStartWidth || this.column.width);
            this.service.resizeColumns(percent);
        })));
        this.subscriptions.add(service.pipe(filter(e => e.type === 'autoFitComplete'))
            .subscribe(this.sizeToFit.bind(this)));
        this.subscriptions.add(service.pipe(filter(e => e.type === 'triggerAutoFit'))
            .subscribe(this.autoFit.bind(this)));
        this.subscriptions.add(this.ctx.localization.changes.subscribe(({ rtl }) => this.rtl = rtl));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    shouldUpdate() {
        return !allLeafColumns(this.columns)
            .map(column => column.width)
            .some(isBlank);
    }
    initColumnWidth() {
        this.column.width = headerWidth(this.element);
    }
    initState() {
        this.column.resizeStartWidth = headerWidth(this.element);
        this.service.resizedColumn({
            column: this.column,
            oldWidth: this.column.resizeStartWidth
        });
    }
    resize({ deltaPercent }) {
        let delta = fromPercentage(this.column.resizeStartWidth, deltaPercent);
        if (isTruthy(this.rtl)) {
            delta *= -1;
        }
        let newWidth = Math.max(this.column.resizeStartWidth + delta, this.column.minResizableWidth);
        if (isPresent(this.column.maxResizableWidth)) {
            newWidth = Math.min(newWidth, this.column.maxResizableWidth);
        }
        const tableDelta = this.getTableDelta(newWidth, delta);
        this.updateWidth(this.column, newWidth);
        this.service.resizeTable(this.column, tableDelta);
    }
    sizeToFit({ columns, widths }) {
        const index = columns.indexOf(this.column);
        const width = Math.max(...widths.map(w => w[index])) + 1; //add 1px for IE
        const tableDelta = width - this.column.resizeStartWidth;
        this.updateWidth(this.column, width);
        this.service.resizeTable(this.column, tableDelta);
    }
    updateWidth(column, width) {
        column.width = width;
        this.columnInfoService.hiddenColumns.forEach((col) => {
            if (isBlank(col.width) && isPresent(col.implicitWidth)) {
                // Resize hidden columns to their implicit width so they
                // can be displayed with the same width if made visible.
                col.width = col.implicitWidth;
            }
        });
        this.cdr.markForCheck(); //force CD cycle
    }
    columnsForLevel(level) {
        return columnsToRender(this.columns ? this.columns.filter(column => column.level === level) : []);
    }
    getTableDelta(newWidth, delta) {
        const minWidth = this.column.minResizableWidth;
        const maxWidth = this.column.maxResizableWidth;
        const startWidth = this.column.resizeStartWidth;
        const isAboveMin = newWidth > minWidth;
        const isBelowMax = newWidth < maxWidth;
        const isInBoundaries = isPresent(maxWidth) ?
            isAboveMin && isBelowMax :
            isAboveMin;
        if (isInBoundaries) {
            return delta;
        }
        else if (newWidth <= minWidth) {
            return minWidth - startWidth;
        }
        else {
            return startWidth - maxWidth;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnHandleDirective, deps: [{ token: i1$3.DraggableDirective, host: true }, { token: i0.ElementRef }, { token: ColumnResizingService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: ContextService }, { token: ColumnInfoService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: ColumnHandleDirective, isStandalone: true, selector: "[kendoGridColumnHandle]", inputs: { columns: "columns", column: "column" }, host: { listeners: { "dblclick": "autoFit()" }, properties: { "style.display": "this.visible", "style.left": "this.leftStyle", "style.right": "this.rightStyle" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ColumnHandleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridColumnHandle]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i1$3.DraggableDirective, decorators: [{
                    type: Host
                }] }, { type: i0.ElementRef }, { type: ColumnResizingService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: ContextService }, { type: ColumnInfoService }]; }, propDecorators: { columns: [{
                type: Input
            }], column: [{
                type: Input
            }], visible: [{
                type: HostBinding,
                args: ['style.display']
            }], leftStyle: [{
                type: HostBinding,
                args: ['style.left']
            }], rightStyle: [{
                type: HostBinding,
                args: ['style.right']
            }], autoFit: [{
                type: HostListener,
                args: ['dblclick']
            }] } });

/**
 * @hidden
 */
class LocalDataChangesService {
    changes = new EventEmitter();
    data;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LocalDataChangesService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LocalDataChangesService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LocalDataChangesService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
class CellSelectionAggregateService {
    ctx;
    dataChanges;
    columnInfoService;
    selectedItems = [];
    groupedAggregates = { dates: [], numbers: [], booleans: [] };
    aggregates = {
        sum: null,
        average: null,
        min: null,
        max: null,
        count: null,
        isTrue: null,
        isFalse: null,
        earliest: null,
        latest: null
    };
    sub = new Subscription();
    constructor(ctx, dataChanges, columnInfoService) {
        this.ctx = ctx;
        this.dataChanges = dataChanges;
        this.columnInfoService = columnInfoService;
    }
    ngOnDestroy() {
        this.sub.unsubscribe();
    }
    isAggregateIncluded(aggregate) {
        const { cellAggregates } = this.ctx.grid.selectable;
        if (typeof cellAggregates !== 'boolean') {
            return cellAggregates?.includes(aggregate);
        }
        return true;
    }
    init() {
        this.sub.add(this.ctx.grid.dataStateChange.subscribe(_ => {
            // nullifies aggregates and sets default count to avoid mismatching state -
            // https://github.com/telerik/kendo-angular-private/issues/2964
            this.nullifyAggregates();
            if (this.isAggregateIncluded('count')) {
                this.aggregates['count'] = 0;
            }
        }));
        if (this.ctx.grid.selectable.cellAggregates) {
            if (this.isAggregateIncluded('count')) {
                this.aggregates['count'] = 0;
            }
            const selectionDirective = this.ctx.grid.selectionDirective;
            if (selectionDirective && !this.isRowSelection) {
                this.selectedItems = selectionDirective.selectedKeys;
            }
        }
    }
    onSelectionChange(selectionArgs) {
        this.handleSelectedItems(selectionArgs);
        this.nullifyAggregates();
        this.handleAggregateChanges();
        return this.aggregates;
    }
    get isRowSelection() {
        return typeof this.ctx.grid.selectable === 'boolean' || !this.ctx.grid.selectable.cell;
    }
    handleAggregateChanges() {
        const lockedColumns = this.columnInfoService.lockedLeafColumns.toArray();
        const nonLockedColumns = this.columnInfoService.nonLockedLeafColumns.toArray();
        const selectedItemsLength = this.selectedItems.length;
        const columns = [...lockedColumns, ...nonLockedColumns];
        const fields = columns.map(col => col.field);
        if (this.isAggregateIncluded('count')) {
            this.aggregates['count'] = this.isRowSelection ? (selectedItemsLength * columns.length) : selectedItemsLength;
        }
        this.selectedItems.forEach((item) => {
            if (this.isRowSelection) {
                fields.forEach((field) => {
                    const cellValue = item.dataItem;
                    if (cellValue && cellValue.hasOwnProperty(field)) {
                        const cellValue = item.dataItem[field];
                        this.groupAggregates(cellValue);
                    }
                });
            }
            else if (!this.isRowSelection) {
                // Enables working with the current Grid data regardless of its form (array, GridDataResult, GroupedResult).
                // Currently gets the item by index only - https://github.com/telerik/kendo-angular-private/issues/2964
                const selectedItem = this.ctx.grid.flatData.flatMap(recursiveFlatMap)[item.itemKey];
                const field = fields[item.columnKey];
                if (selectedItem && selectedItem.hasOwnProperty(field)) {
                    const cellValue = selectedItem[fields[item.columnKey]];
                    this.groupAggregates(cellValue);
                }
            }
        });
        this.calculateAggregates();
    }
    groupAggregates(aggregate) {
        if (typeof aggregate === 'number') {
            this.groupedAggregates.numbers.push(aggregate);
        }
        else if (typeof aggregate === 'boolean') {
            this.groupedAggregates.booleans.push(aggregate);
        }
        else if (aggregate instanceof Date) {
            this.groupedAggregates.dates.push(aggregate);
        }
    }
    calculateAggregates() {
        if (this.groupedAggregates.numbers.length > 0) {
            if (this.isAggregateIncluded('min')) {
                this.aggregates['min'] = Math.min(...this.groupedAggregates.numbers);
            }
            if (this.isAggregateIncluded('max')) {
                this.aggregates['max'] = Math.max(...this.groupedAggregates.numbers);
            }
            if (this.isAggregateIncluded('sum')) {
                this.aggregates['sum'] = this.groupedAggregates.numbers.reduce((acc, curr) => acc += curr, 0);
            }
            if (this.isAggregateIncluded('average')) {
                this.aggregates['average'] = this.aggregates['sum'] / this.groupedAggregates.numbers.length;
            }
        }
        if (this.groupedAggregates.booleans.length > 0) {
            if (this.isAggregateIncluded('isTrue')) {
                const isTrueCount = this.groupedAggregates.booleans.filter(bool => bool).length;
                this.aggregates['isTrue'] = isTrueCount > 0 ? isTrueCount : null;
            }
            if (this.isAggregateIncluded('isFalse')) {
                const isFalseCount = this.groupedAggregates.booleans.length - this.aggregates['isTrue'];
                this.aggregates['isFalse'] = isFalseCount > 0 ? isFalseCount : null;
            }
        }
        if (this.groupedAggregates.dates.length > 0) {
            if (this.isAggregateIncluded('earliest')) {
                this.aggregates['earliest'] = new Date(Math.min(...this.groupedAggregates.dates));
            }
            if (this.isAggregateIncluded('latest')) {
                this.aggregates['latest'] = new Date(Math.max(...this.groupedAggregates.dates));
            }
        }
    }
    handleSelectedItems(selectionArgs) {
        const rowOrCellSelect = `${this.isRowSelection ? 'selectedRows' : 'selectedCells'}`;
        const rowOrCellDeselect = `${this.isRowSelection ? 'deselectedRows' : 'deselectedCells'}`;
        const selectedItems = selectionArgs[rowOrCellSelect];
        const deselectedItems = selectionArgs[rowOrCellDeselect];
        if (!this.isRowSelection) {
            // Needed when we have column groups with cell selection, the deselected items are duplicated
            deselectedItems.forEach((item, index) => {
                if (index + 1 < deselectedItems.length) {
                    if (item.itemKey === deselectedItems[index + 1].itemKey
                        && item.columnKey === deselectedItems[index + 1].columnKey) {
                        deselectedItems.splice(index, 1);
                    }
                }
            });
        }
        if (selectedItems.length > 0) {
            selectedItems.forEach((item) => {
                this.selectedItems = [...this.selectedItems, item];
            });
        }
        if (deselectedItems.length > 0) {
            if (this.isRowSelection) {
                deselectedItems.forEach((row) => {
                    this.selectedItems = this.selectedItems.filter((elem) => elem.dataItem !== row.dataItem);
                });
            }
            else {
                deselectedItems.forEach((cell) => {
                    const index = this.selectedItems.findIndex((elem) => elem.itemKey === cell.itemKey && elem.columnKey === cell.columnKey);
                    this.selectedItems.splice(index, 1);
                });
            }
        }
    }
    nullifyAggregates() {
        this.groupedAggregates = { dates: [], numbers: [], booleans: [] };
        this.aggregates['count'] = null;
        this.aggregates['sum'] = this.aggregates['average'] = null;
        this.aggregates['max'] = this.aggregates['min'] = null;
        this.aggregates['isFalse'] = this.aggregates['isTrue'] = null;
        this.aggregates['earliest'] = this.aggregates['latest'] = null;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CellSelectionAggregateService, deps: [{ token: ContextService }, { token: LocalDataChangesService }, { token: ColumnInfoService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CellSelectionAggregateService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CellSelectionAggregateService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: ContextService }, { type: LocalDataChangesService }, { type: ColumnInfoService }]; } });

/**
 * @hidden
 */
class SelectionService {
    domEvents;
    aggregateService;
    localDataChangesService;
    navigationService;
    ctxService;
    changes = new EventEmitter();
    lastSelectionStartIndex;
    currentSelection = [];
    nonSelectableRows = new Map();
    selectAllChecked = false;
    settings;
    active = false;
    aggregates;
    get enableMarquee() {
        const checkboxOnly = this.settings && typeof this.settings === 'object' && this.settings.checkboxOnly;
        if (!this.settings || checkboxOnly) {
            return false;
        }
        const selectableSettings = this.settings.selectable;
        const dragAndMultiple = typeof (selectableSettings) === 'object' &&
            isPresent(selectableSettings) &&
            selectableSettings.mode === 'multiple' &&
            selectableSettings.enabled !== false &&
            !selectableSettings.checkboxOnly &&
            selectableSettings.drag;
        return this.active && dragAndMultiple;
    }
    mouseDownEventArgs;
    dragging = false;
    get hasNonSelectable() {
        return this.nonSelectableRows.size > 0;
    }
    cellClickSubscription;
    mousedownSubscription;
    dataChangedSubscription;
    lastSelectionData = {};
    _selectAllState;
    constructor(domEvents, aggregateService, localDataChangesService, navigationService, ctxService) {
        this.domEvents = domEvents;
        this.aggregateService = aggregateService;
        this.localDataChangesService = localDataChangesService;
        this.navigationService = navigationService;
        this.ctxService = ctxService;
        this.addSubscriptions();
    }
    init(settings) {
        this.settings = settings;
        if (!isPresent(this.lastSelectionStartIndex)) {
            this.lastSelectionStartIndex = this.ctxService?.grid.selectionDirective?.rangeSelectionStartRow?.index || 0;
            this.lastSelectionData = this.ctxService?.grid.selectionDirective?.rangeSelectionStartRow?.dataItem || {};
        }
        this.currentSelection = [];
        this.nonSelectableRows = new Map();
        if (settings.selectable && settings.selectable.enabled !== false) {
            const iterator = this.getIterator();
            this._selectAllState = true;
            let item = iterator.next();
            while (!item.done) {
                if (item.value && item.value.type === "data") {
                    const rowArgs = {
                        dataItem: item.value.data,
                        index: item.value.index
                    };
                    if (settings.rowSelected(rowArgs)) {
                        this.currentSelection[item.value.index] = rowArgs;
                    }
                    else {
                        this._selectAllState = undefined;
                    }
                    if (!settings.isRowSelectable(rowArgs)) {
                        this.nonSelectableRows.set(rowArgs.index, rowArgs.dataItem);
                        this._selectAllState = undefined;
                    }
                }
                item = iterator.next();
            }
            if (this.currentSelection.length === 0) {
                this._selectAllState = false;
            }
        }
    }
    isSelected(index) {
        if (this.settings && this.active) {
            return this.options.enabled && isPresent(this.currentSelection[index]) && !this.nonSelectableRows.has(index);
        }
    }
    handleClick(item, event) {
        if (this.dragging) {
            this.dragging = false;
            return;
        }
        let ev;
        const ctrlKey = event.ctrlKey || event.metaKey;
        if (this.options.mode === "single" && ctrlKey && this.isSelected(item.index)) {
            ev = this.toggle(item);
        }
        else if (this.options.mode === "multiple") {
            if ((ctrlKey || !this.options.metaKeyMultiSelect) && !event.shiftKey) {
                ev = this.toggle(item);
            }
            else if (event.shiftKey) {
                ev = this.addAllTo(item, ctrlKey);
            }
        }
        if (!isPresent(ev)) {
            ev = this.select(item);
            this.currentSelection[item.index] = {
                dataItem: item.data,
                index: item.index
            };
        }
        if (!ev.selectedRows.length && !ev.deselectedRows.length) {
            return;
        }
        ev.ctrlKey = ctrlKey;
        ev.shiftKey = event.shiftKey;
        if (this.options.cellAggregates) {
            ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
        }
        if (ev.shiftKey) {
            ev.rangeStartRow = { dataItem: this.lastSelectionData, index: this.lastSelectionStartIndex };
            ev.rangeEndRow = { dataItem: item.data, index: item.index };
        }
        this.changes.emit(ev);
    }
    toggle(item) {
        const selectedRows = [];
        const deselectedRows = [];
        this.lastSelectionStartIndex = item.index;
        this.lastSelectionData = item.data;
        const rowArgs = { dataItem: item.data, index: item.index };
        if (this.isSelected(item.index)) {
            deselectedRows.push(rowArgs);
        }
        else if (!this.nonSelectableRows.has(item.index)) {
            selectedRows.push(rowArgs);
        }
        if (this.hasNonSelectable) {
            const nonSelectableRows = this.currentSelection.filter(i => this.nonSelectableRows.has(i.index));
            deselectedRows.push(...nonSelectableRows);
        }
        return {
            deselectedRows: deselectedRows,
            selectedRows: selectedRows
        };
    }
    toggleByIndex(index) {
        const iterator = this.getIterator();
        if (this.selectAllChecked && this.isSelected(index)) {
            this.selectAllChecked = false;
        }
        let item = iterator.next();
        while (!item.done) {
            if (item.value && item.value.type === "data" && item.value.index === index) {
                const itemToToggle = {
                    data: item.value.data,
                    index: item.value.index
                };
                if (this.isSelected(index) || this.options.mode === "multiple") {
                    return this.toggle(itemToToggle);
                }
                else {
                    return this.select(itemToToggle);
                }
            }
            item = iterator.next();
        }
    }
    select(item) {
        const deselectedRows = [];
        const selectedRows = [];
        this.lastSelectionStartIndex = item.index;
        this.lastSelectionData = item.data;
        if (!this.isSelected(item.index) && !this.nonSelectableRows.has(item.index)) {
            selectedRows.push({ dataItem: item.data, index: item.index });
        }
        this.currentSelection.forEach((row) => {
            if (row.index !== item.index) {
                deselectedRows.push(row);
            }
        });
        return {
            deselectedRows: deselectedRows,
            selectedRows: selectedRows
        };
    }
    //Used to manually deselect removed items
    deselect(removedItem) {
        const iterator = this.getIterator();
        let item = iterator.next();
        while (!item.done) {
            if (item.value && item.value.type === "data" && item.value.data === removedItem) {
                const rowArgs = {
                    dataItem: item.value.data,
                    index: item.value.index
                };
                if (this.isSelected(rowArgs.index) || this.nonSelectableRows.has(rowArgs.index)) {
                    const ev = {
                        ctrlKey: false,
                        deselectedRows: [rowArgs],
                        selectedRows: []
                    };
                    this.changes.emit(ev);
                }
            }
            item = iterator.next();
        }
    }
    addAllTo(item, ctrlKey) {
        const selectedRows = [];
        const deselectedRows = [];
        const start = Math.min(this.lastSelectionStartIndex, item.index);
        const end = Math.max(this.lastSelectionStartIndex, item.index);
        const iterator = this.getIterator();
        let next = iterator.next();
        while (!next.done) {
            if (next.value && next.value.type === "data") {
                const idx = next.value.index;
                const rowArgs = { dataItem: next.value.data, index: idx };
                if ((idx < start || idx > end) && this.isSelected(idx) && !ctrlKey) {
                    deselectedRows.push(rowArgs);
                }
                if ((idx >= start && idx <= end) && !this.isSelected(idx) && !this.nonSelectableRows.has(idx)) {
                    selectedRows.push(rowArgs);
                }
            }
            next = iterator.next();
        }
        if (this.hasNonSelectable) {
            const nonSelectableRows = this.currentSelection.filter(i => this.nonSelectableRows.has(i.index));
            deselectedRows.push(...nonSelectableRows);
        }
        return {
            deselectedRows: deselectedRows,
            selectedRows: selectedRows
        };
    }
    updateAll(selectAllChecked) {
        this.selectAllChecked = selectAllChecked;
        const selectedRows = [];
        const deselectedRows = [];
        const iterator = this.getIterator();
        let next = iterator.next();
        while (!next.done) {
            if (next.value && next.value.type === "data") {
                const idx = next.value.index;
                const rowArgs = { dataItem: next.value.data, index: idx };
                if (!this.nonSelectableRows.has(idx)) {
                    if (this.isSelected(idx) && !selectAllChecked) {
                        deselectedRows.push(rowArgs);
                    }
                    if (!this.isSelected(idx) && selectAllChecked) {
                        selectedRows.push(rowArgs);
                    }
                }
            }
            next = iterator.next();
        }
        if (!selectedRows.length && !deselectedRows.length) {
            return;
        }
        if (this.hasNonSelectable) {
            const nonSelectableRows = this.currentSelection.filter(i => this.nonSelectableRows.has(i.index));
            deselectedRows.push(...nonSelectableRows);
        }
        const ev = {
            ctrlKey: true,
            deselectedRows: deselectedRows,
            selectedRows: selectedRows,
            shiftKey: true
        };
        if (this.options.cellAggregates) {
            ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
        }
        this.changes.emit(ev);
    }
    selectRange(startIndex, endIndex) {
        const selectedRows = [];
        const deselectedRows = [];
        const start = Math.min(startIndex, endIndex);
        const end = Math.max(startIndex, endIndex);
        const iterator = this.getIterator();
        let next = iterator.next();
        while (!next.done) {
            if (next.value && next.value.type === "data") {
                const idx = next.value.index;
                const rowArgs = { dataItem: next.value.data, index: idx };
                if ((idx < start || idx > end) && this.isSelected(idx)) {
                    deselectedRows.push(rowArgs);
                }
                if ((idx >= start && idx <= end) && !this.isSelected(idx) && !this.nonSelectableRows.has(idx)) {
                    selectedRows.push(rowArgs);
                }
            }
            next = iterator.next();
        }
        let cellAggregates;
        if (this.options.cellAggregates) {
            cellAggregates = this.aggregateService.onSelectionChange({ selectedRows, deselectedRows });
        }
        if (this.hasNonSelectable) {
            const nonSelectableRows = this.currentSelection.filter(i => this.nonSelectableRows.has(i.index));
            deselectedRows.push(...nonSelectableRows);
        }
        return {
            deselectedRows: deselectedRows,
            selectedRows: selectedRows,
            cellAggregates
        };
    }
    get selectAllState() {
        return this._selectAllState;
    }
    get selected() {
        return this.currentSelection.map((item) => {
            return item.index;
        }).filter((n) => typeof n === "number");
    }
    get options() {
        const defaultOptions = {
            cellAggregates: false,
            checkboxOnly: false,
            enabled: true,
            mode: "multiple",
            metaKeyMultiSelect: true
        };
        if (!isPresent(this.settings)) {
            return defaultOptions;
        }
        if (typeof this.settings.selectable === 'boolean') {
            return {
                cellAggregates: false,
                checkboxOnly: false,
                enabled: this.settings.selectable,
                mode: "multiple",
                metaKeyMultiSelect: true
            };
        }
        else {
            return Object.assign(defaultOptions, this.settings.selectable);
        }
    }
    ngOnDestroy() {
        this.removeSubscriptions();
    }
    targetArgs() {
        return {
            index: this.mouseDownEventArgs.rowIndex,
            dataItem: this.mouseDownEventArgs.dataItem
        };
    }
    addSubscriptions() {
        if (!this.cellClickSubscription) {
            this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
                if (this.options.enabled && !this.options.checkboxOnly && args.type !== 'contextmenu') {
                    if (this.active) {
                        this.handleClick({ index: args.rowIndex, data: args.dataItem }, args.originalEvent);
                    }
                }
            });
        }
        if (!this.mousedownSubscription) {
            this.mousedownSubscription = this.domEvents.cellMousedown.subscribe((args) => {
                this.mouseDownEventArgs = args;
                if ((this.options.enabled && (!this.options.mode || this.options.mode === "multiple") &&
                    !this.options.checkboxOnly && args.originalEvent.shiftKey)) {
                    if (this.active) {
                        args.originalEvent.preventDefault();
                        this.navigationService.focusCellByElement(args.originalEvent.target);
                    }
                }
            });
        }
        if (this.localDataChangesService && !this.dataChangedSubscription) {
            this.dataChangedSubscription = this.localDataChangesService.changes.subscribe((args) => {
                if (this.active) {
                    if (isPresent(args.action) && args.action === 'remove') {
                        this.deselect(args.item);
                    }
                }
            });
        }
    }
    getIterator() {
        const accessor = this.settings.view.accessor();
        if (!accessor) {
            return;
        }
        return accessor[iterator]();
    }
    removeSubscriptions() {
        if (this.cellClickSubscription) {
            this.cellClickSubscription.unsubscribe();
            this.cellClickSubscription = null;
        }
        if (this.mousedownSubscription) {
            this.mousedownSubscription.unsubscribe();
            this.mousedownSubscription = null;
        }
        if (this.dataChangedSubscription) {
            this.dataChangedSubscription.unsubscribe();
            this.dataChangedSubscription = null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SelectionService, deps: [{ token: DomEventsService }, { token: CellSelectionAggregateService }, { token: LocalDataChangesService }, { token: NavigationService }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SelectionService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SelectionService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: DomEventsService }, { type: CellSelectionAggregateService }, { type: LocalDataChangesService }, { type: NavigationService }, { type: ContextService }]; } });

/**
 * @hidden
 */
class CellSelectionService {
    domEvents;
    aggregateService;
    localDataChangesService;
    navigationService;
    changes = new EventEmitter();
    mouseUpEvent = new EventEmitter();
    currentSelection = [];
    settings;
    active = false;
    aggregates;
    nonSelectableRows = new Map();
    get enableMarquee() {
        const checkboxOnly = this.settings && typeof this.settings === 'object' && this.settings.checkboxOnly;
        if (!this.settings || checkboxOnly) {
            return false;
        }
        const selectableSettings = this.settings.selectable;
        const dragAndMultiple = typeof (selectableSettings) === 'object' &&
            isPresent(selectableSettings) &&
            selectableSettings.mode === 'multiple' &&
            selectableSettings.cell &&
            selectableSettings.enabled !== false &&
            selectableSettings.drag;
        return this.active && dragAndMultiple;
    }
    get hasNonSelectable() {
        return this.nonSelectableRows.size > 0;
    }
    mouseDownEventArgs;
    mouseUpEventArgs;
    dragging = false;
    dragSelectDeselect = false;
    lastSelectionItem = { itemKey: 0, columnKey: 0 };
    lastSelectionItemRowIndex = 0;
    lastSelectionItemColIndex = 0;
    cellClickSubscription;
    dataChangedSubscription;
    mousedownSubscription;
    constructor(domEvents, aggregateService, localDataChangesService, navigationService) {
        this.domEvents = domEvents;
        this.aggregateService = aggregateService;
        this.localDataChangesService = localDataChangesService;
        this.navigationService = navigationService;
        this.addSubscriptions();
    }
    init(settings) {
        this.settings = settings;
        this.currentSelection = [];
        this.nonSelectableRows = new Map();
        if (settings.selectable && settings.selectable.enabled !== false) {
            const iterator = this.getIterator();
            let item = iterator.next();
            while (!item.done) {
                if (item.value && item.value.type === "data") {
                    const rowArgs = {
                        dataItem: item.value.data,
                        index: item.value.index
                    };
                    settings.columns.forEach(col => {
                        const selectedCellArgs = settings.cellSelected(rowArgs, col, col.leafIndex);
                        if (selectedCellArgs.selected) {
                            this.currentSelection.push(selectedCellArgs.item);
                        }
                        if (!settings.isRowSelectable(rowArgs)) {
                            this.nonSelectableRows.set(rowArgs.index, rowArgs.dataItem);
                        }
                    });
                }
                item = iterator.next();
            }
        }
    }
    isCellSelected(item, col) {
        if (this.settings && this.active) {
            const selectedCellArgs = this.settings.cellSelected({ dataItem: item.data, index: item.index }, col, col.leafIndex);
            return this.options.enabled && selectedCellArgs.selected && !this.nonSelectableRows.has(item.index);
        }
        return false;
    }
    handleClick(item, event) {
        if (this.dragging) {
            this.dragging = false;
            return;
        }
        let ev;
        const ctrlKey = event.ctrlKey || event.metaKey;
        if (this.options.mode === "single" && ctrlKey && this.isCellSelected(item, item.column)) {
            ev = this.toggle(item);
        }
        else if (this.options.mode === "multiple") {
            if ((ctrlKey || !this.options.metaKeyMultiSelect) && !event.shiftKey) {
                ev = this.toggle(item);
            }
            else if (event.shiftKey) {
                const startRowIndex = Math.min(this.lastSelectionItemRowIndex, item.index);
                const startColIndex = Math.min(this.lastSelectionItemColIndex, item.column.leafIndex);
                const endRowIndex = Math.max(this.lastSelectionItemRowIndex, item.index);
                const endColIndex = Math.max(this.lastSelectionItemColIndex, item.column.leafIndex);
                ev = this.selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex);
            }
        }
        if (!isPresent(ev)) {
            ev = this.select(item);
            this.currentSelection = [this.lastSelectionItem];
        }
        if (!ev.selectedCells.length && !ev.deselectedCells.length) {
            return;
        }
        ev.ctrlKey = ctrlKey;
        ev.shiftKey = event.shiftKey;
        if (this.options.cellAggregates && !event.shiftKey) {
            ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
        }
        if (ev.shiftKey) {
            ev.rangeStartCell = this.lastSelectionItem;
            ev.rangeEndCell = {
                ...this.settings.cellSelected({ dataItem: item.data, index: item.index }, item.column, item.column.leafIndex).item
            };
        }
        this.changes.emit(ev);
    }
    toggle(item) {
        const selectedCells = [];
        const deselectedCells = [];
        this.lastSelectionItem =
            this.settings.cellSelected({ dataItem: item.data, index: item.index }, item.column, item.column.leafIndex).item;
        this.lastSelectionItemRowIndex = item.index;
        this.lastSelectionItemColIndex = item.column.leafIndex;
        if (this.isCellSelected(item, item.column)) {
            deselectedCells.push(this.lastSelectionItem);
        }
        else if (!this.nonSelectableRows.has(item.index)) {
            selectedCells.push(this.lastSelectionItem);
        }
        return {
            deselectedCells,
            selectedCells
        };
    }
    select(item) {
        const selectedCells = [];
        const deselectedCells = [];
        this.lastSelectionItem =
            this.settings.cellSelected({ dataItem: item.data, index: item.index }, item.column, item.column.leafIndex).item;
        this.lastSelectionItemRowIndex = item.index;
        this.lastSelectionItemColIndex = item.column.leafIndex;
        if (!this.isCellSelected(item, item.column) && !this.nonSelectableRows.has(item.index)) {
            selectedCells.push(this.lastSelectionItem);
        }
        this.currentSelection.forEach((selectedItem) => {
            if (selectedItem.itemKey !== this.lastSelectionItem.itemKey || selectedItem.columnKey !== this.lastSelectionItem.columnKey) {
                deselectedCells.push(selectedItem);
            }
        });
        return {
            deselectedCells,
            selectedCells
        };
    }
    //Used to manually deselect removed items
    deselect(removedItem) {
        const iterator = this.getIterator();
        let item = iterator.next();
        let rowArgs;
        while (!item.done) {
            if (item.value && item.value.type === "data" && item.value.data === removedItem) {
                rowArgs = {
                    dataItem: item.value.data,
                    index: item.value.index
                };
                break;
            }
            item = iterator.next();
        }
        if (rowArgs) {
            const cellsToRemove = this.currentSelection.filter(selectedItem => {
                const contender = this.settings.cellSelected(rowArgs, null, null).item;
                return selectedItem.itemKey === contender.itemKey || this.nonSelectableRows.has(rowArgs.index);
            });
            if (cellsToRemove.length) {
                const ev = {
                    ctrlKey: false,
                    deselectedCells: cellsToRemove,
                    selectedCells: []
                };
                this.changes.emit(ev);
            }
        }
    }
    selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex) {
        const selectedCells = [];
        const deselectedCells = [];
        const selectionStartRow = Math.min(startRowIndex, endRowIndex);
        const selectionStartCol = Math.min(startColIndex, endColIndex);
        const selectionEndRow = Math.max(startRowIndex, endRowIndex);
        const selectionEndCol = Math.max(startColIndex, endColIndex);
        const iterator = this.getIterator();
        let next = iterator.next();
        while (!next.done) {
            if (next.value && next.value.type === "data") {
                const idx = next.value.index;
                const data = next.value.data;
                const rowArgs = {
                    dataItem: data,
                    index: idx
                };
                this.settings.columns.forEach(col => {
                    const { item } = this.settings.cellSelected(rowArgs, col, col.leafIndex);
                    const selected = this.isCellSelected(next.value, col);
                    const isInRowRange = selectionStartRow <= idx && idx <= selectionEndRow;
                    const isInColRange = selectionStartCol <= col.leafIndex && col.leafIndex <= selectionEndCol;
                    const isInSelectionRect = isInRowRange && isInColRange;
                    if (!isInSelectionRect && selected) {
                        deselectedCells.push(item);
                    }
                    if (isInSelectionRect && !selected && !this.nonSelectableRows.has(idx)) {
                        selectedCells.push(item);
                    }
                });
            }
            next = iterator.next();
        }
        let cellAggregates;
        if (this.options.cellAggregates) {
            cellAggregates = this.aggregateService.onSelectionChange({ selectedCells, deselectedCells });
        }
        return {
            deselectedCells,
            selectedCells,
            cellAggregates
        };
    }
    get options() {
        const defaultOptions = {
            cellAggregates: false,
            checkboxOnly: false,
            enabled: true,
            mode: "multiple",
            metaKeyMultiSelect: true
        };
        if (!isPresent(this.settings)) {
            return defaultOptions;
        }
        if (typeof this.settings.selectable === 'boolean') {
            return {
                cellAggregates: false,
                checkboxOnly: false,
                enabled: this.settings.selectable,
                mode: "multiple",
                metaKeyMultiSelect: true
            };
        }
        else {
            return Object.assign(defaultOptions, this.settings.selectable);
        }
    }
    ngOnDestroy() {
        this.removeSubscriptions();
    }
    addSubscriptions() {
        if (!this.cellClickSubscription) {
            this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
                if (this.options.enabled && !this.options.checkboxOnly && args.type !== 'contextmenu') {
                    if (this.active) {
                        this.handleClick({ index: args.rowIndex, data: args.dataItem, column: args.column }, args.originalEvent);
                    }
                }
            });
        }
        if (!this.mousedownSubscription) {
            this.mousedownSubscription = this.domEvents.cellMousedown.subscribe((args) => {
                this.mouseDownEventArgs = args;
                if (this.options.enabled && (!this.options.mode || this.options.mode === "multiple") &&
                    !this.options.checkboxOnly && args.originalEvent.shiftKey) {
                    if (this.active) {
                        args.originalEvent.preventDefault();
                        this.navigationService.focusCellByElement(args.originalEvent.target);
                    }
                }
            });
        }
        if (this.localDataChangesService && !this.dataChangedSubscription) {
            this.dataChangedSubscription = this.localDataChangesService.changes.subscribe((args) => {
                if (this.active) {
                    if (isPresent(args.action) && args.action === 'remove') {
                        this.deselect(args.item);
                    }
                }
            });
        }
    }
    getIterator() {
        const accessor = this.settings.view.accessor();
        if (!accessor) {
            return;
        }
        return accessor[iterator]();
    }
    removeSubscriptions() {
        if (this.cellClickSubscription) {
            this.cellClickSubscription.unsubscribe();
            this.cellClickSubscription = null;
        }
        if (this.mousedownSubscription) {
            this.mousedownSubscription.unsubscribe();
            this.mousedownSubscription = null;
        }
        if (this.dataChangedSubscription) {
            this.dataChangedSubscription.unsubscribe();
            this.dataChangedSubscription = null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CellSelectionService, deps: [{ token: DomEventsService }, { token: CellSelectionAggregateService }, { token: LocalDataChangesService }, { token: NavigationService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CellSelectionService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CellSelectionService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: DomEventsService }, { type: CellSelectionAggregateService }, { type: LocalDataChangesService }, { type: NavigationService }]; } });

/**
 * Represents the select-all checkbox feature of the Grid ([see example](slug:grid_selection_persistence#toc-selecting-all-items)).
 *
 * @example
 * ```html
 * <input
 *   type="checkbox"
 *   kendoCheckBox
 *   kendoGridSelectAllCheckbox
 *   [state]="selectAllState"
 *   (selectAllChange)="onSelectAllChange($event)"
 * />
 * ```
 */
class SelectAllCheckboxDirective {
    selectionService;
    cellSelectionService;
    ngZone;
    element;
    renderer;
    checkbox;
    /**
     * Explicitly overrides the state of the select-all checkbox.
     */
    state;
    /**
     * Fires when the user clicks the `kendoGridSelectAllCheckbox` select-all checkbox
     * ([see example](slug:grid_row_selection#toc-select-all-checkbox)).
     */
    selectAllChange = new EventEmitter();
    destroyClick;
    checkboxChange;
    stateSet = false;
    ngAfterContentChecked() {
        this.setState();
    }
    ngOnChanges() {
        this.stateSet = true;
    }
    constructor(selectionService, cellSelectionService, ngZone, element, renderer, checkbox) {
        this.selectionService = selectionService;
        this.cellSelectionService = cellSelectionService;
        this.ngZone = ngZone;
        this.element = element;
        this.renderer = renderer;
        this.checkbox = checkbox;
        this.ngZone.runOutsideAngular(() => {
            if (this.checkbox) {
                this.checkboxChange = this.checkbox.checkedStateChange.subscribe(this.onClick.bind(this));
            }
            else {
                this.destroyClick = this.renderer.listen(this.element.nativeElement, 'click', this.onClick.bind(this));
            }
        });
    }
    ngOnDestroy() {
        if (this.checkboxChange) {
            this.checkboxChange.unsubscribe();
        }
        if (this.destroyClick) {
            this.destroyClick();
        }
    }
    /**
     * @hidden
     */
    onClick() {
        const isIndeterminateState = this.checkbox?.checkedState === 'indeterminate' || this.element.nativeElement.indeterminate;
        const isCheckedState = this.checkbox?.checkedState === true || this.element.nativeElement.checked;
        const checkboxState = isCheckedState ? 'checked' : isIndeterminateState ? 'indeterminate' : 'unchecked';
        const isChecked = this.selectionService.hasNonSelectable ? !this.selectionService.selectAllChecked : isCheckedState;
        const options = this.selectionService.options;
        const enabledAndMultiple = options.enabled && options.mode === 'multiple' && !this.cellSelectionService.active;
        const shouldEmitSelectAll = hasObservers(this.selectAllChange);
        if (enabledAndMultiple || shouldEmitSelectAll) {
            this.ngZone.run(() => {
                if (enabledAndMultiple) {
                    this.selectionService.updateAll(isChecked);
                }
                if (shouldEmitSelectAll) {
                    this.selectAllChange.emit(checkboxState);
                }
            });
        }
    }
    /**
     * @hidden
     */
    setState() {
        const state = this.stateSet ? this.stateToBool() : this.selectionService.selectAllState;
        if (this.checkbox) {
            this.checkbox.checkedState = isPresent(state) ? state : 'indeterminate';
        }
        else {
            const elem = this.element.nativeElement;
            this.renderer.setProperty(elem, 'indeterminate', !isPresent(state));
            this.renderer.setProperty(elem, 'checked', isPresent(state) ? state : false);
        }
    }
    /**
     * @hidden
     */
    stateToBool() {
        switch (this.state) {
            case 'checked':
                return true;
            case 'unchecked':
                return false;
            default:
                return undefined;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SelectAllCheckboxDirective, deps: [{ token: SelectionService }, { token: CellSelectionService }, { token: i0.NgZone }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i3.CheckBoxComponent, host: true, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: SelectAllCheckboxDirective, isStandalone: true, selector: "[kendoGridSelectAllCheckbox]", inputs: { state: "state" }, outputs: { selectAllChange: "selectAllChange" }, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SelectAllCheckboxDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridSelectAllCheckbox]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: SelectionService }, { type: CellSelectionService }, { type: i0.NgZone }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i3.CheckBoxComponent, decorators: [{
                    type: Host
                }, {
                    type: Optional
                }] }]; }, propDecorators: { state: [{
                type: Input
            }], selectAllChange: [{
                type: Output
            }] } });

const mergeObjects = (...args) => Object.assign.apply(null, [{}].concat(args));
const directions = initialDirection => initialDirection === "asc" ? ["asc", "desc"] : ["desc", "asc"];
/**
 * @hidden
 */
const isRootLevel = ({ parent }) => !isTruthy(parent);
const ofColumnType = ({ draggable }) => ['column', 'columnGroup']
    .indexOf(draggable.context.type) >= 0;
const notSameElement = ({ draggable, target }) => draggable.element.nativeElement !== target.element.nativeElement;
const inSameParent = (x, y) => x.parent === y.parent ||
    (isInSpanColumn$1(y) && inSameParent(x, y.parent));
const sameParent = ({ draggable, target }) => inSameParent(draggable.context.column, target.context.column);
const lastNonLocked = ({ draggable }) => !isTruthy(draggable.context.column.locked) &&
    isRootLevel(draggable.context.column) &&
    draggable.context.lastColumn;
const notInSpanColumn = ({ draggable }) => !isInSpanColumn$1(draggable.context.column);
const reorderable = ({ draggable }) => draggable.context.column.reorderable;
const lockable = ({ draggable, target }) => draggable.context.column.lockable !== false ||
    draggable.context.column.isLocked === target.context.column.isLocked;
const rules = and(ofColumnType, reorderable, notInSpanColumn, notSameElement, sameParent, not(lastNonLocked), lockable);
const modifierKeys = ['alt', 'ctrl', 'shift', 'meta'];
/**
 * @hidden
 */
class HeaderComponent {
    popupService;
    hint;
    cue;
    reorderService;
    idService;
    sortService;
    columnInfoService;
    cd;
    contextService;
    navigationService;
    zone;
    /**
     * @hidden
     */
    totalColumnLevels;
    columns = [];
    groups = [];
    detailTemplate;
    scrollable;
    filterable;
    sort = new Array();
    filter;
    sortable = false;
    groupable = false;
    lockedColumnsCount = 0;
    resizable = false;
    reorderable = false;
    columnMenu = false;
    columnMenuTemplate;
    totalColumnsCount = 0;
    totalColumns;
    tabIndex;
    size = 'medium';
    sortedFields = {};
    get headerClass() {
        return !this.scrollable;
    }
    hostClass = true;
    get sortableLabel() {
        return this.contextService.localization.get('sortable');
    }
    get columnMenuSettings() {
        return this.columnMenu;
    }
    dropTargets = new QueryList();
    filterMenus;
    columnMenus;
    // Number of unlocked columns in the next table, if any
    get unlockedColumnsCount() {
        return this.totalColumnsCount - this.lockedColumnsCount - this.columns.length;
    }
    sortAscSmallIcon = sortAscSmallIcon;
    sortDescSmallIcon = sortDescSmallIcon;
    subscription = new Subscription();
    targetSubscription;
    stopSorting = false;
    _leafColumns;
    constructor(popupService, hint, cue, reorderService, idService, sortService, columnInfoService, cd, contextService, navigationService, zone) {
        this.popupService = popupService;
        this.hint = hint;
        this.cue = cue;
        this.reorderService = reorderService;
        this.idService = idService;
        this.sortService = sortService;
        this.columnInfoService = columnInfoService;
        this.cd = cd;
        this.contextService = contextService;
        this.navigationService = navigationService;
        this.zone = zone;
    }
    sortColumn(descriptor) {
        this.sortService.sort(descriptor);
    }
    getColumnComponent(column) {
        return column;
    }
    onSortClick(column, event, link) {
        if (this.stopSorting) {
            this.stopSorting = false;
            return;
        }
        const target = event.target;
        if (column.headerTemplateRef && target !== link) {
            const hasFocusableParent = Boolean(closestInScope(target, isFocusable, link));
            if (hasFocusableParent) {
                // Do not sort when clicking focusable template elements.
                return;
            }
        }
        const modifier = this.matchModifier(event);
        const toggledColumn = this.toggleSort(column, modifier);
        this.sortColumn(toggledColumn);
    }
    onHeaderKeydown(column, args) {
        if (args.keyCode === Keys.ArrowDown && args.altKey && this.showFilterMenu) {
            args.preventDefault();
            args.stopImmediatePropagation();
            const filterMenu = this.filterMenus.find(fm => fm.column === column);
            filterMenu.toggle(filterMenu.anchor.nativeElement, filterMenu.template);
            return;
        }
        if (args.keyCode === Keys.ArrowDown && args.altKey && this.showColumnMenu(column)) {
            args.preventDefault();
            args.stopImmediatePropagation();
            const columnMenu = this.columnMenus.find(cm => cm.column === column);
            columnMenu.toggle(null, columnMenu.anchor.nativeElement, columnMenu.template);
            return;
        }
        const isCtrlOrMeta = args.ctrlKey || args.metaKey;
        const isGroupingKeyShortcut = (args.keyCode === Keys.Enter || args.keyCode === Keys.Space) && isCtrlOrMeta;
        if (isGroupingKeyShortcut && this.isGroupable(column)) {
            args.preventDefault();
            args.stopImmediatePropagation();
            const isGroupedByField = this.groups.some(gr => gr.field === column.field);
            if (isGroupedByField) {
                this.groups = this.groups.filter(gr => gr.field !== column.field);
            }
            else {
                this.groups.push({
                    field: column.field
                });
            }
            this.contextService.grid.groupChange.emit(this.groups);
            return;
        }
        const isLeftOrRightArrow = args.keyCode === Keys.ArrowLeft || args.keyCode === Keys.ArrowRight;
        const isReorderingKeyShortcut = isLeftOrRightArrow && isCtrlOrMeta;
        if (isReorderingKeyShortcut && this.isReorderable(column)) {
            args.preventDefault();
            const columnsCount = this.columnInfoService.leafNamedColumns.length;
            const reorderDirection = args.keyCode === Keys.ArrowLeft ? -1 : 1;
            const rtlMultiplier = this.contextService.localization.rtl ? -1 : 1;
            const reorderDirectionOffset = reorderDirection * rtlMultiplier;
            const newIndex = column.leafIndex + reorderDirectionOffset;
            const normalizedNewIndex = Math.min(Math.max(0, newIndex), columnsCount - 1);
            const gridInstance = this.contextService.grid;
            gridInstance.reorderColumn(column, normalizedNewIndex, { before: reorderDirectionOffset < 0 });
            gridInstance.columnReorder.emit(new ColumnReorderEvent({
                column,
                newIndex: normalizedNewIndex,
                oldIndex: column.leafIndex
            }));
            return;
        }
        if (!this.sortable || args.defaultPrevented || column.sortable === false) {
            return;
        }
        if (args.keyCode === Keys.Enter && isPresent(column.field)) {
            const modifier = this.matchModifier(args);
            this.sortService.sort(this.toggleSort(column, modifier));
        }
    }
    showSortNumbering(column) {
        const { showIndexes } = normalize$1(this.sortable);
        return showIndexes
            && this.sort
            && this.sort.filter(({ dir }) => isPresent(dir)).length > 1
            && this.sortOrder(column.field) > 0;
    }
    sortOrder(field) {
        return this.sort
            .filter(({ dir }) => isPresent(dir))
            .findIndex(x => x.field === field)
            + 1;
    }
    sortState(column) {
        if (!this.isInteractive(column, 'sortable')) {
            return;
        }
        const state = this.sortDescriptor(column.field);
        if (state.dir === 'asc') {
            return 'ascending';
        }
        if (state.dir === 'desc') {
            return 'descending';
        }
    }
    get isNavigable() {
        return this.navigationService.tableEnabled;
    }
    /**
     *
     * @param column
     * @param modifier - Indicates whether the client-defined `multiSortKey` modifier is met. Defaults to `true`.
     * @returns - SortDescriptor[]
     */
    toggleSort(column, modifier = true) {
        const { allowUnsort, mode, initialDirection } = normalize$1(this.sortable, column.sortable);
        const descriptor = this.toggleDirection(column.field, allowUnsort, initialDirection);
        if (mode === 'single' || !modifier) {
            return [descriptor];
        }
        return [...this.sort.filter(desc => desc.field !== column.field), descriptor];
    }
    /**
     *
     * Determines whether the modifier key (if any) passed
     * with a click/keyboard event matches the user-defined multiSortKey.
     */
    matchModifier(event) {
        const { multiSortKey } = normalize$1(this.sortable);
        if (multiSortKey === 'none') {
            return modifierKeys.every(key => !event[`${key}Key`]);
        }
        return multiSortKey === 'ctrl'
            ? event.ctrlKey || event.metaKey
            : event[`${multiSortKey}Key`];
    }
    ngAfterViewInit() {
        this.subscription.add(observe(this.dropTargets)
            .subscribe(this.attachTargets.bind(this)));
    }
    ngDoCheck() {
        this._leafColumns = columnsToRender(this.columns || []).filter(x => !isColumnGroupComponent(x));
    }
    ngOnChanges(changes) {
        const sortChange = changes.sort;
        if (sortChange && !sortChange.isFirstChange()) {
            sortChange.currentValue.forEach(change => {
                this.sortedFields[change.field] = true;
            });
        }
    }
    ngOnInit() {
        this.subscription.add(this.contextService.localization.changes
            .subscribe(() => this.cd.markForCheck()));
    }
    ngOnDestroy() {
        if (this.targetSubscription) {
            this.targetSubscription.unsubscribe();
        }
        if (this.popupService) {
            this.popupService.destroy();
        }
        this.subscription.unsubscribe();
    }
    selectAllCheckboxId() {
        return this.idService.selectAllCheckboxId();
    }
    get selectAllCheckboxLabel() {
        return this.contextService.localization.get('selectAllCheckboxLabel');
    }
    isFirstOnRow(column, index) {
        const isTailing = (c) => c &&
            (this.columnsForLevel(c.level).indexOf(c) > 0 || isTailing(c.parent));
        return index === 0 && !this.groups.length && !this.detailTemplate && isTailing(column.parent);
    }
    logicalColumnIndex(column) {
        const index = column.leafIndex;
        if (isPresent(index)) {
            return index + (isPresent(this.detailTemplate) ? 1 : 0);
        }
        return -1;
    }
    get showFilterMenu() {
        return !this.columnMenu && hasFilterMenu(this.filterable);
    }
    get showFilterRow() {
        return hasFilterRow(this.filterable);
    }
    showColumnMenu(column) {
        return this.columnMenu && column.columnMenu &&
            (this.columnMenuTemplate || column.columnMenuTemplates.length || hasItems(this.columnMenu, column));
    }
    isFilterable(column) {
        return !isNullOrEmptyString(column.field) && column.filterable === true;
    }
    canDrop(draggable, target) {
        isDocumentAvailable() && this.zone.runOutsideAngular(() => {
            document.addEventListener('pointerup', e => {
                this.stopSorting = true;
                setTimeout(() => this.stopSorting = false);
            }, {
                once: true,
                capture: true
            });
        });
        return this.reorderable && rules({ draggable, target });
    }
    shouldActivate(column) {
        const canReorder = this.isReorderable(column);
        if (!canReorder && !isColumnComponent(column)) {
            return false;
        }
        const groupable = this.isGroupable(column);
        return groupable || canReorder;
    }
    isInteractive(column, prop) {
        return !isNullOrEmptyString(column.field)
            && isTruthy(this[prop]) && isTruthy(column[prop]);
    }
    isCheckboxColumn(column) {
        return isCheckboxColumn(column) && !column.templateRef;
    }
    trackByIndex(index, _item) {
        return index;
    }
    addStickyStyles(column) {
        const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
        return { ...column.headerStyle, ...stickyStyles };
    }
    toggleDirection(field, allowUnsort, initialDirection) {
        const descriptor = this.sortDescriptor(field);
        const [first, second] = directions(initialDirection);
        let dir = first;
        if (descriptor.dir === first) {
            dir = second;
        }
        else if (descriptor.dir === second && allowUnsort) {
            dir = undefined;
        }
        return { dir, field };
    }
    columnsForLevel(level) {
        const columns = this.columns ? this.columns.filter(column => column.level === level) : [];
        return sortColumns(columnsToRender(columns));
    }
    isColumnGroupComponent(column) {
        return isColumnGroupComponent(column);
    }
    sortDescriptor(field) {
        return this.sort.find(item => item.field === field) || { field };
    }
    get columnLevels() {
        return new Array((this.totalColumnLevels || 0) + 1);
    }
    get leafColumns() {
        return this._leafColumns;
    }
    isReorderable(column) {
        return this.reorderable && column.reorderable;
    }
    isGroupable(column) {
        return this.groupable && isColumnComponent(column) && column.groupable !== false;
    }
    attachTargets() {
        if (this.targetSubscription) {
            this.targetSubscription.unsubscribe();
        }
        this.targetSubscription = new Subscription();
        const enterStream = merge(...this.dropTargets.map(target => target.enter));
        const leaveStream = merge(...this.dropTargets.map(target => target.leave));
        const dropStream = merge(...this.dropTargets.map(target => target.drop));
        this.targetSubscription.add(enterStream.pipe(tap(({ target, draggable }) => {
            if (draggable.context.type === 'groupIndicator') {
                return;
            }
            const targetLocked = isTruthy(target.context.column.isLocked);
            const draggableLocked = isTruthy(draggable.context.column.isLocked);
            if (this.lockedColumnsCount > 0 || targetLocked || draggableLocked) {
                this.hint.toggleLock(targetLocked);
            }
        }), filter(({ draggable, target }) => this.canDrop(draggable, target)), switchMap(this.trackMove.bind(this, leaveStream, dropStream)), map((e) => mergeObjects(e, { before: this.calculateBefore(e), changeContainer: e.changeContainer })), map(this.normalizeTarget.bind(this)), tap(this.enter.bind(this)), switchMap((args) => dropStream.pipe(map(() => args), takeUntil(leaveStream.pipe(tap(this.leave.bind(this)))))))
            .subscribe(this.drop.bind(this)));
    }
    normalizeTarget(e) {
        let target = e.target;
        const parent = target.context.column.parent;
        if (parent && parent.isSpanColumn) {
            const arr = this.dropTargets.toArray();
            const firstSpan = arr.find(t => t.context.column.parent === parent);
            const index = arr.indexOf(firstSpan);
            const adjust = e.before ? 0 : parent.childColumns.length - 1;
            target = arr[index + adjust];
        }
        return mergeObjects(e, { target });
    }
    trackMove(leaveStream, dropStream, e) {
        const column = e.target.context.column;
        const levelColumns = this.columnsForLevel(column.level);
        const index = levelColumns.indexOf(column);
        const isFirst = (column.locked ? index === levelColumns.length - 1 : index === 0);
        const changed = e.draggable.context.column.isLocked !== column.isLocked;
        if (changed && isFirst) {
            return e.draggable.drag
                .pipe(takeUntil(leaveStream), takeUntil(dropStream), map(({ mouseEvent }) => mergeObjects({ changeContainer: true }, e, { mouseEvent })));
        }
        return of(mergeObjects({ changeContainer: changed }, e));
    }
    calculateBefore({ draggable, target, mouseEvent, changeContainer = false }) {
        const targetElement = target.element.nativeElement;
        let before = false;
        if (changeContainer) {
            const { left } = offset(targetElement);
            const halfWidth = targetElement.offsetWidth / 2;
            const middle = left + halfWidth;
            before = middle > mouseEvent.pageX;
            if (this.contextService.localization.rtl) {
                before = !before;
            }
        }
        else {
            before = isTargetBefore(draggable.element.nativeElement, targetElement);
        }
        return before;
    }
    enter({ target, before }) {
        this.hint.enable();
        if (this.contextService.localization.rtl) {
            before = !before;
        }
        this.cue.position(position(target.element.nativeElement, before));
    }
    leave() {
        this.hint.disable();
        this.cue.hide();
    }
    drop({ draggable, target, before, changeContainer }) {
        this.reorderService.reorder({
            before,
            changeContainer,
            source: draggable.context.column,
            target: target.context.column
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: HeaderComponent, deps: [{ token: SinglePopupService }, { token: DragHintService }, { token: DropCueService }, { token: ColumnReorderService }, { token: IdService }, { token: SortService }, { token: ColumnInfoService }, { token: i0.ChangeDetectorRef }, { token: ContextService }, { token: NavigationService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: HeaderComponent, isStandalone: true, selector: "[kendoGridHeader]", inputs: { totalColumnLevels: "totalColumnLevels", columns: "columns", groups: "groups", detailTemplate: "detailTemplate", scrollable: "scrollable", filterable: "filterable", sort: "sort", filter: "filter", sortable: "sortable", groupable: "groupable", lockedColumnsCount: "lockedColumnsCount", resizable: "resizable", reorderable: "reorderable", columnMenu: "columnMenu", columnMenuTemplate: "columnMenuTemplate", totalColumnsCount: "totalColumnsCount", totalColumns: "totalColumns", tabIndex: "tabIndex", size: "size" }, host: { properties: { "class.k-grid-header": "this.headerClass", "class.k-table-thead": "this.hostClass" } }, viewQueries: [{ propertyName: "dropTargets", predicate: DropTargetDirective, descendants: true }, { propertyName: "filterMenus", predicate: FilterMenuComponent, descendants: true }, { propertyName: "columnMenus", predicate: ColumnMenuComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <ng-container>
        <tr *ngFor="let i of columnLevels; let levelIndex = index"
            kendoGridLogicalRow
                [logicalRowIndex]="levelIndex"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount"
                [totalColumns]="totalColumns">
            <th
                class="k-group-cell k-header k-table-th"
                role="presentation"
                *ngFor="let g of groups">
            </th>
            <th class="k-hierarchy-cell k-header k-table-th"
                role="presentation"
                *ngIf="detailTemplate?.templateRef"
            >
            </th>
            <ng-container *ngFor="let column of columnsForLevel(levelIndex); trackBy: trackByIndex; let columnIndex = index; let last = last;">
                <th *ngIf="!isColumnGroupComponent(column)"
                    kendoGridLogicalCell
                    [logicalRowIndex]="levelIndex"
                    [logicalColIndex]="logicalColumnIndex(column)"
                    [headerLabelText]="column.title || getColumnComponent(column).field"
                    [colSpan]="column.colspan"
                    [rowSpan]="column.rowspan(totalColumnLevels)"
                    role="columnheader"
                    aria-selected="false"
                    [attr.aria-sort]="sortState(getColumnComponent(column))"
                    [class.k-sorted]="!!sortState(getColumnComponent(column))"
                    (keydown)="onHeaderKeydown(getColumnComponent(column), $event)"
                    kendoDropTarget
                    kendoDraggable
                    kendoDraggableColumn
                    [enableDrag]="shouldActivate(column)"
                    [context]="{
                        field: getColumnComponent(column).field,
                        type: 'column',
                        column: column,
                        hint: column.title || getColumnComponent(column).field,
                        lastColumn: last && columnIndex === 0
                    }"
                    class="k-header k-table-th"
                    [class.k-filterable]="(showFilterMenu && isFilterable(getColumnComponent(column))) || showColumnMenu(column)"
                    [class.k-first]="isFirstOnRow(getColumnComponent(column), columnIndex)"
                    [class.k-grid-header-sticky]="column.sticky"
                    [ngClass]="column.headerClass"
                    [ngStyle]="column.sticky ? addStickyStyles(column) : column.headerStyle"
                    [attr.rowspan]="column.rowspan(totalColumnLevels)"
                    [attr.colspan]="column.colspan"
                    [attr.aria-haspopup]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? 'dialog' : undefined"
                    [attr.aria-expanded]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? false : undefined"
                    [attr.aria-keyshortcuts]="isNavigable ? 'Alt + ArrowDown' : undefined">

                    <ng-container *ngIf="!isInteractive(getColumnComponent(column), 'sortable')">
                        <span class="k-cell-inner">
                            <span class="k-link" [class.!k-cursor-default]="!isInteractive(getColumnComponent(column), 'groupable') && !isInteractive(getColumnComponent(column), 'reorderable')">
                                <ng-template
                                    [templateContext]="{
                                        templateRef: column.headerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                                </ng-template>
                                <ng-container *ngIf="!column.headerTemplateRef">
                                    <span class="k-column-title">{{column.displayTitle}}</span>
                                </ng-container>
                            </span>
                            <kendo-grid-filter-menu
                                *ngIf="showFilterMenu && isFilterable(getColumnComponent(column))"
                                [column]="getColumnComponent(column)"
                                [filter]="filter"
                                [tabIndex]="tabIndex">
                            </kendo-grid-filter-menu>
                            <kendo-grid-column-menu *ngIf="showColumnMenu(column)"
                                [standalone]="false"
                                [settings]="columnMenuSettings"
                                [column]="column"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [sort]="sort"
                                [filter]="filter"
                                [sortable]="sortable"
                                [tabIndex]="tabIndex">
                            </kendo-grid-column-menu>
                        </span>
                    </ng-container>

                    <ng-container *ngIf="isInteractive(getColumnComponent(column), 'sortable')">
                        <span class="k-cell-inner">
                            <span #link class="k-link" (click)="onSortClick(getColumnComponent(column), $event, link)">
                                <ng-template
                                    [templateContext]="{
                                        templateRef: column.headerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                                </ng-template>
                                <ng-container *ngIf="!column.headerTemplateRef">
                                    <span class="k-column-title">{{column.displayTitle}}</span>
                                </ng-container>
                                <span [class.k-sort-icon]="sortDescriptor(getColumnComponent(column).field).dir">
                                    <kendo-icon-wrapper
                                        *ngIf="sortDescriptor(getColumnComponent(column).field).dir"
                                        role="note" [attr.aria-label]="sortableLabel"
                                        name="sort-{{sortDescriptor(getColumnComponent(column).field).dir}}-small"
                                        [svgIcon]="sortDescriptor(getColumnComponent(column).field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon"
                                        ></kendo-icon-wrapper>
                                </span>
                                <span *ngIf="showSortNumbering(getColumnComponent(column))" class="k-sort-order">{{sortOrder(getColumnComponent(column).field)}}</span>
                            </span>
                            <kendo-grid-filter-menu
                                *ngIf="showFilterMenu && isFilterable(getColumnComponent(column))"
                                [column]="getColumnComponent(column)"
                                [filter]="filter"
                                [tabIndex]="tabIndex">
                            </kendo-grid-filter-menu>
                            <kendo-grid-column-menu *ngIf="showColumnMenu(column)"
                                [standalone]="false"
                                [settings]="columnMenuSettings"
                                [column]="column"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [sort]="sort"
                                [filter]="filter"
                                [sortable]="sortable"
                                [tabIndex]="tabIndex">
                            </kendo-grid-column-menu>
                        </span>
                    </ng-container>

                    <ng-container *ngIf="isCheckboxColumn(column) && !column.headerTemplateRef && $any(column).showSelectAll">
                        <kendo-checkbox
                            [attr.id]="selectAllCheckboxId()"
                            [inputAttributes]="{'aria-label': selectAllCheckboxLabel}"
                            kendoGridSelectAllCheckbox
                            kendoGridFocusable
                        ></kendo-checkbox>
                    </ng-container>
                    <span kendoGridColumnHandle
                        kendoDraggable
                        class="k-column-resizer"
                        *ngIf="resizable"
                        [column]="column"
                        [columns]="columns">
                    </span>
                </th>
                <th *ngIf="isColumnGroupComponent(column)"
                    kendoGridLogicalCell
                    [logicalRowIndex]="levelIndex"
                    [logicalColIndex]="logicalColumnIndex(column)"
                    [rowSpan]="column.rowspan(totalColumnLevels)"
                    [colSpan]="column.colspan"
                    [headerLabelText]="column.title || getColumnComponent(column).field"
                    kendoDropTarget
                    kendoDraggable
                    kendoDraggableColumn
                    [enableDrag]="shouldActivate(column)"
                    [context]="{
                        type: 'columnGroup',
                        column: column,
                        hint: column.title,
                        lastColumn: last && columnIndex === 0
                    }"
                    class="k-header k-table-th"
                    [class.k-first]="isFirstOnRow(getColumnComponent(column), columnIndex)"
                    [class.k-filterable]="showColumnMenu(column)"
                    [class.k-grid-content-sticky]="column.sticky"
                    [ngClass]="column.headerClass"
                    [ngStyle]="column.headerStyle"
                    [attr.rowspan]="column.rowspan(totalColumnLevels)"
                    [attr.colspan]="column.colspan">
                    <span class="k-cell-inner">
                        <span class="k-link">
                            <ng-template
                                [templateContext]="{
                                    templateRef: column.headerTemplateRef,
                                    columnIndex: lockedColumnsCount + columnIndex,
                                    column: column,
                                    $implicit: column
                                }">
                            </ng-template>
                            <ng-container *ngIf="!column.headerTemplateRef">
                                <span class="k-column-title">{{column.displayTitle}}</span>
                            </ng-container>
                        </span>
                        <kendo-grid-column-menu *ngIf="showColumnMenu(column)"
                            [standalone]="false"
                            [settings]="columnMenuSettings"
                            [column]="column"
                            [columnMenuTemplate]="columnMenuTemplate">
                        </kendo-grid-column-menu>
                    </span>
                    <span kendoGridColumnHandle
                        kendoDraggable
                        class="k-column-resizer"
                        *ngIf="resizable"
                        [column]="column"
                        [columns]="columns">
                    </span>
                </th>
            </ng-container>
        </tr>
        <tr *ngIf="showFilterRow"
            kendoGridFilterRow
                [columns]="leafColumns"
                [filter]="filter"
                [groups]="groups"
                [detailTemplate]="detailTemplate"
                [lockedColumnsCount]="lockedColumnsCount"
            kendoGridLogicalRow
                [logicalRowIndex]="totalColumnLevels + 1"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount"
                [totalColumns]="totalColumns"
        ></tr>
    </ng-container>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: LogicalRowDirective, selector: "[kendoGridLogicalRow]", inputs: ["logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "dataRowIndex", "dataItem", "totalColumns"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: LogicalCellDirective, selector: "[kendoGridLogicalCell]", inputs: ["logicalColIndex", "logicalRowIndex", "logicalSlaveCell", "colIndex", "colSpan", "rowSpan", "groupItem", "dataRowIndex", "dataItem", "detailExpandCell", "headerLabelText"] }, { kind: "directive", type: DropTargetDirective, selector: "[kendoDropTarget]", inputs: ["context"], outputs: ["enter", "leave", "drop"] }, { kind: "directive", type: DraggableDirective, selector: "[kendoDraggable]", inputs: ["enableDrag"], outputs: ["kendoPress", "kendoDrag", "kendoRelease"] }, { kind: "directive", type: DraggableColumnDirective, selector: "[kendoDraggableColumn]", inputs: ["context", "enableDrag"], outputs: ["drag"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: TemplateContextDirective, selector: "[templateContext]", inputs: ["templateContext"] }, { kind: "component", type: FilterMenuComponent, selector: "kendo-grid-filter-menu", inputs: ["column", "filter", "tabIndex"] }, { kind: "component", type: ColumnMenuComponent, selector: "kendo-grid-column-menu", inputs: ["standalone", "column", "settings", "sort", "filter", "sortable", "columnMenuTemplate", "tabIndex"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: SelectAllCheckboxDirective, selector: "[kendoGridSelectAllCheckbox]", inputs: ["state"], outputs: ["selectAllChange"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: ["kendoGridFocusable"] }, { kind: "directive", type: ColumnHandleDirective, selector: "[kendoGridColumnHandle]", inputs: ["columns", "column"] }, { kind: "component", type: FilterRowComponent, selector: "[kendoGridFilterRow]", inputs: ["columns", "filter", "groups", "detailTemplate", "logicalRowIndex", "lockedColumnsCount"] }, { kind: "component", type: CheckBoxComponent, selector: "kendo-checkbox", inputs: ["checkedState", "rounded"], outputs: ["checkedStateChange"], exportAs: ["kendoCheckBox"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: HeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridHeader]',
                    template: `
    <ng-container>
        <tr *ngFor="let i of columnLevels; let levelIndex = index"
            kendoGridLogicalRow
                [logicalRowIndex]="levelIndex"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount"
                [totalColumns]="totalColumns">
            <th
                class="k-group-cell k-header k-table-th"
                role="presentation"
                *ngFor="let g of groups">
            </th>
            <th class="k-hierarchy-cell k-header k-table-th"
                role="presentation"
                *ngIf="detailTemplate?.templateRef"
            >
            </th>
            <ng-container *ngFor="let column of columnsForLevel(levelIndex); trackBy: trackByIndex; let columnIndex = index; let last = last;">
                <th *ngIf="!isColumnGroupComponent(column)"
                    kendoGridLogicalCell
                    [logicalRowIndex]="levelIndex"
                    [logicalColIndex]="logicalColumnIndex(column)"
                    [headerLabelText]="column.title || getColumnComponent(column).field"
                    [colSpan]="column.colspan"
                    [rowSpan]="column.rowspan(totalColumnLevels)"
                    role="columnheader"
                    aria-selected="false"
                    [attr.aria-sort]="sortState(getColumnComponent(column))"
                    [class.k-sorted]="!!sortState(getColumnComponent(column))"
                    (keydown)="onHeaderKeydown(getColumnComponent(column), $event)"
                    kendoDropTarget
                    kendoDraggable
                    kendoDraggableColumn
                    [enableDrag]="shouldActivate(column)"
                    [context]="{
                        field: getColumnComponent(column).field,
                        type: 'column',
                        column: column,
                        hint: column.title || getColumnComponent(column).field,
                        lastColumn: last && columnIndex === 0
                    }"
                    class="k-header k-table-th"
                    [class.k-filterable]="(showFilterMenu && isFilterable(getColumnComponent(column))) || showColumnMenu(column)"
                    [class.k-first]="isFirstOnRow(getColumnComponent(column), columnIndex)"
                    [class.k-grid-header-sticky]="column.sticky"
                    [ngClass]="column.headerClass"
                    [ngStyle]="column.sticky ? addStickyStyles(column) : column.headerStyle"
                    [attr.rowspan]="column.rowspan(totalColumnLevels)"
                    [attr.colspan]="column.colspan"
                    [attr.aria-haspopup]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? 'dialog' : undefined"
                    [attr.aria-expanded]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? false : undefined"
                    [attr.aria-keyshortcuts]="isNavigable ? 'Alt + ArrowDown' : undefined">

                    <ng-container *ngIf="!isInteractive(getColumnComponent(column), 'sortable')">
                        <span class="k-cell-inner">
                            <span class="k-link" [class.!k-cursor-default]="!isInteractive(getColumnComponent(column), 'groupable') && !isInteractive(getColumnComponent(column), 'reorderable')">
                                <ng-template
                                    [templateContext]="{
                                        templateRef: column.headerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                                </ng-template>
                                <ng-container *ngIf="!column.headerTemplateRef">
                                    <span class="k-column-title">{{column.displayTitle}}</span>
                                </ng-container>
                            </span>
                            <kendo-grid-filter-menu
                                *ngIf="showFilterMenu && isFilterable(getColumnComponent(column))"
                                [column]="getColumnComponent(column)"
                                [filter]="filter"
                                [tabIndex]="tabIndex">
                            </kendo-grid-filter-menu>
                            <kendo-grid-column-menu *ngIf="showColumnMenu(column)"
                                [standalone]="false"
                                [settings]="columnMenuSettings"
                                [column]="column"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [sort]="sort"
                                [filter]="filter"
                                [sortable]="sortable"
                                [tabIndex]="tabIndex">
                            </kendo-grid-column-menu>
                        </span>
                    </ng-container>

                    <ng-container *ngIf="isInteractive(getColumnComponent(column), 'sortable')">
                        <span class="k-cell-inner">
                            <span #link class="k-link" (click)="onSortClick(getColumnComponent(column), $event, link)">
                                <ng-template
                                    [templateContext]="{
                                        templateRef: column.headerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                                </ng-template>
                                <ng-container *ngIf="!column.headerTemplateRef">
                                    <span class="k-column-title">{{column.displayTitle}}</span>
                                </ng-container>
                                <span [class.k-sort-icon]="sortDescriptor(getColumnComponent(column).field).dir">
                                    <kendo-icon-wrapper
                                        *ngIf="sortDescriptor(getColumnComponent(column).field).dir"
                                        role="note" [attr.aria-label]="sortableLabel"
                                        name="sort-{{sortDescriptor(getColumnComponent(column).field).dir}}-small"
                                        [svgIcon]="sortDescriptor(getColumnComponent(column).field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon"
                                        ></kendo-icon-wrapper>
                                </span>
                                <span *ngIf="showSortNumbering(getColumnComponent(column))" class="k-sort-order">{{sortOrder(getColumnComponent(column).field)}}</span>
                            </span>
                            <kendo-grid-filter-menu
                                *ngIf="showFilterMenu && isFilterable(getColumnComponent(column))"
                                [column]="getColumnComponent(column)"
                                [filter]="filter"
                                [tabIndex]="tabIndex">
                            </kendo-grid-filter-menu>
                            <kendo-grid-column-menu *ngIf="showColumnMenu(column)"
                                [standalone]="false"
                                [settings]="columnMenuSettings"
                                [column]="column"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [sort]="sort"
                                [filter]="filter"
                                [sortable]="sortable"
                                [tabIndex]="tabIndex">
                            </kendo-grid-column-menu>
                        </span>
                    </ng-container>

                    <ng-container *ngIf="isCheckboxColumn(column) && !column.headerTemplateRef && $any(column).showSelectAll">
                        <kendo-checkbox
                            [attr.id]="selectAllCheckboxId()"
                            [inputAttributes]="{'aria-label': selectAllCheckboxLabel}"
                            kendoGridSelectAllCheckbox
                            kendoGridFocusable
                        ></kendo-checkbox>
                    </ng-container>
                    <span kendoGridColumnHandle
                        kendoDraggable
                        class="k-column-resizer"
                        *ngIf="resizable"
                        [column]="column"
                        [columns]="columns">
                    </span>
                </th>
                <th *ngIf="isColumnGroupComponent(column)"
                    kendoGridLogicalCell
                    [logicalRowIndex]="levelIndex"
                    [logicalColIndex]="logicalColumnIndex(column)"
                    [rowSpan]="column.rowspan(totalColumnLevels)"
                    [colSpan]="column.colspan"
                    [headerLabelText]="column.title || getColumnComponent(column).field"
                    kendoDropTarget
                    kendoDraggable
                    kendoDraggableColumn
                    [enableDrag]="shouldActivate(column)"
                    [context]="{
                        type: 'columnGroup',
                        column: column,
                        hint: column.title,
                        lastColumn: last && columnIndex === 0
                    }"
                    class="k-header k-table-th"
                    [class.k-first]="isFirstOnRow(getColumnComponent(column), columnIndex)"
                    [class.k-filterable]="showColumnMenu(column)"
                    [class.k-grid-content-sticky]="column.sticky"
                    [ngClass]="column.headerClass"
                    [ngStyle]="column.headerStyle"
                    [attr.rowspan]="column.rowspan(totalColumnLevels)"
                    [attr.colspan]="column.colspan">
                    <span class="k-cell-inner">
                        <span class="k-link">
                            <ng-template
                                [templateContext]="{
                                    templateRef: column.headerTemplateRef,
                                    columnIndex: lockedColumnsCount + columnIndex,
                                    column: column,
                                    $implicit: column
                                }">
                            </ng-template>
                            <ng-container *ngIf="!column.headerTemplateRef">
                                <span class="k-column-title">{{column.displayTitle}}</span>
                            </ng-container>
                        </span>
                        <kendo-grid-column-menu *ngIf="showColumnMenu(column)"
                            [standalone]="false"
                            [settings]="columnMenuSettings"
                            [column]="column"
                            [columnMenuTemplate]="columnMenuTemplate">
                        </kendo-grid-column-menu>
                    </span>
                    <span kendoGridColumnHandle
                        kendoDraggable
                        class="k-column-resizer"
                        *ngIf="resizable"
                        [column]="column"
                        [columns]="columns">
                    </span>
                </th>
            </ng-container>
        </tr>
        <tr *ngIf="showFilterRow"
            kendoGridFilterRow
                [columns]="leafColumns"
                [filter]="filter"
                [groups]="groups"
                [detailTemplate]="detailTemplate"
                [lockedColumnsCount]="lockedColumnsCount"
            kendoGridLogicalRow
                [logicalRowIndex]="totalColumnLevels + 1"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount"
                [totalColumns]="totalColumns"
        ></tr>
    </ng-container>
    `,
                    standalone: true,
                    imports: [
                        NgFor, LogicalRowDirective, NgIf, LogicalCellDirective, DropTargetDirective, DraggableDirective, DraggableColumnDirective,
                        NgClass, NgStyle, TemplateContextDirective, FilterMenuComponent, ColumnMenuComponent, IconWrapperComponent, SelectAllCheckboxDirective,
                        FocusableDirective, ColumnHandleDirective, FilterRowComponent, CheckBoxComponent
                    ]
                }]
        }], ctorParameters: function () { return [{ type: SinglePopupService }, { type: DragHintService }, { type: DropCueService }, { type: ColumnReorderService }, { type: IdService }, { type: SortService }, { type: ColumnInfoService }, { type: i0.ChangeDetectorRef }, { type: ContextService }, { type: NavigationService }, { type: i0.NgZone }]; }, propDecorators: { totalColumnLevels: [{
                type: Input
            }], columns: [{
                type: Input
            }], groups: [{
                type: Input
            }], detailTemplate: [{
                type: Input
            }], scrollable: [{
                type: Input
            }], filterable: [{
                type: Input
            }], sort: [{
                type: Input
            }], filter: [{
                type: Input
            }], sortable: [{
                type: Input
            }], groupable: [{
                type: Input
            }], lockedColumnsCount: [{
                type: Input
            }], resizable: [{
                type: Input
            }], reorderable: [{
                type: Input
            }], columnMenu: [{
                type: Input
            }], columnMenuTemplate: [{
                type: Input
            }], totalColumnsCount: [{
                type: Input
            }], totalColumns: [{
                type: Input
            }], tabIndex: [{
                type: Input
            }], size: [{
                type: Input
            }], headerClass: [{
                type: HostBinding,
                args: ['class.k-grid-header']
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-table-thead']
            }], dropTargets: [{
                type: ViewChildren,
                args: [DropTargetDirective]
            }], filterMenus: [{
                type: ViewChildren,
                args: [FilterMenuComponent]
            }], columnMenus: [{
                type: ViewChildren,
                args: [ColumnMenuComponent]
            }] } });

/**
 * @hidden
 */
class FooterComponent {
    columnInfoService;
    columns = [];
    groups = [];
    detailTemplate;
    scrollable;
    lockedColumnsCount = 0;
    logicalRowIndex = 0;
    totalColumns;
    get footerClass() {
        return !this.scrollable;
    }
    hostClass = true;
    hostRole = 'rowgroup';
    constructor(columnInfoService) {
        this.columnInfoService = columnInfoService;
    }
    get columnsToRender() {
        return columnsToRender(this.columns || []);
    }
    trackByIndex(index, _item) {
        return index;
    }
    logicalColumnIndex(column) {
        const index = column.leafIndex;
        if (isPresent(index)) {
            return index + (isPresent(this.detailTemplate) ? 1 : 0);
        }
        return -1;
    }
    addStickyStyles(column) {
        const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
        return { ...column.footerStyle, ...stickyStyles };
    }
    isColumnGroupComponent(column) {
        return isColumnGroupComponent(column);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FooterComponent, deps: [{ token: ColumnInfoService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: FooterComponent, isStandalone: true, selector: "[kendoGridFooter]", inputs: { columns: "columns", groups: "groups", detailTemplate: "detailTemplate", scrollable: "scrollable", lockedColumnsCount: "lockedColumnsCount", logicalRowIndex: "logicalRowIndex", totalColumns: "totalColumns" }, host: { properties: { "class.k-grid-footer": "this.footerClass", "class.k-table-tfoot": "this.hostClass", "attr.role": "this.hostRole" } }, ngImport: i0, template: `
    <ng-container>
        <tr
            [class.k-footer-template]="true"
            kendoGridLogicalRow
                [logicalRowIndex]="logicalRowIndex"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="columns.length - lockedColumnsCount"
                [totalColumns]="totalColumns"
            >
            <td
                class="k-table-td k-group-cell k-table-group-td"
                role="presentation"
                *ngFor="let g of groups">
            </td>
            <td
                role="presentation"
                class="k-table-td k-hierarchy-cell"
                *ngIf="detailTemplate?.templateRef">
            </td>
            <ng-container *ngFor="let column of columnsToRender; let columnIndex = index; trackBy: trackByIndex;">
                <td *ngIf="!isColumnGroupComponent(column)"
                    kendoGridLogicalCell
                    class="k-table-td"
                        [logicalRowIndex]="logicalRowIndex"
                        [logicalColIndex]="logicalColumnIndex(column)"
                        role="gridcell"
                        aria-selected="false"
                    [class.k-grid-footer-sticky]="column.sticky"
                    [ngClass]="column.footerClass"
                    [ngStyle]="column.sticky ? addStickyStyles(column) : column.footerStyle">
                    <ng-template
                        [templateContext]="{
                            templateRef: column.footerTemplateRef,
                            columnIndex: column.leafIndex,
                            column: column,
                            $implicit: column
                        }">
                    </ng-template>
                </td>
            </ng-container>
        </tr>
    </ng-container>
    `, isInline: true, dependencies: [{ kind: "directive", type: LogicalRowDirective, selector: "[kendoGridLogicalRow]", inputs: ["logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "dataRowIndex", "dataItem", "totalColumns"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: LogicalCellDirective, selector: "[kendoGridLogicalCell]", inputs: ["logicalColIndex", "logicalRowIndex", "logicalSlaveCell", "colIndex", "colSpan", "rowSpan", "groupItem", "dataRowIndex", "dataItem", "detailExpandCell", "headerLabelText"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: TemplateContextDirective, selector: "[templateContext]", inputs: ["templateContext"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FooterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridFooter]',
                    template: `
    <ng-container>
        <tr
            [class.k-footer-template]="true"
            kendoGridLogicalRow
                [logicalRowIndex]="logicalRowIndex"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="columns.length - lockedColumnsCount"
                [totalColumns]="totalColumns"
            >
            <td
                class="k-table-td k-group-cell k-table-group-td"
                role="presentation"
                *ngFor="let g of groups">
            </td>
            <td
                role="presentation"
                class="k-table-td k-hierarchy-cell"
                *ngIf="detailTemplate?.templateRef">
            </td>
            <ng-container *ngFor="let column of columnsToRender; let columnIndex = index; trackBy: trackByIndex;">
                <td *ngIf="!isColumnGroupComponent(column)"
                    kendoGridLogicalCell
                    class="k-table-td"
                        [logicalRowIndex]="logicalRowIndex"
                        [logicalColIndex]="logicalColumnIndex(column)"
                        role="gridcell"
                        aria-selected="false"
                    [class.k-grid-footer-sticky]="column.sticky"
                    [ngClass]="column.footerClass"
                    [ngStyle]="column.sticky ? addStickyStyles(column) : column.footerStyle">
                    <ng-template
                        [templateContext]="{
                            templateRef: column.footerTemplateRef,
                            columnIndex: column.leafIndex,
                            column: column,
                            $implicit: column
                        }">
                    </ng-template>
                </td>
            </ng-container>
        </tr>
    </ng-container>
    `,
                    standalone: true,
                    imports: [LogicalRowDirective, NgFor, NgIf, LogicalCellDirective, NgClass, NgStyle, TemplateContextDirective]
                }]
        }], ctorParameters: function () { return [{ type: ColumnInfoService }]; }, propDecorators: { columns: [{
                type: Input
            }], groups: [{
                type: Input
            }], detailTemplate: [{
                type: Input
            }], scrollable: [{
                type: Input
            }], lockedColumnsCount: [{
                type: Input
            }], logicalRowIndex: [{
                type: Input
            }], totalColumns: [{
                type: Input
            }], footerClass: [{
                type: HostBinding,
                args: ['class.k-grid-footer']
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-table-tfoot']
            }], hostRole: [{
                type: HostBinding,
                args: ['attr.role']
            }] } });

/**
 * Represents the command columns of the Grid. You have to define the content of the
 * column inside an `<ng-template>` tag.
 * For more information and examples, refer to the [Command Column Directives](slug:editing_directives_grid#toc-command-column-directives) article.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData">
 *   <kendo-grid-column field="ProductID"></kendo-grid-column>
 *   <kendo-grid-command-column title="command" [width]="220">
 *      <ng-template kendoGridCellTemplate>
 *         <button kendoGridEditCommand class="k-primary">Edit</button>
 *         <button kendoGridRemoveCommand>Remove</button>
 *      </ng-template>
 *   </kendo-grid-command-column>
 * </kendo-grid>
 * ```
 */
class CommandColumnComponent extends ColumnBase {
    parent;
    template;
    constructor(parent, idService) {
        super(parent, idService);
        this.parent = parent;
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CommandColumnComponent, deps: [{ token: ColumnBase, host: true, optional: true, skipSelf: true }, { token: IdService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: CommandColumnComponent, isStandalone: true, selector: "kendo-grid-command-column", providers: [
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => CommandColumnComponent)
            }
        ], queries: [{ propertyName: "template", first: true, predicate: CellTemplateDirective, descendants: true }], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CommandColumnComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: ColumnBase,
                            useExisting: forwardRef(() => CommandColumnComponent)
                        }
                    ],
                    selector: 'kendo-grid-command-column',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ColumnBase, decorators: [{
                    type: SkipSelf
                }, {
                    type: Host
                }, {
                    type: Optional
                }] }, { type: IdService, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { template: [{
                type: ContentChild,
                args: [CellTemplateDirective, { static: false }]
            }] } });

/**
 * Represents the checkbox column for selecting rows in the Grid. [See example](slug:grid_row_selection#toc-select-all-checkbox).
 *
 * @example
 * ```html
 * <kendo-grid [selectable]="{enabled: true, checkboxOnly: true}">
 *   <kendo-grid-checkbox-column title="Default checkbox"></kendo-grid-checkbox-column>
 *   <kendo-grid-column field="ProductID"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class CheckboxColumnComponent extends ColumnBase {
    selectionService;
    cellSelectionService;
    parent;
    /**
     * Determines whether a select-all `kendoGridSelectAllCheckbox` checkbox will be displayed in the header.
     */
    showSelectAll;
    /**
     * Determines whether checkboxes will be rendered for rows which are marked as non-selectable. By default, such checkboxes are visible and disabled.
     */
    showDisabledCheckbox = true;
    /*
     * @hidden
     */
    isCheckboxColumn = true;
    template;
    constructor(selectionService, cellSelectionService, parent, idService) {
        super(parent, idService);
        this.selectionService = selectionService;
        this.cellSelectionService = cellSelectionService;
        this.parent = parent;
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
    /**
     * @hidden
     */
    rowSelectable(rowIdx) {
        return !this.selectionService.nonSelectableRows.has(rowIdx) && !this.cellSelectionService.nonSelectableRows.has(rowIdx);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CheckboxColumnComponent, deps: [{ token: SelectionService }, { token: CellSelectionService }, { token: ColumnBase, host: true, optional: true, skipSelf: true }, { token: IdService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: CheckboxColumnComponent, isStandalone: true, selector: "kendo-grid-checkbox-column", inputs: { showSelectAll: "showSelectAll", showDisabledCheckbox: "showDisabledCheckbox" }, providers: [
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => CheckboxColumnComponent)
            }
        ], queries: [{ propertyName: "template", first: true, predicate: CellTemplateDirective, descendants: true }], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CheckboxColumnComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: ColumnBase,
                            useExisting: forwardRef(() => CheckboxColumnComponent)
                        }
                    ],
                    selector: 'kendo-grid-checkbox-column',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: SelectionService }, { type: CellSelectionService }, { type: ColumnBase, decorators: [{
                    type: SkipSelf
                }, {
                    type: Host
                }, {
                    type: Optional
                }] }, { type: IdService, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { showSelectAll: [{
                type: Input
            }], showDisabledCheckbox: [{
                type: Input
            }], template: [{
                type: ContentChild,
                args: [CellTemplateDirective, { static: false }]
            }] } });

/**
 * Represents the row-selection checkbox of the Grid. The directive expects the
 * index of the current row as an input parameter. Inside the [`CellTemplateDirective`](slug:api_grid_celltemplatedirective), apply the
 * `kendoGridSelectionCheckbox` to a `<kendo-checkbox></kendo-checkbox>` or an `<input type="checkbox"/>` element. When the user clicks the checkbox that is associated
 * with the directive, a [selectionChange](slug:api_grid_gridcomponent#toc-selectionChange)
 * event is triggered.
 *
 * @example
 * ```html
 * <kendo-grid ... >
 *   <kendo-grid-column>
 *     <ng-template kendoGridCellTemplate let-rowIndex="rowIndex">
 *       <input ... [kendoGridSelectionCheckbox]="rowIndex"/>
 *     </ng-template>
 *   </kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class SelectionCheckboxDirective {
    selectionService;
    cellSelectionService;
    aggregateService;
    el;
    renderer;
    ngZone;
    checkbox;
    /**
     * The current index of the `dataItem` that will be selected.
     */
    itemIndex;
    destroyClick;
    destroyKeyDown;
    ngAfterContentChecked() {
        this.setCheckedState();
    }
    constructor(selectionService, cellSelectionService, aggregateService, el, renderer, ngZone, checkbox) {
        this.selectionService = selectionService;
        this.cellSelectionService = cellSelectionService;
        this.aggregateService = aggregateService;
        this.el = el;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.checkbox = checkbox;
        this.ngZone.runOutsideAngular(() => {
            this.destroyClick = this.renderer.listen(this.el.nativeElement, 'click', this.onClick.bind(this));
            this.destroyKeyDown = this.renderer.listen(this.el.nativeElement, 'keydown', this.onKeyDown.bind(this));
        });
    }
    ngOnDestroy() {
        if (this.destroyClick) {
            this.destroyClick();
        }
        if (this.destroyKeyDown) {
            this.destroyKeyDown();
        }
    }
    onClick(event) {
        const nonSelectableRow = this.selectionService.nonSelectableRows.has(this.itemIndex) || this.cellSelectionService.nonSelectableRows.has(this.itemIndex);
        if (nonSelectableRow || this.cellSelectionService.options.cell) {
            event.preventDefault();
            return;
        }
        if (this.selectionService.options.enabled) {
            this.ngZone.run(() => {
                let ev;
                const ctrlKey = event.ctrlKey || event.metaKey;
                if (event.shiftKey) {
                    const item = { index: this.itemIndex };
                    ev = this.selectionService.addAllTo(item, ctrlKey);
                }
                else {
                    ev = this.selectionService.toggleByIndex(this.itemIndex);
                }
                ev.ctrlKey = event.ctrlKey;
                ev.shiftKey = event.shiftKey;
                if (this.selectionService.options.cellAggregates) {
                    ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
                }
                this.selectionService.changes.emit(ev);
            });
        }
    }
    onKeyDown(e) {
        if (e.keyCode === Keys.Enter) {
            this.onClick(e);
        }
    }
    /*
     * @hidden
     */
    setCheckedState() {
        const isSelected = this.selectionService.nonSelectableRows.has(this.itemIndex) ? false : this.selectionService.isSelected(this.itemIndex);
        if (this.checkbox) {
            this.checkbox.checkedState = isSelected;
        }
        else {
            this.renderer.setProperty(this.el.nativeElement, 'checked', isSelected);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SelectionCheckboxDirective, deps: [{ token: SelectionService }, { token: CellSelectionService }, { token: CellSelectionAggregateService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: i3.CheckBoxComponent, host: true, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: SelectionCheckboxDirective, isStandalone: true, selector: "[kendoGridSelectionCheckbox]", inputs: { itemIndex: ["kendoGridSelectionCheckbox", "itemIndex"] }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SelectionCheckboxDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridSelectionCheckbox]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: SelectionService }, { type: CellSelectionService }, { type: CellSelectionAggregateService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: i3.CheckBoxComponent, decorators: [{
                    type: Host
                }, {
                    type: Optional
                }] }]; }, propDecorators: { itemIndex: [{
                type: Input,
                args: ['kendoGridSelectionCheckbox']
            }] } });

/**
 * @hidden
 */
class ChangeNotificationService {
    ngZone;
    changes = new EventEmitter();
    subscription;
    constructor(ngZone) {
        this.ngZone = ngZone;
    }
    notify() {
        if (!this.subscription || this.subscription.closed) {
            this.subscription = this.ngZone.onStable
                .asObservable().pipe(take(1))
                .subscribe(() => this.changes.emit());
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ChangeNotificationService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ChangeNotificationService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ChangeNotificationService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });

/**
 * Represents the no-records template of the Grid. Provides an option to customize the
 * appearance of the item that is displayed when no data is present.
 * To define the no-records template, nest an `<ng-template>` tag with the `kendoGridNoRecordsTemplate`
 * directive inside `<kendo-grid>` [see example](slug:norecordtemplate_grid).
 *
 * @example
 * ```html
 * <kendo-grid [data]="data">
 *   <ng-template kendoGridNoRecordsTemplate>
 *     There are not products. <a href="#" (click)="refresh()">Click here to refresh</a>.
 *   </ng-template>
 *   <kendo-grid-column field="ProductID"></kendo-grid-column>
 *   <kendo-grid-column field="ProductName"></kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class NoRecordsTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NoRecordsTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: NoRecordsTemplateDirective, isStandalone: true, selector: "[kendoGridNoRecordsTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NoRecordsTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridNoRecordsTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * @hidden
 */
function defaultTrackBy(index, item) {
    if (item.type === 'data' && item.isEditing) {
        return item.data;
    }
    return index;
}

/**
 * @hidden
 */
const NON_DATA_CELL_CLASSES = 'k-hierarchy-cell k-detail-cell k-group-cell';
/**
 * @hidden
 */
const NON_DATA_ROW_CLASSES = 'k-grouping-row k-group-footer k-detail-row k-grid-norecords';
/**
 * @hidden
 */
const IGNORE_TARGET_CLASSSES = 'k-icon k-svg-icon';
/**
 * @hidden
 */
const IGNORE_CONTAINER_CLASSES = 'k-grid k-grid-ignore-click';

/**
 * @hidden
 */
class CellComponent {
    editService;
    idService;
    ctx;
    cellContext;
    get commandCellClass() {
        return this.isCommand(this.column);
    }
    get dragHandleCellClass() {
        return isRowReorderColumn(this.column);
    }
    get dragRowHandleLabel() {
        return isRowReorderColumn(this.column) ? this.ctx.localization.get('dragRowHandleLabel') : undefined;
    }
    column;
    columnIndex;
    isNew = false;
    isLoading = false;
    isVirtual = false;
    loadingTemplate;
    set rowIndex(index) {
        this._rowIndex = index;
        this.updateCellContext();
    }
    get rowIndex() {
        return this._rowIndex;
    }
    dataItem;
    reorderIcon = reorderIcon;
    get isEdited() {
        if (!(this.editService.isEditing() || this.isNew) || !this.isColumnEditable) {
            return false;
        }
        const editContext = this.editService.columnContext(this.rowIndex, this.column);
        return this.isFieldEditable(editContext, this.column);
    }
    get showLoading() {
        return this.isVirtual && this.isLoading;
    }
    get formGroup() {
        return this.editService.context(this.rowIndex).group;
    }
    get templateContext() {
        return this._templateContext;
    }
    get editTemplateContext() {
        this._editTemplateContext.$implicit = this.formGroup;
        this._editTemplateContext.isNew = this.isNew;
        this._editTemplateContext.column = this.column;
        this._editTemplateContext.dataItem = this.dataItem;
        this._editTemplateContext.formGroup = this.formGroup;
        this._editTemplateContext.rowIndex = this.rowIndex;
        return this._editTemplateContext;
    }
    get format() {
        if (isColumnComponent(this.column) && !isNullOrEmptyString(this.column.format)) {
            return extractFormat(this.column.format);
        }
        return undefined;
    }
    get isBoundColumn() {
        return this.column.field && !this.column.templateRef;
    }
    get isCheckboxColumn() {
        return isCheckboxColumn(this.column) && !this.column.templateRef;
    }
    get selectionCheckboxId() {
        return this.idService.selectionCheckboxId(this.rowIndex);
    }
    get selectionCheckboxLabel() {
        return this.ctx.localization.get('selectionCheckboxLabel');
    }
    get isSpanColumn() {
        return isSpanColumn(this.column) && !this.column.templateRef;
    }
    get childColumns() {
        return columnsToRender([this.column]);
    }
    get isRowReorderColumn() {
        return isRowReorderColumn(this.column) && !this.column.templateRef;
    }
    get isRowSelectable() {
        return this.column.rowSelectable(this._rowIndex);
    }
    _rowIndex;
    get isColumnEditable() {
        if (!this.column || this.isCommand(this.column)) {
            return false;
        }
        return this.column.editable !== false;
    }
    _templateContext = {};
    _editTemplateContext = {};
    constructor(editService, idService, ctx, cellContext) {
        this.editService = editService;
        this.idService = idService;
        this.ctx = ctx;
        this.cellContext = cellContext;
    }
    ngDoCheck() {
        this.updateCellContext();
    }
    ngOnChanges(_changes) {
        this.updateTemplateContext();
    }
    ngAfterContentChecked() {
        this.updateTemplateContext();
    }
    isCommand(column) {
        return column instanceof CommandColumnComponent;
    }
    isFieldEditable(editContext, column) {
        if (!isPresent(editContext)) {
            return false;
        }
        if (isPresent(column.editTemplate)) {
            return true;
        }
        return isPresent(editContext.group) && isPresent(editContext.group.get(column.field));
    }
    updateCellContext() {
        if (this.cellContext) {
            this.cellContext.rowIndex = this._rowIndex;
        }
    }
    updateTemplateContext() {
        if (!this.column.templateRef) {
            return;
        }
        const context = this._templateContext;
        context.isNew = this.isNew;
        context.column = this.column;
        context.dataItem = this.dataItem;
        context.rowIndex = this.rowIndex;
        context.columnIndex = this.columnIndex;
        context.$implicit = this.dataItem;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CellComponent, deps: [{ token: EditService }, { token: IdService }, { token: ContextService }, { token: CELL_CONTEXT, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: CellComponent, isStandalone: true, selector: "[kendoGridCell]", inputs: { column: "column", columnIndex: "columnIndex", isNew: "isNew", isLoading: "isLoading", isVirtual: "isVirtual", loadingTemplate: "loadingTemplate", rowIndex: "rowIndex", dataItem: "dataItem" }, host: { properties: { "class.k-command-cell": "this.commandCellClass", "class.k-drag-cell": "this.dragHandleCellClass", "class.k-touch-action-none": "this.dragHandleCellClass", "attr.aria-label": "this.dragRowHandleLabel" } }, usesOnChanges: true, ngImport: i0, template: `
        <ng-container [ngSwitch]="isEdited">
            <ng-container *ngSwitchCase="false">
                <ng-container *ngIf="!showLoading; else loading">
                    <ng-template *ngIf="column.templateRef"
                        [ngTemplateOutlet]="column.templateRef"
                        [ngTemplateOutletContext]="templateContext">
                    </ng-template>
                    <ng-container *ngIf="isSpanColumn">
                        <ng-container *ngFor="let childColumn of childColumns">
                            {{ dataItem | valueOf: childColumn.field: childColumn.format}}
                        </ng-container>
                    </ng-container>
                    <ng-container *ngIf="isBoundColumn">{{ dataItem | valueOf: column.field: column.format}}</ng-container>
                    <ng-container *ngIf="isCheckboxColumn && !isNew">
                        <ng-container *ngIf="isRowSelectable; else nonSelectableRow">
                            <kendo-checkbox
                                [kendoGridSelectionCheckbox]="rowIndex"
                                [attr.id]="selectionCheckboxId"
                                [inputAttributes]="{'aria-label': selectionCheckboxLabel}">
                            </kendo-checkbox>
                        </ng-container>
                        <ng-template #nonSelectableRow>
                            <kendo-checkbox *ngIf="column.showDisabledCheckbox"
                                [kendoGridSelectionCheckbox]="rowIndex"
                                [attr.id]="selectionCheckboxId"
                                [inputAttributes]="{'aria-label': selectionCheckboxLabel}"
                                [disabled]="true"
                            ></kendo-checkbox>
                        </ng-template>
                    </ng-container>
                    <ng-container *ngIf="isRowReorderColumn && !isNew">
                        <kendo-icon-wrapper
                            name="reorder"
                            [svgIcon]="reorderIcon">
                        </kendo-icon-wrapper>
                    </ng-container>
                </ng-container>
                <ng-template #loading>
                    <ng-template
                        *ngIf="loadingTemplate"
                        [ngTemplateOutlet]="loadingTemplate"
                        [ngTemplateOutletContext]="{$implicit: column}">
                    </ng-template>
                    <div *ngIf="!loadingTemplate" class="k-skeleton-text k-skeleton"></div>
                </ng-template>
            </ng-container>
            <ng-container *ngSwitchCase="true">
                <ng-template
                    *ngIf="column.editTemplateRef"
                    [ngTemplateOutlet]="column.editTemplateRef"
                    [ngTemplateOutletContext]="editTemplateContext">
                </ng-template>
                <ng-container [ngSwitch]="column.editor" *ngIf="!column.editTemplateRef">
                    <kendo-numerictextbox
                        *ngSwitchCase="'numeric'"
                        [format]="format"
                        [formControl]="$any(formGroup.get(column.field))"
                        kendoGridFocusable
                    ></kendo-numerictextbox>

                    <kendo-datepicker
                        *ngSwitchCase="'date'"
                        [format]="format"
                        [formControl]="$any(formGroup.get(column.field))"
                        kendoGridFocusable
                    ></kendo-datepicker>

                    <kendo-checkbox
                        *ngSwitchCase="'boolean'"
                        [formControl]="$any(formGroup.get(column.field))"
                        kendoGridFocusable
                    ></kendo-checkbox>

                    <kendo-textbox
                        *ngSwitchDefault
                        [formControl]="$any(formGroup.get(column.field))"
                        kendoGridFocusable
                    ></kendo-textbox>
                </ng-container>
            </ng-container>
        </ng-container>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoGridFocusable],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridCancelCommand],\n        [kendoGridSelectionCheckbox]\n    ", inputs: ["kendoGridFocusable"] }, { kind: "directive", type: SelectionCheckboxDirective, selector: "[kendoGridSelectionCheckbox]", inputs: ["kendoGridSelectionCheckbox"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "component", type: NumericTextBoxComponent, selector: "kendo-numerictextbox", inputs: ["focusableId", "disabled", "readonly", "title", "autoCorrect", "format", "max", "min", "decimals", "placeholder", "step", "spinners", "rangeValidation", "tabindex", "tabIndex", "changeValueOnScroll", "selectOnFocus", "value", "maxlength", "size", "rounded", "fillMode", "inputAttributes"], outputs: ["valueChange", "focus", "blur", "inputFocus", "inputBlur"], exportAs: ["kendoNumericTextBox"] }, { kind: "component", type: DatePickerComponent, selector: "kendo-datepicker", inputs: ["focusableId", "cellTemplate", "clearButton", "inputAttributes", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "navigationItemTemplate", "weekDaysFormat", "showOtherMonthDays", "activeView", "bottomView", "topView", "calendarType", "animateCalendarNavigation", "disabled", "readonly", "readOnlyInput", "popupSettings", "navigation", "min", "max", "incompleteDateValidation", "autoCorrectParts", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "autoFill", "focusedDate", "value", "format", "twoDigitYearMax", "formatPlaceholder", "placeholder", "tabindex", "tabIndex", "disabledDates", "title", "subtitle", "rangeValidation", "disabledDatesValidation", "weekNumber", "size", "rounded", "fillMode", "adaptiveMode"], outputs: ["valueChange", "focus", "blur", "open", "close", "escape"], exportAs: ["kendo-datepicker"] }, { kind: "directive", type: NgSwitchDefault, selector: "[ngSwitchDefault]" }, { kind: "pipe", type: FieldAccessorPipe, name: "valueOf" }, { kind: "ngmodule", type: ReactiveFormsModule }, { kind: "directive", type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i4.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "component", type: CheckBoxComponent, selector: "kendo-checkbox", inputs: ["checkedState", "rounded"], outputs: ["checkedStateChange"], exportAs: ["kendoCheckBox"] }, { kind: "component", type: TextBoxComponent, selector: "kendo-textbox", inputs: ["focusableId", "title", "type", "disabled", "readonly", "tabindex", "value", "selectOnFocus", "showSuccessIcon", "showErrorIcon", "clearButton", "successIcon", "successSvgIcon", "errorIcon", "errorSvgIcon", "clearButtonIcon", "clearButtonSvgIcon", "size", "rounded", "fillMode", "tabIndex", "placeholder", "maxlength", "inputAttributes"], outputs: ["valueChange", "inputFocus", "inputBlur", "focus", "blur"], exportAs: ["kendoTextBox"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridCell]',
                    template: `
        <ng-container [ngSwitch]="isEdited">
            <ng-container *ngSwitchCase="false">
                <ng-container *ngIf="!showLoading; else loading">
                    <ng-template *ngIf="column.templateRef"
                        [ngTemplateOutlet]="column.templateRef"
                        [ngTemplateOutletContext]="templateContext">
                    </ng-template>
                    <ng-container *ngIf="isSpanColumn">
                        <ng-container *ngFor="let childColumn of childColumns">
                            {{ dataItem | valueOf: childColumn.field: childColumn.format}}
                        </ng-container>
                    </ng-container>
                    <ng-container *ngIf="isBoundColumn">{{ dataItem | valueOf: column.field: column.format}}</ng-container>
                    <ng-container *ngIf="isCheckboxColumn && !isNew">
                        <ng-container *ngIf="isRowSelectable; else nonSelectableRow">
                            <kendo-checkbox
                                [kendoGridSelectionCheckbox]="rowIndex"
                                [attr.id]="selectionCheckboxId"
                                [inputAttributes]="{'aria-label': selectionCheckboxLabel}">
                            </kendo-checkbox>
                        </ng-container>
                        <ng-template #nonSelectableRow>
                            <kendo-checkbox *ngIf="column.showDisabledCheckbox"
                                [kendoGridSelectionCheckbox]="rowIndex"
                                [attr.id]="selectionCheckboxId"
                                [inputAttributes]="{'aria-label': selectionCheckboxLabel}"
                                [disabled]="true"
                            ></kendo-checkbox>
                        </ng-template>
                    </ng-container>
                    <ng-container *ngIf="isRowReorderColumn && !isNew">
                        <kendo-icon-wrapper
                            name="reorder"
                            [svgIcon]="reorderIcon">
                        </kendo-icon-wrapper>
                    </ng-container>
                </ng-container>
                <ng-template #loading>
                    <ng-template
                        *ngIf="loadingTemplate"
                        [ngTemplateOutlet]="loadingTemplate"
                        [ngTemplateOutletContext]="{$implicit: column}">
                    </ng-template>
                    <div *ngIf="!loadingTemplate" class="k-skeleton-text k-skeleton"></div>
                </ng-template>
            </ng-container>
            <ng-container *ngSwitchCase="true">
                <ng-template
                    *ngIf="column.editTemplateRef"
                    [ngTemplateOutlet]="column.editTemplateRef"
                    [ngTemplateOutletContext]="editTemplateContext">
                </ng-template>
                <ng-container [ngSwitch]="column.editor" *ngIf="!column.editTemplateRef">
                    <kendo-numerictextbox
                        *ngSwitchCase="'numeric'"
                        [format]="format"
                        [formControl]="$any(formGroup.get(column.field))"
                        kendoGridFocusable
                    ></kendo-numerictextbox>

                    <kendo-datepicker
                        *ngSwitchCase="'date'"
                        [format]="format"
                        [formControl]="$any(formGroup.get(column.field))"
                        kendoGridFocusable
                    ></kendo-datepicker>

                    <kendo-checkbox
                        *ngSwitchCase="'boolean'"
                        [formControl]="$any(formGroup.get(column.field))"
                        kendoGridFocusable
                    ></kendo-checkbox>

                    <kendo-textbox
                        *ngSwitchDefault
                        [formControl]="$any(formGroup.get(column.field))"
                        kendoGridFocusable
                    ></kendo-textbox>
                </ng-container>
            </ng-container>
        </ng-container>
    `,
                    standalone: true,
                    imports: [NgSwitch, NgSwitchCase, NgIf, NgTemplateOutlet, NgFor, FocusableDirective, SelectionCheckboxDirective,
                        IconWrapperComponent, NumericTextBoxComponent, DatePickerComponent, NgSwitchDefault, FieldAccessorPipe, ReactiveFormsModule, CheckBoxComponent, TextBoxComponent]
                }]
        }], ctorParameters: function () { return [{ type: EditService }, { type: IdService }, { type: ContextService }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [CELL_CONTEXT]
                }] }]; }, propDecorators: { commandCellClass: [{
                type: HostBinding,
                args: ['class.k-command-cell']
            }], dragHandleCellClass: [{
                type: HostBinding,
                args: ['class.k-drag-cell']
            }, {
                type: HostBinding,
                args: ['class.k-touch-action-none']
            }], dragRowHandleLabel: [{
                type: HostBinding,
                args: ['attr.aria-label']
            }], column: [{
                type: Input
            }], columnIndex: [{
                type: Input
            }], isNew: [{
                type: Input
            }], isLoading: [{
                type: Input
            }], isVirtual: [{
                type: Input
            }], loadingTemplate: [{
                type: Input
            }], rowIndex: [{
                type: Input
            }], dataItem: [{
                type: Input
            }] } });

const columnCellIndex = (cell, cells) => {
    let cellIndex = 0;
    for (let idx = 0; idx < cells.length; idx++) {
        if (cells[idx] === cell) {
            return cellIndex;
        }
        if (!hasClasses(cells[idx], 'k-hierarchy-cell k-group-cell')) {
            cellIndex++;
        }
    }
};
/**
 * @hidden
 */
class TableBodyComponent {
    detailsService;
    groupsService;
    changeNotification;
    editService;
    ctx;
    ngZone;
    renderer;
    element;
    domEvents;
    selectionService;
    cellSelectionService;
    columnInfoService;
    navigationService;
    columns = [];
    allColumns;
    groups = [];
    detailTemplate;
    noRecordsTemplate;
    data;
    skip = 0;
    selectable;
    filterable;
    noRecordsText;
    isLocked = false;
    isLoading;
    isVirtual;
    cellLoadingTemplate;
    skipGroupDecoration = false;
    showGroupFooters = false;
    lockedColumnsCount = 0;
    totalColumnsCount = 0;
    virtualColumns;
    trackBy = defaultTrackBy;
    rowSticky;
    totalColumns;
    hostClass = true;
    groupHeaderSlaveCellsCount;
    groupHeaderColumns;
    clickSubscription;
    touchSubscription;
    l10nSubscription;
    cellKeydownSubscription;
    clickTimeout;
    minusIcon = minusIcon;
    plusIcon = plusIcon;
    rowClass = () => null;
    constructor(detailsService, groupsService, changeNotification, editService, ctx, ngZone, renderer, element, domEvents, selectionService, cellSelectionService, columnInfoService, navigationService) {
        this.detailsService = detailsService;
        this.groupsService = groupsService;
        this.changeNotification = changeNotification;
        this.editService = editService;
        this.ctx = ctx;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.element = element;
        this.domEvents = domEvents;
        this.selectionService = selectionService;
        this.cellSelectionService = cellSelectionService;
        this.columnInfoService = columnInfoService;
        this.navigationService = navigationService;
        this.noRecordsText = this.ctx.localization.get('noRecords');
        this.cellKeydownSubscription = this.navigationService.cellKeydown.subscribe((args) => this.cellKeydownHandler(args));
        this.trackByWrapper = this.trackByWrapper.bind(this);
        this.trackByColumns = this.trackByColumns.bind(this);
    }
    get newDataItem() {
        return this.editService.newDataItem;
    }
    // Number of unlocked columns in the next table, if any
    unlockedColumnsCount(item) {
        const allColumns = this.allColumns || this.columns;
        let allColumnsCount = allColumns.length;
        allColumns.forEach(column => {
            if (column.isSpanColumn) {
                allColumnsCount += column.colspan - 1;
            }
        });
        const contentColumnsCount = this.totalColumnsCount - this.lockedColumnsCount - allColumnsCount;
        const headerFooterColumnsCount = this.totalColumnsCount - this.lockedColumnsCount - (this.allColumns || this.columns).length;
        return item && this.isDataItem(item) ? contentColumnsCount : headerFooterColumnsCount;
    }
    isAriaSelected(item, column) {
        return this.cellSelectionService.isCellSelected(item, column) ||
            this.isRowSelected(item) ? 'true' : 'false';
    }
    toggleRow(index, dataItem) {
        this.detailsService.toggleRow(index, dataItem);
        return false;
    }
    isExpanded(viewItem) {
        return this.detailsService.isExpanded(viewItem.index, viewItem.data);
    }
    detailButtonIconName(viewItem) {
        const expanded = this.isExpanded(viewItem);
        return expanded ? 'minus' : 'plus';
    }
    detailButtonSvgIcon(viewItem) {
        const expanded = this.isExpanded(viewItem);
        return expanded ? this.minusIcon : this.plusIcon;
    }
    detailButtonTitle(viewItem) {
        const messageKey = this.isExpanded(viewItem) ? 'detailCollapse' : 'detailExpand';
        return this.ctx.localization.get(messageKey);
    }
    isGroup(item) {
        return item.type === 'group';
    }
    isDataItem(item) {
        return !this.isGroup(item) && !this.isFooter(item);
    }
    isFooter(item) {
        return item.type === 'footer';
    }
    isFooterItemInExpandedGroup(item) {
        const footerItem = { data: item.data, index: item.groupIndex, parentGroup: item.group.parentGroup };
        return this.isInExpandedGroup(footerItem);
    }
    isDataItemInExpandedGroup(item) {
        const dataItem = { data: item.group.data, index: item.groupIndex, parentGroup: item.group.parentGroup };
        return this.isInExpandedGroup(dataItem);
    }
    isInExpandedGroup(item) {
        return this.groupsService.isInExpandedGroup(item);
    }
    isParentGroupExpanded(item) {
        return this.groupsService.isInExpandedGroup(item.parentGroup);
    }
    isOdd(item) {
        return item.index % 2 !== 0;
    }
    isSelectable(args) {
        const rowSelectable = this.isRowSelectable(args);
        const selectionEnabled = this.selectable && this.selectable.enabled !== false;
        return selectionEnabled && rowSelectable;
    }
    isRowSelected(item) {
        return this.selectionService.isSelected(item.index);
    }
    isRowSelectable(args) {
        return this.selectionService.settings?.isRowSelectable(args) || this.cellSelectionService.settings?.isRowSelectable(args);
    }
    trackByWrapper(index, item) {
        if (item.type === 'data') {
            item.isEditing = this.editService.hasEdited(item.index);
        }
        return this.trackBy(index, item);
    }
    trackByColumns(index, item) {
        return this.virtualColumns ? index : item;
    }
    ngDoCheck() {
        if (this.hasGroupHeaderColumn) {
            this.groupHeaderColumns = columnsToRender(this.skipGroupDecoration ? this.columns : this.columns.toArray().slice(1));
        }
        else {
            this.groupHeaderColumns = [];
        }
        if (this.isLocked) {
            this.groupHeaderSlaveCellsCount =
                this.hasGroupHeaderColumn ? this.columnsContainer.nonLockedColumnsToRender.length : 1;
        }
        else {
            this.groupHeaderSlaveCellsCount = 0;
        }
    }
    ngAfterViewChecked() {
        if (this.rowSticky) {
            this.applyStickyRowsStyling();
        }
    }
    ngOnChanges(changes) {
        if (isChanged$1('columns', changes, false)) {
            this.changeNotification.notify();
        }
    }
    logicalRowIndex(rowIndex) {
        let pos = this.skip + rowIndex;
        if (this.hasDetailTemplate) {
            pos *= 2;
        }
        const absoluteRowIndex = 1 + pos;
        const addRowOffset = this.editService.hasNewItem ? 1 : 0;
        const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;
        const headerRowCount = this.columnInfoService.totalLevels + filterRowOffset + addRowOffset;
        return absoluteRowIndex + headerRowCount;
    }
    addRowLogicalIndex() {
        return this.columnInfoService.totalLevels + 1 +
            (hasFilterRow(this.filterable) ? 1 : 0);
    }
    logicalColIndex(column) {
        if (!isPresent(column.leafIndex)) {
            return -1;
        }
        return column.leafIndex + (this.hasDetailTemplate ? 1 : 0);
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            const clickHandler = this.clickHandler.bind(this);
            const mousedownSubscription = this.renderer.listen(this.element.nativeElement, 'mousedown', clickHandler);
            const mouseupSubscription = this.renderer.listen(this.element.nativeElement, 'mouseup', clickHandler);
            const clickSubscription = this.renderer.listen(this.element.nativeElement, 'click', clickHandler);
            const contextmenuSubscription = this.renderer.listen(this.element.nativeElement, 'contextmenu', clickHandler);
            const touchstartSubscription = this.renderer.listen(this.element.nativeElement, 'touchstart', clickHandler);
            const touchendSubscription = this.renderer.listen(this.element.nativeElement, 'touchend', clickHandler);
            this.clickSubscription = () => {
                mousedownSubscription();
                mouseupSubscription();
                clickSubscription();
                contextmenuSubscription();
            };
            this.touchSubscription = () => {
                touchstartSubscription();
                touchendSubscription();
            };
        });
        let originalNoRecordText = this.ctx.localization.get('noRecords');
        this.l10nSubscription = this.ctx.localization.changes.subscribe(() => {
            if (this.noRecordsText === originalNoRecordText) {
                this.noRecordsText = this.ctx.localization.get('noRecords');
                originalNoRecordText = this.noRecordsText;
            }
        });
    }
    ngOnDestroy() {
        if (this.clickSubscription) {
            this.clickSubscription();
        }
        if (this.touchSubscription) {
            this.touchSubscription();
        }
        if (this.l10nSubscription) {
            this.l10nSubscription.unsubscribe();
        }
        this.cellKeydownSubscription.unsubscribe();
        clearTimeout(this.clickTimeout);
    }
    isEditingCell(index, column) {
        return this.editService.isEditing() && this.editService.isEditedColumn(index, column);
    }
    isEditingRow(index) {
        return this.editService.isEditing() && this.editService.hasEdited(index);
    }
    get hasGroupHeaderColumn() {
        return this.columnsContainer.hasGroupHeaderColumn;
    }
    get columnsContainer() {
        return this.columnInfoService.columnsContainer;
    }
    get columnsSpan() {
        return columnsSpan(this.columns);
    }
    get allColumnsSpan() {
        return columnsSpan(this.allColumns || this.columns);
    }
    get colSpan() {
        return this.columnsSpan + this.groups.length + (this.hasDetailTemplate ? 1 : 0);
    }
    get footerColumns() {
        const colsToRender = Array.from(this.columns).reduce((cols, col) => {
            const newCols = (col instanceof SpanColumnComponent) ? Array.from(col.childColumns) : [col];
            return [...cols, ...newCols];
        }, []);
        return colsToRender;
    }
    showGroupHeader(item) {
        return !item.data.skipHeader;
    }
    addStickyColumnStyles(column) {
        const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
        return { ...column.style, ...stickyStyles };
    }
    resizeHandler() {
        this.applyStickyRowsStyling();
    }
    get hasDetailTemplate() {
        return isPresent(this.detailTemplate);
    }
    clickHandler(eventArg) {
        const element = this.element.nativeElement;
        const target = this.eventTarget(eventArg);
        let cell, row, body, gridElement;
        let currentTarget = target;
        do {
            cell = closest(currentTarget, matchesNodeName('td'));
            row = closest(cell, matchesNodeName('tr'));
            body = closest(row, matchesNodeName('tbody'));
            currentTarget = body;
            gridElement = closestInScope(currentTarget, matchesClasses('k-grid'), element);
        } while (body && body !== element && !gridElement);
        if (cell && !hasClasses(cell, NON_DATA_CELL_CLASSES) &&
            !hasClasses(row, NON_DATA_ROW_CLASSES) &&
            body === element && !gridElement) {
            this.editService.preventCellClose();
            const focusable = target !== cell && isFocusableWithTabKey(target, false);
            if (!focusable && !matchesNodeName('label')(target) && !hasClasses(target, IGNORE_TARGET_CLASSSES) &&
                !closestInScope(target, matchesClasses(IGNORE_CONTAINER_CLASSES), cell)) {
                const args = this.cellClickArgs(cell, row, eventArg);
                const selectionEnabled = this.selectable && this.selectable.enabled !== false;
                if (selectionEnabled && !this.isRowSelectable({ index: args.rowIndex, dataItem: args.dataItem })) {
                    return;
                }
                if (eventArg.type === 'mousedown' || eventArg.type === 'touchstart') {
                    this.domEvents.cellMousedown.emit(args);
                }
                else if (eventArg.type === 'mouseup' || eventArg.type === 'touchend') {
                    this.domEvents.cellMouseup.emit(args);
                }
                else {
                    if (args.isEditedColumn || !this.editService.closeCell(eventArg)) {
                        if (eventArg.type === 'click') {
                            this.clickTimeout = setTimeout(() => {
                                this.emitCellClick(args);
                            }, 0);
                        }
                        else {
                            this.emitCellClick(args);
                        }
                    }
                }
            }
        }
    }
    emitCellClick(args) {
        this.domEvents.cellClick.emit(Object.assign(args, {
            isEdited: args.isEditedRow || args.isEditedColumn
        }));
    }
    cellKeydownHandler(args) {
        if (args.keyCode === Keys.Enter) {
            this.clickHandler(args);
        }
    }
    cellClickArgs(cell, row, eventArg) {
        const index = columnCellIndex(cell, row.cells);
        const column = this.columns.toArray()[index];
        const columnIndex = this.lockedColumnsCount + index;
        let rowIndex = row.getAttribute('data-kendo-grid-item-index');
        rowIndex = rowIndex ? parseInt(rowIndex, 10) : -1;
        const dataItem = rowIndex === -1 ? this.editService.newDataItem : this.data.at(rowIndex - this.skip);
        const isEditedColumn = this.editService.isEditedColumn(rowIndex, column);
        const isEditedRow = this.editService.isEdited(rowIndex);
        const type = eventArg.type === 'keydown' ? 'click' : eventArg.type;
        return {
            column: column,
            columnIndex: columnIndex,
            dataItem: dataItem,
            isEditedColumn: isEditedColumn,
            isEditedRow: isEditedRow,
            originalEvent: eventArg,
            rowIndex: rowIndex,
            type: type
        };
    }
    eventTarget(args) {
        if (!isDocumentAvailable()) {
            return;
        }
        if (args.type === 'touchend') {
            const touch = args.changedTouches[0];
            return document.elementFromPoint(touch.clientX, touch.clientY);
        }
        return args.target;
    }
    applyStickyRowsStyling() {
        if (!isDocumentAvailable()) {
            return;
        }
        const stickyRows = nodesToArray(this.element.nativeElement.querySelectorAll('.k-grid-row-sticky'));
        const length = stickyRows.length;
        if (length) {
            let accumulatedHeight = 0;
            const stickyRowsOffsets = [];
            stickyRows.forEach(row => {
                const rowHeight = row.getBoundingClientRect().height;
                stickyRowsOffsets.push({ accumulatedHeight, rowHeight });
                accumulatedHeight += rowHeight;
            });
            stickyRows.forEach((row, index) => {
                this.renderer.setStyle(row, 'top', `${stickyRowsOffsets[index].accumulatedHeight}px`);
                this.renderer.setStyle(row, 'bottom', `${accumulatedHeight - stickyRowsOffsets[index].accumulatedHeight - stickyRowsOffsets[index].rowHeight}px`);
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TableBodyComponent, deps: [{ token: DetailsService }, { token: GroupsService }, { token: ChangeNotificationService }, { token: EditService }, { token: ContextService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: DomEventsService }, { token: SelectionService }, { token: CellSelectionService }, { token: ColumnInfoService }, { token: NavigationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: TableBodyComponent, isStandalone: true, selector: "[kendoGridTableBody]", inputs: { columns: "columns", allColumns: "allColumns", groups: "groups", detailTemplate: "detailTemplate", noRecordsTemplate: "noRecordsTemplate", data: "data", skip: "skip", selectable: "selectable", filterable: "filterable", noRecordsText: "noRecordsText", isLocked: "isLocked", isLoading: "isLoading", isVirtual: "isVirtual", cellLoadingTemplate: "cellLoadingTemplate", skipGroupDecoration: "skipGroupDecoration", showGroupFooters: "showGroupFooters", lockedColumnsCount: "lockedColumnsCount", totalColumnsCount: "totalColumnsCount", virtualColumns: "virtualColumns", trackBy: "trackBy", rowSticky: "rowSticky", totalColumns: "totalColumns", rowClass: "rowClass" }, host: { properties: { "class.k-table-tbody": "this.hostClass" } }, usesOnChanges: true, ngImport: i0, template: `
    <ng-container *ngIf="editService.hasNewItem">
        <tr class="k-grid-add-row k-grid-edit-row k-master-row"
            kendoGridLogicalRow
                [logicalRowIndex]="addRowLogicalIndex()"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount()"
                [totalColumns]="totalColumns">
            <ng-container *ngIf="!skipGroupDecoration">
                <td class="k-group-cell k-table-td k-table-group-td" *ngFor="let g of groups" role="presentation"></td>
            </ng-container>
            <td class="k-hierarchy-cell k-table-td"
                *ngIf="detailTemplate?.templateRef"
                kendoGridLogicalCell
                    [logicalRowIndex]="addRowLogicalIndex()"
                    [logicalColIndex]="0"
                    aria-selected="false"
                >
            </td>
            <td *ngFor="let column of columns; let columnIndex = index; trackBy: trackByColumns;"
                class="k-table-td"
                kendoGridCell
                    [rowIndex]="-1"
                    [columnIndex]="lockedColumnsCount + columnIndex"
                    [isNew]="true"
                    [column]="column"
                    [dataItem]="newDataItem"
                [class.k-grid-content-sticky]="column.sticky"
                [ngClass]="column.cssClass"
                [style.left]="column.sticky ? '0' : undefined"
                [ngStyle]="column.sticky ? addStickyColumnStyles(column) : column.style"
                [attr.colspan]="column.colspan"
                [attr.role]="column.tableCellsRole"
                kendoGridLogicalCell
                    [logicalRowIndex]="addRowLogicalIndex()"
                    [logicalColIndex]="logicalColIndex(column)"
                    [colSpan]="column.colspan">
            </td>
        </tr>
    </ng-container>
    <tr *ngIf="data?.length === 0 || data === null" class="k-grid-norecords" role="row">
        <td [attr.colspan]="colSpan" class="k-table-td">
            <ng-template
                *ngIf="noRecordsTemplate?.templateRef"
                [templateContext]="{
                    templateRef: noRecordsTemplate?.templateRef
                 }">
            </ng-template>
            <ng-container *ngIf="!noRecordsTemplate?.templateRef">
                {{noRecordsText}}
            </ng-container>
        </td>
    </tr>
    <ng-container *ngFor="let item of data; trackBy: trackByWrapper; let rowIndex = index;">
        <tr *ngIf="isGroup(item) && isParentGroupExpanded($any(item)) && showGroupHeader(item)"
            kendoGridGroupHeader
                [columns]="columns"
                [groups]="groups"
                [item]="$any(item)"
                [hasDetails]="!!detailTemplate?.templateRef"
                [skipGroupDecoration]="skipGroupDecoration"
                [hasGroupHeaderColumn]="hasGroupHeaderColumn"
                [groupHeaderColumns]="groupHeaderColumns"
                [rowIndex]="rowIndex + 1"
                [totalColumnsCount]="totalColumnsCount"
            kendoGridLogicalRow
                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [totalColumns]="totalColumns"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="groupHeaderSlaveCellsCount">
        </tr>
        <tr
            *ngIf="isDataItem(item) && (!$any(item).group || isDataItemInExpandedGroup($any(item)))"
            kendoGridLogicalRow
                [dataRowIndex]="$any(item).index"
                [dataItem]="item.data"
                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [totalColumns]="totalColumns"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount(item)"
            class="{{ isOdd(item) ?  'k-alt k-table-alt-row' : ''}}"
            [class.k-grid-row-sticky]="rowSticky ? rowSticky({ dataItem: item.data, index: $any(item).index }) : false"
            [ngClass]="rowClass({ dataItem: item.data, index: $any(item).index })"
            [class.k-master-row]="true"
            [class.k-expanded]="isDataItem(item) && isExpanded(item)"
            [class.k-grid-edit-row]="isEditingRow($any(item).index)"
            [attr.aria-selected]="lockedColumnsCount < 1 ? isSelectable({ dataItem: item.data, index: $any(item).index }) && isRowSelected(item) : undefined"
            [attr.data-kendo-grid-item-index]="$any(item).index"
            [class.k-selected]="isSelectable({ dataItem: item.data, index: $any(item).index }) && isRowSelected(item)">
            <ng-container *ngIf="!skipGroupDecoration">
                <td class="k-group-cell k-table-td k-table-group-td" *ngFor="let g of groups" role="presentation"></td>
            </ng-container>
            <td class="k-hierarchy-cell k-table-td"
                *ngIf="detailTemplate?.templateRef"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="0"
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [detailExpandCell]="true"
                    aria-selected="false"
                    role="gridcell">
                <a
                    *ngIf="detailTemplate.showIf(item.data, $any(item).index)"
                    [attr.title]="detailButtonTitle(item)"
                    [attr.aria-label]="detailButtonTitle(item)"
                    href="#" tabindex="-1" (click)="toggleRow($any(item).index, item.data)">
                    <kendo-icon-wrapper
                        [name]="detailButtonIconName(item)"
                        [svgIcon]="detailButtonSvgIcon(item)"></kendo-icon-wrapper>
                </a>
            </td>
            <td
                kendoGridCell
                    [rowIndex]="$any(item).index"
                    [columnIndex]="lockedColumnsCount + columnIndex"
                    [attr.data-kendo-grid-column-index]="lockedColumnsCount + columnIndex"
                    [column]="column"
                    [dataItem]="item.data"
                    [isLoading]="isLoading"
                    [isVirtual]="isVirtual"
                    [loadingTemplate]="cellLoadingTemplate"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="logicalColIndex(column)"
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [colIndex]="columnIndex"
                    [colSpan]="column.colspan"
                    [attr.role]="column.tableCellsRole"
                    class="k-table-td"
                    [attr.aria-selected]="lockedColumnsCount < 1 && isSelectable({ dataItem: item.data, index: $any(item).index }) ? isAriaSelected(item, column) : undefined"
                    [class.k-grid-content-sticky]="column.sticky"
                    [class.k-touch-action-none]="isSelectable({ dataItem: item.data, index: $any(item).index }) && $any(selectable).drag"
                [ngClass]="column.cssClass"
                [class.k-grid-edit-cell]="isEditingCell($any(item).index, column)"
                [ngStyle]="column.sticky ? addStickyColumnStyles(column) : column.style"
                [attr.colspan]="column.colspan"
                [class.k-selected]="isSelectable && cellSelectionService.isCellSelected(item, column)"
                *ngFor="let column of columns; let columnIndex = index; trackBy: trackByColumns;">
            </td>
        </tr>
        <tr *ngIf="isDataItem(item) &&
                (!$any(item).group || isDataItemInExpandedGroup($any(item))) &&
                detailTemplate?.templateRef &&
                detailTemplate.showIf(item.data, $any(item).index) &&
                isExpanded(item)"
            class="k-detail-row"
            kendoGridLogicalRow
                [dataRowIndex]="$any(item).index"
                [dataItem]="item.data"
                [logicalRowIndex]="logicalRowIndex(rowIndex) + 1"
                [logicalSlaveRow]="false"
                [logicalCellsCount]="1"
            >
            <td class="k-group-cell k-table-td k-table-group-td" *ngFor="let g of groups"></td>
            <td class="k-hierarchy-cell k-table-td"></td>
            <td class="k-detail-cell k-table-td"
                [attr.colspan]="columnsSpan"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex) + 1"
                    [logicalColIndex]="0"
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [colIndex]="0"
                    [colSpan]="allColumnsSpan + 1"
                    role="gridcell" aria-selected="false"
                >
                <ng-template
                    [ngTemplateOutlet]="detailTemplate.templateRef"
                    [ngTemplateOutletContext]="{
                        dataItem: item.data,
                        rowIndex: $any(item).index,
                        $implicit: item.data
                    }">
                </ng-template>
            </td>
        </tr>
        <tr *ngIf="isFooter(item) &&
                $any(item).group &&
                (isFooterItemInExpandedGroup($any(item)) || (showGroupFooters && isParentGroupExpanded($any(item).group))) &&
                !$any(item.data).hideFooter"
            class="k-group-footer"
            kendoGridLogicalRow
                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [totalColumns]="totalColumns"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount(item)">
            <ng-container *ngIf="!skipGroupDecoration">
                <td class="k-group-cell k-table-td k-table-group-td" *ngFor="let g of groups"></td>
            </ng-container>
            <td class="k-hierarchy-cell k-table-td"
                *ngIf="detailTemplate?.templateRef"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="0"
                    aria-selected="false"
                >
            </td>
            <td kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="logicalColIndex(column)"
                [attr.data-skip]="skipGroupDecoration"
                class="k-table-td"
                *ngFor="let column of footerColumns; let columnIndex = index; trackBy: trackByColumns;">
                <ng-template
                    [templateContext]="{
                        templateRef: $any(column).groupFooterTemplateRef,
                        group: $any(item.data),
                        field: $any(column).field,
                        column: column,
                        aggregates: $any(item.data)?.aggregates,
                        $implicit: $any(item.data)?.aggregates
                    }">
                </ng-template>
           </td>
        </tr>
    </ng-container>
    <kendo-resize-sensor *ngIf="rowSticky" (resize)="resizeHandler()"></kendo-resize-sensor>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: LogicalRowDirective, selector: "[kendoGridLogicalRow]", inputs: ["logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "dataRowIndex", "dataItem", "totalColumns"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: LogicalCellDirective, selector: "[kendoGridLogicalCell]", inputs: ["logicalColIndex", "logicalRowIndex", "logicalSlaveCell", "colIndex", "colSpan", "rowSpan", "groupItem", "dataRowIndex", "dataItem", "detailExpandCell", "headerLabelText"] }, { kind: "component", type: CellComponent, selector: "[kendoGridCell]", inputs: ["column", "columnIndex", "isNew", "isLoading", "isVirtual", "loadingTemplate", "rowIndex", "dataItem"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: TemplateContextDirective, selector: "[templateContext]", inputs: ["templateContext"] }, { kind: "component", type: GroupHeaderComponent, selector: "[kendoGridGroupHeader]", inputs: ["rowIndex", "logicalRowIndex", "item", "skipGroupDecoration", "hasDetails", "totalColumnsCount", "hasGroupHeaderColumn", "groupHeaderColumns", "columns", "groups"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TableBodyComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridTableBody]',
                    template: `
    <ng-container *ngIf="editService.hasNewItem">
        <tr class="k-grid-add-row k-grid-edit-row k-master-row"
            kendoGridLogicalRow
                [logicalRowIndex]="addRowLogicalIndex()"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount()"
                [totalColumns]="totalColumns">
            <ng-container *ngIf="!skipGroupDecoration">
                <td class="k-group-cell k-table-td k-table-group-td" *ngFor="let g of groups" role="presentation"></td>
            </ng-container>
            <td class="k-hierarchy-cell k-table-td"
                *ngIf="detailTemplate?.templateRef"
                kendoGridLogicalCell
                    [logicalRowIndex]="addRowLogicalIndex()"
                    [logicalColIndex]="0"
                    aria-selected="false"
                >
            </td>
            <td *ngFor="let column of columns; let columnIndex = index; trackBy: trackByColumns;"
                class="k-table-td"
                kendoGridCell
                    [rowIndex]="-1"
                    [columnIndex]="lockedColumnsCount + columnIndex"
                    [isNew]="true"
                    [column]="column"
                    [dataItem]="newDataItem"
                [class.k-grid-content-sticky]="column.sticky"
                [ngClass]="column.cssClass"
                [style.left]="column.sticky ? '0' : undefined"
                [ngStyle]="column.sticky ? addStickyColumnStyles(column) : column.style"
                [attr.colspan]="column.colspan"
                [attr.role]="column.tableCellsRole"
                kendoGridLogicalCell
                    [logicalRowIndex]="addRowLogicalIndex()"
                    [logicalColIndex]="logicalColIndex(column)"
                    [colSpan]="column.colspan">
            </td>
        </tr>
    </ng-container>
    <tr *ngIf="data?.length === 0 || data === null" class="k-grid-norecords" role="row">
        <td [attr.colspan]="colSpan" class="k-table-td">
            <ng-template
                *ngIf="noRecordsTemplate?.templateRef"
                [templateContext]="{
                    templateRef: noRecordsTemplate?.templateRef
                 }">
            </ng-template>
            <ng-container *ngIf="!noRecordsTemplate?.templateRef">
                {{noRecordsText}}
            </ng-container>
        </td>
    </tr>
    <ng-container *ngFor="let item of data; trackBy: trackByWrapper; let rowIndex = index;">
        <tr *ngIf="isGroup(item) && isParentGroupExpanded($any(item)) && showGroupHeader(item)"
            kendoGridGroupHeader
                [columns]="columns"
                [groups]="groups"
                [item]="$any(item)"
                [hasDetails]="!!detailTemplate?.templateRef"
                [skipGroupDecoration]="skipGroupDecoration"
                [hasGroupHeaderColumn]="hasGroupHeaderColumn"
                [groupHeaderColumns]="groupHeaderColumns"
                [rowIndex]="rowIndex + 1"
                [totalColumnsCount]="totalColumnsCount"
            kendoGridLogicalRow
                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [totalColumns]="totalColumns"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="groupHeaderSlaveCellsCount">
        </tr>
        <tr
            *ngIf="isDataItem(item) && (!$any(item).group || isDataItemInExpandedGroup($any(item)))"
            kendoGridLogicalRow
                [dataRowIndex]="$any(item).index"
                [dataItem]="item.data"
                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [totalColumns]="totalColumns"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount(item)"
            class="{{ isOdd(item) ?  'k-alt k-table-alt-row' : ''}}"
            [class.k-grid-row-sticky]="rowSticky ? rowSticky({ dataItem: item.data, index: $any(item).index }) : false"
            [ngClass]="rowClass({ dataItem: item.data, index: $any(item).index })"
            [class.k-master-row]="true"
            [class.k-expanded]="isDataItem(item) && isExpanded(item)"
            [class.k-grid-edit-row]="isEditingRow($any(item).index)"
            [attr.aria-selected]="lockedColumnsCount < 1 ? isSelectable({ dataItem: item.data, index: $any(item).index }) && isRowSelected(item) : undefined"
            [attr.data-kendo-grid-item-index]="$any(item).index"
            [class.k-selected]="isSelectable({ dataItem: item.data, index: $any(item).index }) && isRowSelected(item)">
            <ng-container *ngIf="!skipGroupDecoration">
                <td class="k-group-cell k-table-td k-table-group-td" *ngFor="let g of groups" role="presentation"></td>
            </ng-container>
            <td class="k-hierarchy-cell k-table-td"
                *ngIf="detailTemplate?.templateRef"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="0"
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [detailExpandCell]="true"
                    aria-selected="false"
                    role="gridcell">
                <a
                    *ngIf="detailTemplate.showIf(item.data, $any(item).index)"
                    [attr.title]="detailButtonTitle(item)"
                    [attr.aria-label]="detailButtonTitle(item)"
                    href="#" tabindex="-1" (click)="toggleRow($any(item).index, item.data)">
                    <kendo-icon-wrapper
                        [name]="detailButtonIconName(item)"
                        [svgIcon]="detailButtonSvgIcon(item)"></kendo-icon-wrapper>
                </a>
            </td>
            <td
                kendoGridCell
                    [rowIndex]="$any(item).index"
                    [columnIndex]="lockedColumnsCount + columnIndex"
                    [attr.data-kendo-grid-column-index]="lockedColumnsCount + columnIndex"
                    [column]="column"
                    [dataItem]="item.data"
                    [isLoading]="isLoading"
                    [isVirtual]="isVirtual"
                    [loadingTemplate]="cellLoadingTemplate"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="logicalColIndex(column)"
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [colIndex]="columnIndex"
                    [colSpan]="column.colspan"
                    [attr.role]="column.tableCellsRole"
                    class="k-table-td"
                    [attr.aria-selected]="lockedColumnsCount < 1 && isSelectable({ dataItem: item.data, index: $any(item).index }) ? isAriaSelected(item, column) : undefined"
                    [class.k-grid-content-sticky]="column.sticky"
                    [class.k-touch-action-none]="isSelectable({ dataItem: item.data, index: $any(item).index }) && $any(selectable).drag"
                [ngClass]="column.cssClass"
                [class.k-grid-edit-cell]="isEditingCell($any(item).index, column)"
                [ngStyle]="column.sticky ? addStickyColumnStyles(column) : column.style"
                [attr.colspan]="column.colspan"
                [class.k-selected]="isSelectable && cellSelectionService.isCellSelected(item, column)"
                *ngFor="let column of columns; let columnIndex = index; trackBy: trackByColumns;">
            </td>
        </tr>
        <tr *ngIf="isDataItem(item) &&
                (!$any(item).group || isDataItemInExpandedGroup($any(item))) &&
                detailTemplate?.templateRef &&
                detailTemplate.showIf(item.data, $any(item).index) &&
                isExpanded(item)"
            class="k-detail-row"
            kendoGridLogicalRow
                [dataRowIndex]="$any(item).index"
                [dataItem]="item.data"
                [logicalRowIndex]="logicalRowIndex(rowIndex) + 1"
                [logicalSlaveRow]="false"
                [logicalCellsCount]="1"
            >
            <td class="k-group-cell k-table-td k-table-group-td" *ngFor="let g of groups"></td>
            <td class="k-hierarchy-cell k-table-td"></td>
            <td class="k-detail-cell k-table-td"
                [attr.colspan]="columnsSpan"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex) + 1"
                    [logicalColIndex]="0"
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [colIndex]="0"
                    [colSpan]="allColumnsSpan + 1"
                    role="gridcell" aria-selected="false"
                >
                <ng-template
                    [ngTemplateOutlet]="detailTemplate.templateRef"
                    [ngTemplateOutletContext]="{
                        dataItem: item.data,
                        rowIndex: $any(item).index,
                        $implicit: item.data
                    }">
                </ng-template>
            </td>
        </tr>
        <tr *ngIf="isFooter(item) &&
                $any(item).group &&
                (isFooterItemInExpandedGroup($any(item)) || (showGroupFooters && isParentGroupExpanded($any(item).group))) &&
                !$any(item.data).hideFooter"
            class="k-group-footer"
            kendoGridLogicalRow
                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [totalColumns]="totalColumns"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount(item)">
            <ng-container *ngIf="!skipGroupDecoration">
                <td class="k-group-cell k-table-td k-table-group-td" *ngFor="let g of groups"></td>
            </ng-container>
            <td class="k-hierarchy-cell k-table-td"
                *ngIf="detailTemplate?.templateRef"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="0"
                    aria-selected="false"
                >
            </td>
            <td kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="logicalColIndex(column)"
                [attr.data-skip]="skipGroupDecoration"
                class="k-table-td"
                *ngFor="let column of footerColumns; let columnIndex = index; trackBy: trackByColumns;">
                <ng-template
                    [templateContext]="{
                        templateRef: $any(column).groupFooterTemplateRef,
                        group: $any(item.data),
                        field: $any(column).field,
                        column: column,
                        aggregates: $any(item.data)?.aggregates,
                        $implicit: $any(item.data)?.aggregates
                    }">
                </ng-template>
           </td>
        </tr>
    </ng-container>
    <kendo-resize-sensor *ngIf="rowSticky" (resize)="resizeHandler()"></kendo-resize-sensor>
    `,
                    standalone: true,
                    imports: [
                        NgIf, LogicalRowDirective, NgFor, LogicalCellDirective, CellComponent, NgClass, NgStyle, TemplateContextDirective,
                        GroupHeaderComponent, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent
                    ]
                }]
        }], ctorParameters: function () { return [{ type: DetailsService }, { type: GroupsService }, { type: ChangeNotificationService }, { type: EditService }, { type: ContextService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: DomEventsService }, { type: SelectionService }, { type: CellSelectionService }, { type: ColumnInfoService }, { type: NavigationService }]; }, propDecorators: { columns: [{
                type: Input
            }], allColumns: [{
                type: Input
            }], groups: [{
                type: Input
            }], detailTemplate: [{
                type: Input
            }], noRecordsTemplate: [{
                type: Input
            }], data: [{
                type: Input
            }], skip: [{
                type: Input
            }], selectable: [{
                type: Input
            }], filterable: [{
                type: Input
            }], noRecordsText: [{
                type: Input
            }], isLocked: [{
                type: Input
            }], isLoading: [{
                type: Input
            }], isVirtual: [{
                type: Input
            }], cellLoadingTemplate: [{
                type: Input
            }], skipGroupDecoration: [{
                type: Input
            }], showGroupFooters: [{
                type: Input
            }], lockedColumnsCount: [{
                type: Input
            }], totalColumnsCount: [{
                type: Input
            }], virtualColumns: [{
                type: Input
            }], trackBy: [{
                type: Input
            }], rowSticky: [{
                type: Input
            }], totalColumns: [{
                type: Input
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-table-tbody']
            }], rowClass: [{
                type: Input
            }] } });

/**
 * Represents the `edit` command of the Grid. You can apply this directive to any `button`
 * element inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %}).
 * When an associated button with the directive is clicked, the
 * [edit]({% slug api_grid_gridcomponent %}#toc-edit) event
 * is triggered ([see example]({% slug basics_editing_grid %})).
 *
 * When the row is in the `edit` mode, the button with `kendoGridEditCommand` is automatically hidden.
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <kendo-grid-command-column title="command">
 *     <ng-template kendoGridCellTemplate>
 *       <button kendoGridEditCommand class="k-primary">Edit</button>
 *     </ng-template>
 *   </kendo-grid-command-column>
 * </kendo-grid>
 * ```
 *
 */
class EditCommandDirective extends Button {
    editService;
    cellContext;
    rowIndex;
    isEdited;
    /**
     * @hidden
     */
    get visible() {
        return this.isEdited ? 'none' : '';
    }
    /**
     * @hidden
     */
    commandClass = true;
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.editService.beginEdit(this.rowIndex);
    }
    constructor(editService, cellContext, element, renderer, ctx, ngZone) {
        super(element, renderer, null, ctx.localization, ngZone);
        this.editService = editService;
        this.cellContext = cellContext;
    }
    ngDoCheck() {
        if (this.cellContext) {
            this.rowIndex = this.cellContext.rowIndex;
            this.isEdited = this.editService.isEdited(this.rowIndex);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EditCommandDirective, deps: [{ token: EditService }, { token: CELL_CONTEXT }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ContextService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: EditCommandDirective, isStandalone: true, selector: "[kendoGridEditCommand]", host: { listeners: { "click": "onClick($event)" }, properties: { "style.display": "this.visible", "class.k-grid-edit-command": "this.commandClass" } }, usesInheritance: true, ngImport: i0, template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EditCommandDirective, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridEditCommand]',
                    template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
                    standalone: true,
                    imports: [NgIf, IconWrapperComponent, NgClass]
                }]
        }], ctorParameters: function () { return [{ type: EditService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [CELL_CONTEXT]
                }] }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ContextService }, { type: i0.NgZone }]; }, propDecorators: { visible: [{
                type: HostBinding,
                args: ['style.display']
            }], commandClass: [{
                type: HostBinding,
                args: ['class.k-grid-edit-command']
            }], onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/**
 * Represents the `cancel` command of the Grid. You can apply this directive to any `button`
 * element inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %})
 * ([see example](slug:editing_directives_grid#toc-command-column-directives)).
 * When an associated button with the directive is clicked, the
 * [cancel]({% slug api_grid_gridcomponent %}#toc-cancel) event
 * is triggered. When the row is not in the edit mode, the button with the `kendoGridCancelCommand` is automatically hidden.
 *
 * You can control the content of the button based on the state of the row.
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <kendo-grid-command-column title="command">
 *     <ng-template kendoGridCellTemplate let-isNew="isNew">
 *       <button kendoGridCancelCommand>{{isNew ? 'Discard' : 'Cancel changes'}}</button>
 *     </ng-template>
 *   </kendo-grid-command-column>
 * </kendo-grid>
 * ```
 */
class CancelCommandDirective extends Button {
    editService;
    cellContext;
    rowIndex;
    isEdited;
    /**
     * @hidden
     */
    get visible() {
        return !this.isEdited ? 'none' : '';
    }
    /**
     * @hidden
     */
    commandClass = true;
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        if (this.isEdited) {
            this.editService.endEdit(this.rowIndex);
        }
    }
    constructor(editService, cellContext, element, renderer, ctx, ngZone) {
        super(element, renderer, null, ctx.localization, ngZone);
        this.editService = editService;
        this.cellContext = cellContext;
    }
    ngDoCheck() {
        if (this.cellContext) {
            this.rowIndex = this.cellContext.rowIndex;
            this.isEdited = this.editService.isEdited(this.rowIndex);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CancelCommandDirective, deps: [{ token: EditService }, { token: CELL_CONTEXT }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ContextService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: CancelCommandDirective, isStandalone: true, selector: "[kendoGridCancelCommand]", host: { listeners: { "click": "onClick($event)" }, properties: { "style.display": "this.visible", "class.k-grid-cancel-command": "this.commandClass" } }, usesInheritance: true, ngImport: i0, template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CancelCommandDirective, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridCancelCommand]',
                    template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
                    standalone: true,
                    imports: [NgIf, IconWrapperComponent, NgClass]
                }]
        }], ctorParameters: function () { return [{ type: EditService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [CELL_CONTEXT]
                }] }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ContextService }, { type: i0.NgZone }]; }, propDecorators: { visible: [{
                type: HostBinding,
                args: ['style.display']
            }], commandClass: [{
                type: HostBinding,
                args: ['class.k-grid-cancel-command']
            }], onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/**
 * Represents the `save` command of the Grid. You can apply this directive to any `button`
 * element inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %})
 * ([see example](slug:editing_directives_grid#toc-command-column-directives)).
 * When an associated button with the directive is clicked, the
 * [save]({% slug api_grid_gridcomponent %}#toc-save) event
 * is triggered. When the row is not in the edit mode, the button with `kendoGridSaveCommand` is automatically hidden.
 *
 * You can control the content of the button based on the state of the row.
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <kendo-grid-command-column title="command">
 *     <ng-template kendoGridCellTemplate let-isNew="isNew">
 *       <button kendoGridSaveCommand>{{isNew ? 'Add' : 'Update'}}</button>
 *     </ng-template>
 *   </kendo-grid-command-column>
 * </kendo-grid>
 * ```
 */
class SaveCommandDirective extends Button {
    editService;
    cellContext;
    rowIndex;
    isEdited;
    /**
     * @hidden
     */
    get visible() {
        return !this.isEdited ? 'none' : '';
    }
    /**
     * @hidden
     */
    commandClass = true;
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        if (this.isEdited) {
            this.editService.save(this.rowIndex);
        }
    }
    constructor(editService, cellContext, element, renderer, ctx, ngZone) {
        super(element, renderer, null, ctx.localization, ngZone);
        this.editService = editService;
        this.cellContext = cellContext;
    }
    ngDoCheck() {
        if (this.cellContext) {
            this.rowIndex = this.cellContext.rowIndex;
            this.isEdited = this.editService.isEdited(this.rowIndex);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SaveCommandDirective, deps: [{ token: EditService }, { token: CELL_CONTEXT }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ContextService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SaveCommandDirective, isStandalone: true, selector: "[kendoGridSaveCommand]", host: { listeners: { "click": "onClick($event)" }, properties: { "style.display": "this.visible", "class.k-grid-save-command": "this.commandClass" } }, usesInheritance: true, ngImport: i0, template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SaveCommandDirective, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridSaveCommand]',
                    template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
                    standalone: true,
                    imports: [NgIf, IconWrapperComponent, NgClass]
                }]
        }], ctorParameters: function () { return [{ type: EditService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [CELL_CONTEXT]
                }] }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ContextService }, { type: i0.NgZone }]; }, propDecorators: { visible: [{
                type: HostBinding,
                args: ['style.display']
            }], commandClass: [{
                type: HostBinding,
                args: ['class.k-grid-save-command']
            }], onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/**
 * Represents the `remove` command of the Grid. You can apply this directive to any `button` element
 * inside a [CommandColumnComponent]({% slug api_grid_commandcolumncomponent %})
 * ([see example](slug:editing_directives_grid#toc-command-column-directives)).
 * When an associated button with the directive is clicked, the
 * [remove]({% slug api_grid_gridcomponent %}#toc-remove) event
 * is triggered.
 * When the row is in the `edit` mode, the button with the `kendoGridRemoveCommand` is automatically hidden.
 *
 * @example
 * ```html
 * <kendo-grid>
 *   <kendo-grid-command-column title="command">
 *     <ng-template kendoGridCellTemplate>
 *       <button kendoGridRemoveCommand>Remove row</button>
 *     </ng-template>
 *   </kendo-grid-command-column>
 * </kendo-grid>
 * ```
 */
class RemoveCommandDirective extends Button {
    editService;
    cellContext;
    rowIndex;
    isEdited;
    /**
     * @hidden
     */
    get visible() {
        return this.isEdited ? 'none' : '';
    }
    /**
     * @hidden
     */
    commandClass = true;
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.editService.remove(this.rowIndex);
    }
    constructor(editService, cellContext, element, renderer, ctx, ngZone) {
        super(element, renderer, null, ctx.localization, ngZone);
        this.editService = editService;
        this.cellContext = cellContext;
    }
    ngDoCheck() {
        if (this.cellContext) {
            this.rowIndex = this.cellContext.rowIndex;
            this.isEdited = this.editService.isEdited(this.rowIndex);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: RemoveCommandDirective, deps: [{ token: EditService }, { token: CELL_CONTEXT }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ContextService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: RemoveCommandDirective, isStandalone: true, selector: "[kendoGridRemoveCommand]", host: { listeners: { "click": "onClick($event)" }, properties: { "style.display": "this.visible", "class.k-grid-remove-command": "this.commandClass" } }, usesInheritance: true, ngImport: i0, template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: RemoveCommandDirective, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridRemoveCommand]',
                    template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
                    standalone: true,
                    imports: [NgIf, IconWrapperComponent, NgClass]
                }]
        }], ctorParameters: function () { return [{ type: EditService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [CELL_CONTEXT]
                }] }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ContextService }, { type: i0.NgZone }]; }, propDecorators: { visible: [{
                type: HostBinding,
                args: ['style.display']
            }], commandClass: [{
                type: HostBinding,
                args: ['class.k-grid-remove-command']
            }], onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/**
 * Represents the command for adding a new item to the Grid. You can apply this directive to any
 * `button` element inside a [ToolbarTemplate]({% slug api_grid_commandcolumncomponent %}).
 * When an associated button with the directive is clicked, the
 * [add]({% slug api_grid_gridcomponent %}#toc-add) event is triggered
 * ([see example]({% slug basics_editing_grid %})).
 *
 * @example
 * ```html
 * <kendo-grid>
 *    <ng-template kendoGridToolbarTemplate>
 *       <button kendoGridAddCommand>Add new</button>
 *    </ng-template>
 * </kendo-grid>
 * ```
 */
class AddCommandDirective extends Button {
    editService;
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.editService.beginAdd();
    }
    /**
     * @hidden
     */
    get commandClass() {
        return true;
    }
    constructor(editService, element, renderer, ctx, ngZone) {
        super(element, renderer, null, ctx.localization, ngZone);
        this.editService = editService;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AddCommandDirective, deps: [{ token: EditService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ContextService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: AddCommandDirective, isStandalone: true, selector: "[kendoGridAddCommand]", host: { listeners: { "click": "onClick($event)" }, properties: { "class.k-grid-add-command": "this.commandClass" } }, usesInheritance: true, ngImport: i0, template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AddCommandDirective, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoGridAddCommand]',
                    template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
                    standalone: true,
                    imports: [NgIf, IconWrapperComponent, NgClass]
                }]
        }], ctorParameters: function () { return [{ type: EditService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ContextService }, { type: i0.NgZone }]; }, propDecorators: { onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }], commandClass: [{
                type: HostBinding,
                args: ['class.k-grid-add-command']
            }] } });

/**
 * Represents the virtual scrolling cell template of the Grid while loading new data. Provides an option to customize the
 * appearance of the indicator that is displayed while new data is loading. To define the loading cell template,
 * nest an `<ng-template>` tag with the `kendoGridCellLoadingTemplate` directive inside `<kendo-grid>` tag [see example]({% slug virtualscrolling_grid %}#toc-custom-loading-skeleton).
 *
 *
 * The template context is set to the current column and the following additional field is passed:
 *
 * - `column`&mdash;The current column instance. Represents the default context that will be assigned to any template variable which utilizes the `let-x` syntax (for example `let-column`).
 *
 * @example
 * ```html
 * <kendo-grid ... scrollable="virtual" [rowHeight]="36" [height]="450">
 *   <ng-template kendoGridCellLoadingTemplate let-column>
 *    ...
 *   </ng-template>
 * </kendo-grid>
 * ```
 */
class CellLoadingTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CellLoadingTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: CellLoadingTemplateDirective, isStandalone: true, selector: "[kendoGridCellLoadingTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CellLoadingTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridCellLoadingTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the drag handle for reordering rows in the Grid ([see example](slug:reordering_rows_grid))
 */
class RowReorderColumnComponent extends ColumnBase {
    parent;
    /**
     * Defines the name for an existing font icon in the Kendo UI theme.
     * @hidden
     */
    dragHandleIcon;
    /**
     * Defines an SVGIcon to be rendered as a drag handle.
     * @hidden
     */
    dragHandleSVGIcon;
    /**
     * @hidden
     */
    isRowReorderColumn = true;
    constructor(parent, idService) {
        super(parent, idService);
        this.parent = parent;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: RowReorderColumnComponent, deps: [{ token: ColumnBase, host: true, optional: true, skipSelf: true }, { token: IdService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: RowReorderColumnComponent, isStandalone: true, selector: "kendo-grid-rowreorder-column", inputs: { dragHandleIcon: "dragHandleIcon", dragHandleSVGIcon: "dragHandleSVGIcon" }, providers: [
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => RowReorderColumnComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: RowReorderColumnComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: ColumnBase,
                            useExisting: forwardRef(() => RowReorderColumnComponent)
                        }
                    ],
                    selector: 'kendo-grid-rowreorder-column',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ColumnBase, decorators: [{
                    type: SkipSelf
                }, {
                    type: Host
                }, {
                    type: Optional
                }] }, { type: IdService, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { dragHandleIcon: [{
                type: Input
            }], dragHandleSVGIcon: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class ZoneAwareEventEmitter extends EventEmitter {
    ngZone;
    constructor(ngZone, isAsync = false) {
        super(isAsync);
        this.ngZone = ngZone;
    }
    subscribe(generatorOrNext, error, complete) {
        let schedulerFn;
        let errorFn = (_) => null;
        let completeFn = () => null;
        if (generatorOrNext && typeof generatorOrNext === 'object') {
            schedulerFn = (value) => { this.ngZone.run(() => generatorOrNext.next(value)); };
            if (generatorOrNext.error) {
                errorFn = (err) => { this.ngZone.run(() => generatorOrNext.error(err)); };
            }
            if (generatorOrNext.complete) {
                completeFn = () => { this.ngZone.run(() => generatorOrNext.complete()); };
            }
        }
        else {
            schedulerFn = (value) => { this.ngZone.run(() => generatorOrNext(value)); };
            if (error) {
                errorFn = (err) => { this.ngZone.run(() => error(err)); };
            }
            if (complete) {
                completeFn = () => { this.ngZone.run(() => complete()); };
            }
        }
        return super.subscribe(schedulerFn, errorFn, completeFn);
    }
}

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-grid',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1733732581,
    version: '17.1.1',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'
};

/**
 * @hidden
 */
const normalizeSettings = ({ buttonCount = 10, info = true, type = 'numeric', pageSizes = false, previousNext = true, responsive = true, position = 'bottom' }) => ({
    buttonCount,
    info,
    pageSizes: pageSizes === true ? [5, 10, 20] : pageSizes,
    previousNext,
    type,
    responsive,
    position
});
/**
 * @hidden
 */
const normalize = (settings) => normalizeSettings(settings === true ? {} : settings);

const canCreateElement = () => isDocumentAvailable() && document.createElement;
let cachedScrollbarWidth = null;
let cachedPixelRatio;
let cachedRtlScrollLeft = null;
function scrollbarWidth() {
    if (cachedScrollbarWidth === null && canCreateElement()) {
        cachedPixelRatio = window.devicePixelRatio || 1;
        const div = document.createElement("div");
        div.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block";
        div.innerHTML = "&nbsp;";
        document.body.appendChild(div);
        cachedScrollbarWidth = div.offsetWidth - div.scrollWidth;
        document.body.removeChild(div);
    }
    return cachedScrollbarWidth;
}
function rtlScrollLeft() {
    if (cachedRtlScrollLeft === null && canCreateElement()) {
        const outer = document.createElement('div');
        outer.style.direction = 'rtl';
        outer.style.display = 'block';
        outer.style.clear = 'both';
        outer.style.width = '100px';
        outer.style.visibility = 'hidden';
        outer.style.position = 'absolute';
        outer.style.left = '-10000px';
        outer.style.overflow = 'scroll';
        outer.style.zoom = '1';
        const inner = document.createElement('div');
        inner.style.width = '200px';
        inner.style.height = '1px';
        outer.append(inner);
        document.body.appendChild(outer);
        const initial = outer.scrollLeft;
        outer.scrollLeft = -1;
        cachedRtlScrollLeft = outer.scrollLeft < 0 ? outer.scrollLeft : initial;
        document.body.removeChild(outer);
    }
    return cachedRtlScrollLeft;
}
/**
 * @hidden
 * move to kendo-common
 */
class BrowserSupportService {
    zone;
    changeDetector;
    changes = new EventEmitter();
    subscriptions;
    constructor(zone, changeDetector) {
        this.zone = zone;
        this.changeDetector = changeDetector;
        if (typeof window === 'undefined') {
            return;
        }
        this.zone.runOutsideAngular(() => {
            this.subscriptions = fromEvent(window, 'resize').pipe(auditTime(100)).subscribe(() => {
                if (cachedPixelRatio !== window.devicePixelRatio) {
                    zone.run(() => {
                        cachedScrollbarWidth = null;
                        this.changes.emit();
                        this.changeDetector.markForCheck();
                    });
                }
            });
        });
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
            this.subscriptions = null;
        }
    }
    get scrollbarWidth() {
        return scrollbarWidth();
    }
    get rtlScrollLeft() {
        return rtlScrollLeft();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BrowserSupportService, deps: [{ token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BrowserSupportService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BrowserSupportService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; } });

const isGroupItem = (source) => {
    return source.items !== undefined &&
        source.field !== undefined;
};
const isVirtualGroupItem = (source) => {
    return source.offset !== undefined &&
        source.skipHeader !== undefined;
};
const flattenGroups = (groups) => (groups.reduce((acc, curr) => {
    if (isGroupItem(curr)) {
        return acc.concat(flattenGroups(curr.items));
    }
    return acc.concat([curr]);
}, []));
/**
 * @hidden
 */
const itemAt = (data, index) => {
    const first = data[0];
    if (isPresent(first) && isGroupItem(first)) {
        return flattenGroups(data)[index];
    }
    return data[index];
};
/**
 * @hidden
 */
const getIterator = (data, { footers, level, dataIndex, parentGroupIndex, groupIndex, parentGroup }) => {
    const first = data[0];
    if (isPresent(first) && isGroupItem(first)) {
        if (isVirtualGroupItem(first)) {
            groupIndex = isPresent(first.offset) ? first.offset : groupIndex;
        }
        return new GroupIterator(data, footers, level, dataIndex, parentGroupIndex, groupIndex, parentGroup);
    }
    return new ItemIterator(data, dataIndex, parentGroupIndex, parentGroup);
};
class ArrayIterator {
    arr;
    idx;
    constructor(arr, idx = 0) {
        this.arr = arr;
        this.idx = idx;
        this.arr = arr || [];
    }
    [iterator]() {
        return this;
    }
    next() {
        return this.idx < this.arr.length ? {
            done: false,
            value: this.arr[this.idx++]
        } : { done: true, value: undefined };
    }
}
/**
 * @hidden
 */
class Iterator {
    dataIndex;
    resultMap;
    _innerIterator;
    constructor(arr, dataIndex = 0, resultMap = (x) => x) {
        this.dataIndex = dataIndex;
        this.resultMap = resultMap;
        const iter = arr[iterator];
        this._innerIterator = iter ? arr[iterator]() : new ArrayIterator(arr);
    }
    [iterator]() {
        return this;
    }
    next() {
        return this.resultMap(this._innerIterator.next(), this.dataIndex++);
    }
}
/**
 * @hidden
 */
class ItemIterator extends Iterator {
    constructor(arr, dataIndex, groupIndex, group) {
        super(arr, dataIndex, (x, idx) => ({
            done: x.done,
            value: {
                data: x.value,
                groupIndex: groupIndex,
                index: idx,
                type: 'data',
                group
            }
        }));
    }
    /**
     * The index of the next record.
     * @readonly
     * @type {number}
     */
    get index() {
        return this.dataIndex;
    }
}
const prefix = (s, n) => {
    const p = s ? s + "_" : s;
    return `${p}${n}`;
};
/**
 * @hidden
 */
class GroupIterator {
    arr;
    outputFooters;
    level;
    dataIndex;
    parentIndex;
    groupIndex;
    parentGroup;
    current;
    _innerIterator;
    _iterator;
    currentGroupIndex = "";
    constructor(arr, outputFooters = false, level = 0, dataIndex = 0, parentIndex = '', groupIndex = 0, parentGroup = undefined) {
        this.arr = arr;
        this.outputFooters = outputFooters;
        this.level = level;
        this.dataIndex = dataIndex;
        this.parentIndex = parentIndex;
        this.groupIndex = groupIndex;
        this.parentGroup = parentGroup;
        this.arr = arr || [];
        this._iterator = new Iterator(this.arr, this.dataIndex);
    }
    [iterator]() {
        return this;
    }
    nextGroupItem() {
        this.current = this._iterator.next().value;
        this._innerIterator = null;
        if (this.current) {
            this.currentGroupIndex = prefix(this.parentIndex, this.groupIndex++);
            return {
                done: false,
                value: {
                    data: this.current,
                    index: this.currentGroupIndex,
                    level: this.level,
                    type: 'group',
                    parentGroup: this.parentGroup
                }
            };
        }
        else {
            this.current = null;
            return { done: true, value: undefined };
        }
    }
    footerItem() {
        if (this.current) {
            const group = this.current;
            this.current = null;
            return {
                done: false,
                value: {
                    data: group,
                    groupIndex: this.currentGroupIndex,
                    level: this.level,
                    type: 'footer',
                    group: {
                        data: group,
                        index: this.currentGroupIndex,
                        level: this.level,
                        type: 'group',
                        parentGroup: this.parentGroup
                    }
                }
            };
        }
        else {
            this.current = null;
            return { done: true, value: undefined };
        }
    }
    innerIterator(group) {
        if (!this._innerIterator) {
            this._innerIterator = getIterator(group.items, {
                dataIndex: this.dataIndex,
                footers: this.outputFooters,
                level: this.level + 1,
                parentGroupIndex: this.currentGroupIndex,
                parentGroup: {
                    data: this.current,
                    index: this.currentGroupIndex,
                    level: this.level,
                    type: 'group',
                    parentGroup: this.parentGroup
                }
            });
        }
        return this._innerIterator;
    }
    nextDataItem(group) {
        const iterator = this.innerIterator(group);
        const result = iterator.next();
        if (isPresent(result.value) && !result.done && result.value.type === "data") {
            this.dataIndex = result.value.index + 1;
        }
        return !result.done ? result : undefined;
    }
    next() {
        if (!isPresent(this.current)) {
            return this.nextGroupItem();
        }
        const item = this.nextDataItem(this.current);
        return item ? item : (this.outputFooters ? this.footerItem() : this.nextGroupItem());
    }
    /**
     * The index of the last iterated data record.
     * @readonly
     * @type {number}
     */
    get index() {
        return this.dataIndex + 1;
    }
}

/**
 * @hidden
 */
class DataResultIterator {
    source;
    skip;
    groupFooters;
    isObject;
    constructor(source, skip = 0, groupFooters = false) {
        this.source = source;
        this.skip = skip;
        this.groupFooters = groupFooters;
        this.source = this.source ? this.source : [];
        this.isObject = this.isGridDataResult(this.source);
    }
    isGridDataResult(source) {
        return source.total !== undefined && source.data !== undefined;
    }
    get total() {
        return this.isObject ? this.source.total : this.source.length;
    }
    get data() {
        return this.isObject ? this.source.data : this.source;
    }
    map(fn) {
        return this.data.map(fn);
    }
    filter(fn) {
        return this.data.filter(fn);
    }
    reduce(fn, init) {
        return this.data.reduce(fn, init);
    }
    forEach(fn) {
        this.data.forEach(fn);
    }
    some(fn) {
        return this.data.some(fn);
    }
    [iterator]() {
        return getIterator(this.data, {
            dataIndex: this.skip,
            footers: this.groupFooters,
            groupIndex: this.skip
        });
    }
    toString() { return this.data.toString(); }
}
/**
 * @hidden
 */
class DataCollection {
    accessor;
    constructor(accessor) {
        this.accessor = accessor;
    }
    get total() { return this.accessor().total; }
    get length() { return this.accessor().data.length; }
    get first() { return this.accessor().data[0]; }
    get last() { return this.accessor().data[this.length - 1]; }
    at(index) {
        return itemAt(this.accessor().data, index);
    }
    map(fn) { return this.accessor().map(fn); }
    filter(fn) {
        return this.accessor().filter(fn);
    }
    reduce(fn, init) {
        return this.accessor().reduce(fn, init);
    }
    forEach(fn) {
        this.accessor().forEach(fn);
    }
    some(fn) {
        return this.accessor().some(fn);
    }
    [iterator]() {
        return this.accessor()[iterator]();
    }
    toString() { return this.accessor().toString(); }
}

/**
 * @hidden
 *
 * Quick look-up structure for combinations of keys.
 * Similar to the native JS Set, however, working with a couple of keys instead of with a single key.
 * Supports both primitive keys and object keys (compared by reference).
 */
class PairSet {
    /**
     * Gets the total number of X/Y key pairs.
     */
    get size() {
        return this.totalKeysCount;
    }
    /**
     * Holds a set of Y keys for each defined X key.
     * Each X key creates a map which holds a set of Y keys.
     *
     * Map { 1 => Set { 1, 2, 3 } } // pairs: [1, 1], [1, 2], [1, 3]
     */
    keysX = new Map();
    /**
     * Count the each added or deleted key manually to avoid iterating over all items when calling `this.size`.
     */
    totalKeysCount = 0;
    constructor(items, keyXField, keyYField) {
        if (items && keyXField && keyYField) {
            items.forEach(item => this.add(item[keyXField], item[keyYField]));
        }
    }
    /**
     * Adds a couple of items identified as a combination.
     */
    add(keyX, keyY) {
        if (!this.keysX.has(keyX)) {
            this.keysX.set(keyX, new Set());
        }
        if (!this.has(keyX, keyY)) {
            this.keysX.get(keyX).add(keyY);
            this.totalKeysCount += 1;
        }
    }
    /**
     * Adds a combination of a couple of items identified together.
     */
    delete(keyX, keyY) {
        if (this.has(keyX, keyY)) {
            this.keysX.get(keyX).delete(keyY);
            this.totalKeysCount -= 1;
        }
    }
    /**
     * Checks whether the defined combination is stored.
     */
    has(keyX, keyY) {
        return this.keysX.has(keyX) && this.keysX.get(keyX).has(keyY);
    }
    /**
     * Clears all key combinations.
     */
    clear() {
        this.keysX.clear();
        this.totalKeysCount = 0;
    }
    /**
     * Converts the persisted data structure to an array of objects,
     * using the provided field names for the object props.
     */
    toArray(keyXField, keyYField) {
        return Array.from(this.keysX).reduce((pairs, pair) => {
            // Array.from(mapInstance) returns an array of arrays [[itemKey1, columnKeysSet1], [itemKey2, columnKeysSet2]]
            const [keyX, keysY] = pair;
            Array.from(keysY).forEach(keyY => pairs.push({ [keyXField]: keyX, [keyYField]: keyY }));
            return pairs;
        }, []);
    }
}

/**
 * @hidden
 */
class Selection {
    ctx;
    cd;
    /**
     * Defines the collection that will store the selected item keys.
     * @default []
     */
    selectedKeys = [];
    /**
     * Defines the initial shift-click range selection starting row index.
     *
     * @default 0
     */
    rangeSelectionStartRow;
    /**
     * Defines the initial shift-click range selection starting column index when cell selection is enabled.
     *
     * @default 0
     */
    rangeSelectionStartColumnIndex = 0;
    /**
     * Defines the item key that will be stored in the `selectedKeys` collection.
     */
    selectionKey;
    /**
     * Defines a function that determines the column key of a data cell.
     *
     * The function should return an unique value for each column.
     * By default, the Grid uses the column index as a column key.
     */
    columnKey;
    /**
     * Fires when the `selectedKeys` collection has been updated.
     */
    selectedKeysChange = new EventEmitter();
    rowSelectionState = new Set();
    cellSelectionState = new PairSet();
    /**
     * @hidden
     */
    get isCellSelectionMode() {
        return isPresent(this.ctx.grid.selectable) && this.ctx.grid.selectable['cell'];
    }
    lastSelectionState;
    selectionChangeSubscription;
    constructor(ctx, cd) {
        this.ctx = ctx;
        this.cd = cd;
        this.init();
    }
    ngOnChanges(changes) {
        // skip reinitialization if the user data is the same as the last state change
        if (isPresent(changes['selectedKeys']) && this.lastSelectionState !== this.selectedKeys) {
            this.setState(this.selectedKeys);
        }
    }
    init() {
        if (!isPresent(this.ctx.grid.rowSelected)) {
            this.ctx.grid.rowSelected = (row) => this.rowSelectionState.has(this.getItemKey(row));
        }
        if (!isPresent(this.ctx.grid.isRowSelectable)) {
            this.ctx.grid.isRowSelectable = (_row) => Boolean(this.ctx.grid.selectable);
        }
        if (!isPresent(this.ctx.grid.cellSelected)) {
            this.ctx.grid.cellSelected = (row, column, colIndex) => {
                const contender = this.getSelectionItem(row, column, colIndex);
                return {
                    selected: this.cellSelectionState.has(contender.itemKey, contender.columnKey),
                    item: contender
                };
            };
        }
        this.selectionChangeSubscription = this.ctx.grid
            .selectionChange
            .subscribe(this.onSelectionChange.bind(this));
    }
    /**
     * @hidden
     */
    destroy() {
        this.selectionChangeSubscription.unsubscribe();
    }
    /**
     * @hidden
     */
    reset() {
        this.rowSelectionState.clear();
        this.cellSelectionState.clear();
    }
    /**
     * @hidden
     */
    getItemKey(row) {
        if (this.selectionKey) {
            if (typeof this.selectionKey === "string") {
                return row.dataItem[this.selectionKey];
            }
            if (typeof this.selectionKey === "function") {
                return this.selectionKey(row);
            }
        }
        return row.index;
    }
    /**
     * @hidden
     */
    stateToArray() {
        return this.isCellSelectionMode ?
            this.cellSelectionState.toArray('itemKey', 'columnKey') :
            Array.from(this.rowSelectionState);
    }
    getSelectionItem(row, col, colIndex) {
        const itemIdentifiers = {};
        itemIdentifiers.itemKey = this.getItemKey(row);
        if (!isPresent(col) && !isPresent(colIndex)) {
            return itemIdentifiers;
        }
        if (this.columnKey) {
            if (typeof this.columnKey === "string") {
                itemIdentifiers.columnKey = row.dataItem[this.columnKey];
            }
            if (typeof this.columnKey === "function") {
                itemIdentifiers.columnKey = this.columnKey(col, colIndex);
            }
        }
        return {
            itemKey: itemIdentifiers.itemKey,
            columnKey: itemIdentifiers.columnKey ? itemIdentifiers.columnKey : colIndex
        };
    }
    onSelectionChange(selection) {
        if (selection.selectedRows) {
            selection.deselectedRows.forEach((item) => {
                const itemKey = this.getItemKey(item);
                this.rowSelectionState.delete(itemKey);
            });
            if (this.ctx.grid.selectableSettings.mode === "single" && this.rowSelectionState.size > 0) {
                this.reset();
            }
            selection.selectedRows.forEach((item) => {
                const itemKey = this.getItemKey(item);
                this.rowSelectionState.add(itemKey);
            });
        }
        else {
            selection.deselectedCells.forEach(({ itemKey, columnKey }) => {
                this.cellSelectionState.delete(itemKey, columnKey);
            });
            if (this.ctx.grid.selectableSettings.mode === "single" && this.cellSelectionState.size > 0) {
                this.reset();
            }
            selection.selectedCells.forEach(({ itemKey, columnKey }) => {
                this.cellSelectionState.add(itemKey, columnKey);
            });
        }
        this.cd.markForCheck();
        this.notifyChange();
    }
    notifyChange() {
        this.lastSelectionState = this.stateToArray();
        this.selectedKeysChange.emit(this.lastSelectionState);
    }
    setState(selectedKeys) {
        this.reset();
        if (this.isCellSelectionMode) {
            this.cellSelectionState = new PairSet(selectedKeys, 'itemKey', 'columnKey');
        }
        else {
            this.rowSelectionState = new Set(selectedKeys);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Selection, deps: [{ token: ContextService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: Selection, selector: "kendo-grid-selection-base", inputs: { selectedKeys: "selectedKeys", rangeSelectionStartRow: "rangeSelectionStartRow", rangeSelectionStartColumnIndex: "rangeSelectionStartColumnIndex", selectionKey: ["kendoGridSelectBy", "selectionKey"], columnKey: "columnKey" }, outputs: { selectedKeysChange: "selectedKeysChange" }, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Selection, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'kendo-grid-selection-base'
                }]
        }], ctorParameters: function () { return [{ type: ContextService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { selectedKeys: [{
                type: Input
            }], rangeSelectionStartRow: [{
                type: Input
            }], rangeSelectionStartColumnIndex: [{
                type: Input
            }], selectionKey: [{
                type: Input,
                args: ["kendoGridSelectBy"]
            }], columnKey: [{
                type: Input
            }], selectedKeysChange: [{
                type: Output
            }] } });

const set = value => pair => pair.forEach(x => x.style.height = value);
const clearHeight = pairs => pairs
    .filter(([left, right]) => left.style.height || right.style.height)
    .forEach(set(""));
const zip = (arr1, arr2) => {
    const result = [];
    for (let idx = 0, len = arr1.length; idx < len; idx++) {
        if (!arr2[idx]) {
            break;
        }
        result.push([arr1[idx], arr2[idx]]);
    }
    return result;
};
const setHeight$1 = heights => (row, idx) => set(`${heights[idx] + 1}px`)(row);
const getHeights = rows => rows.map(([left, right]) => {
    const height = left.offsetHeight;
    const offsetHeight2 = right.offsetHeight;
    if (height < offsetHeight2) {
        return offsetHeight2;
    }
    return height;
});
/**
 * @hidden
 */
const syncRowsHeight = (table1, table2) => {
    if (!isDocumentAvailable()) {
        return;
    }
    const activeElement = document.activeElement;
    const rows = zip(table1.rows, table2.rows);
    clearHeight(rows);
    const heights = getHeights(rows);
    [table1, table2].forEach(x => x.style.display = 'none');
    rows.forEach(setHeight$1(heights));
    [table1, table2].forEach(x => x.style.display = '');
    if (document.activeElement !== activeElement &&
        (table1.contains(activeElement) || table2.contains(activeElement))) {
        activeElement.focus();
    }
};

/**
 * Arguments for the `pdfExport` event.
 */
class PDFExportEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor() {
        super();
    }
}

const bootstrapToMedia = (media) => (({
    "xs": "(max-width: 576px)",
    "sm": "(min-width: 576px)",
    "md": "(min-width: 768px)",
    "lg": "(min-width: 992px)",
    "xl": "(min-width: 1200px)"
})[media] || media);
const browserMatchMedia = (media) => window.matchMedia(media).matches;
/**
 * @hidden
 */
class ResponsiveService {
    /**
     * @hidden
     */
    matchMedia = browserMatchMedia;
    /**
     * @hidden
     */
    matchesMedia(media) {
        return !media || this.matchMedia(bootstrapToMedia(media));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ResponsiveService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ResponsiveService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ResponsiveService, decorators: [{
            type: Injectable
        }] });

/**
 * Represents the toolbar template of the Grid.
 *
 * The template context has the following field:
 * - `position`&mdash;The position at which the toolbar template is rendered. The possible values are `top`, `bottom`, and `both`.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData" style="height: 200px">
 *    <ng-template kendoGridToolbarTemplate [position]="position" let-position="position">
 *       <button (click)="onClick()">Custom action</button>
 *    </ng-template>
 *    <kendo-grid-column field="ProductName">
 *    </kendo-grid-column>
 * </kendo-grid>
 * ```
 */
class ToolbarTemplateDirective {
    templateRef;
    _position = 'top';
    /**
     * The position of the toolbar ([see example]({% slug toolbartemplate_grid %}#toc-setting-the-toolbar-position)).
     *
     * @default 'top'
     */
    set position(position) {
        this._position = position;
    }
    get position() {
        return this._position;
    }
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ToolbarTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: ToolbarTemplateDirective, isStandalone: true, selector: "[kendoGridToolbarTemplate]", inputs: { position: "position" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ToolbarTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridToolbarTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { position: [{
                type: Input,
                args: ["position"]
            }] } });

/**
 * @hidden
 */
class NavigationMetadata {
    dataRows;
    headerRows;
    isVirtual;
    hasPager;
    hasDetailTemplate;
    gridElement;
    virtualColumns;
    columns;
    get maxLogicalRowIndex() {
        const dataRows = this.hasDetailTemplate ? this.dataRows * 2 : this.dataRows;
        return this.headerRows + dataRows - 1;
    }
    constructor(dataRows, headerRows, isVirtual, hasPager, hasDetailTemplate, gridElement, virtualColumns, columns) {
        this.dataRows = dataRows;
        this.headerRows = headerRows;
        this.isVirtual = isVirtual;
        this.hasPager = hasPager;
        this.hasDetailTemplate = hasDetailTemplate;
        this.gridElement = gridElement;
        this.virtualColumns = virtualColumns;
        this.columns = columns;
    }
}

/**
 * Arguments for the `columnVisibilityChange` event.
 */
class ColumnVisibilityChangeEvent {
    /**
     * The columns whose visibility is changed.
     */
    columns;
    /**
     * @hidden
     */
    constructor(columns) {
        this.columns = columns;
    }
}

/**
 * Arguments for the `columnLockedChange` event.
 */
class ColumnLockedChangeEvent {
    /**
     * The columns whose locked state is changed.
     */
    columns;
    /**
     * @hidden
     */
    constructor(columns) {
        this.columns = columns;
    }
}

/**
 * @hidden
 */
const GROUP_CELL_WIDTH = 32; // this should be the value of group-cell inside the theme!
/**
 * @hidden
 */
const RESPONSIVE_BREAKPOINT_MEDIUM = 600;
/**
 * @hidden
 */
const RESPONSIVE_BREAKPOINT_LARGE = 768;

/**
 * Arguments for the `columnStickyChange` event.
 */
class ColumnStickyChangeEvent {
    /**
     * The columns whose sticky state is changed.
     */
    columns;
    /**
     * @hidden
     */
    constructor(columns) {
        this.columns = columns;
    }
}

/**
 * @hidden
 */
const isNextSibling = (dropTarget, dragTarget) => dropTarget === dragTarget.nextElementSibling;
/**
 * @hidden
 */
const isPreviousSibling = (dropTarget, dragTarget) => dropTarget === dragTarget.previousElementSibling;
/**
 * @hidden
 */
const isDifferentParent = (dropTarget, dragTarget) => dropTarget?.parentElement !== dragTarget?.parentElement;
/**
 * @hidden
 */
function getOffset(element) {
    const { clientTop, clientLeft } = getDocument(element);
    const { pageYOffset, pageXOffset } = getWindow(element);
    const { top, left } = element.getBoundingClientRect();
    return {
        top: top + pageYOffset - clientTop,
        left: left + pageXOffset - clientLeft
    };
}
/**
 * @hidden
 */
const hintIcons = {
    forbidden: 'cancel',
    before: 'insert-middle',
    after: 'insert-middle'
};
/**
 * @hidden
 */
const hintSVGIcons = {
    forbidden: cancelIcon,
    before: insertMiddleIcon,
    after: insertMiddleIcon
};
/**
 * @hidden
 */
const dropPosition = {
    forbidden: 'forbidden',
    before: 'before',
    after: 'after'
};
/**
 * @hidden
 */
const hintStyles = {
    zIndex: '20000',
    display: 'flex',
    position: 'fixed'
};
/**
 * @hidden
 */
const hintClasses = ['k-drag-clue', 'k-reorder-clue'];
/**
 * @hidden
 */
const dropIndicatorStyles = {
    zIndex: '19000',
    position: 'absolute'
};
/**
 * @hidden
 */
const dropIndicatorClasses = ['k-drop-hint', 'k-drop-hint-h'];
/**
 * @hidden
 */
const defaultSelectors = {
    handle: '.k-table-td.k-drag-cell',
    dragTarget: '.k-master-row',
    dropTarget: '.k-master-row'
};
const getDocument = element => element?.ownerDocument.documentElement;
const getWindow = element => element?.ownerDocument.defaultView;

/**
 * @hidden
 */
class RowReorderService {
    renderer;
    hintElement = null;
    defaultSelectors = defaultSelectors;
    hintText = '';
    skip;
    dropIndicator;
    lastDropPosition = dropPosition.forbidden;
    dragTarget = null;
    dropTarget = null;
    offsetY;
    rowReorder = new EventEmitter();
    constructor(renderer) {
        this.renderer = renderer;
    }
    press(ev) {
        this.dragTarget = ev.dragTarget;
        this.offsetY = ev.dragEvent.offsetY;
    }
    dragStart() {
        this.createDropIndicator();
    }
    drag(ev) {
        if (isPresent$1(ev.hintElement) && !isPresent$1(this.hintElement)) {
            this.hintElement = ev.hintElement;
            this.decorateHint();
        }
        const position = {
            x: ev.dragEvent.clientX,
            y: ev.dragEvent.clientY - this.offsetY
        };
        if (isPresent$1(this.hintElement)) {
            this.renderer.setStyle(this.hintElement, 'left', `${position.x}px`);
            this.renderer.setStyle(this.hintElement, 'top', `${position.y}px`);
        }
        this.positionDropIndicator(ev);
    }
    dragEnter(ev) {
        this.dropTarget = ev.dropTarget;
    }
    dragLeave() {
        this.dropTarget = null;
        this.hide();
    }
    dragEnd() {
        this.destroyDropIndicator();
        this.dragTarget = null;
        this.dropTarget = null;
        this.hintElement = null;
    }
    drop(ev) {
        this.destroyDropIndicator();
        const rowReorderArgs = this.rowReorderArgs(this.dragTarget, this.dropTarget, ev.dragData);
        this.rowReorder.emit(rowReorderArgs);
    }
    reorderRows(ev, collection) {
        if (this.lastDropPosition === dropPosition.forbidden) {
            return;
        }
        const { draggedRows, dropTargetRow } = ev;
        const draggedDataItem = draggedRows[0].dataItem;
        const dropTargetDataItem = dropTargetRow.dataItem;
        const draggedItemIndex = collection.indexOf(draggedDataItem);
        const dropTargetIndex = collection.indexOf(dropTargetDataItem);
        const idxToAdd = this.calculateIndexToAdd(draggedItemIndex, dropTargetIndex);
        collection.splice(draggedItemIndex, 1);
        collection.splice(idxToAdd, 0, draggedDataItem);
    }
    get hintIcon() {
        return hintIcons[this.lastDropPosition];
    }
    get hintSVGIcon() {
        return hintSVGIcons[this.lastDropPosition];
    }
    getDefaultHintText(columns, data) {
        let hintText = '';
        const columnFieldsArray = columns
            .toArray()
            .filter(column => !column.hidden && isPresent$1(column.field))
            .map(column => column.field);
        const draggedDragRow = this.getDragRowPerElement(this.dragTarget, data);
        const draggedDataItem = draggedDragRow?.dataItem;
        isPresent$1(draggedDataItem) && columnFieldsArray.forEach(column => {
            const columnValue = draggedDataItem[column];
            isPresent$1(columnValue) ? hintText += `${columnValue} ` : null;
        });
        return hintText.trim();
    }
    rowReorderArgs(dragRow, dropRow, data) {
        const dragRowData = this.getDragRowPerElement(dragRow, data);
        const dropRowData = this.getDragRowPerElement(dropRow, data);
        return {
            draggedRows: [dragRowData],
            dropTargetRow: dropRowData,
            dropPosition: this.lastDropPosition
        };
    }
    getDragRowPerElement(row, data) {
        let rowIndex = row?.getAttribute('data-kendo-grid-item-index');
        rowIndex = rowIndex ? parseInt(rowIndex, 10) : -1;
        const skip = this.skip || 0;
        const dataItem = rowIndex === -1 ? null : data[rowIndex - skip];
        return {
            dataItem,
            rowIndex,
            element: row
        };
    }
    createDropIndicator() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.dropIndicator = document.createElement('div');
        this.decorateDropIndicator();
        this.dropIndicator.innerHTML = `
            <div class="k-drop-hint-start"></div>
            <div class="k-drop-hint-line"></div>
        `;
        document.body.appendChild(this.dropIndicator);
        this.hide();
    }
    destroyDropIndicator() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.dropIndicator && this.dropIndicator.parentElement) {
            document.body.removeChild(this.dropIndicator);
            this.dropIndicator = null;
        }
    }
    decorateHint() {
        hintClasses.forEach(className => this.renderer.addClass(this.hintElement, className));
        Object.keys(hintStyles)
            .forEach(style => this.renderer.setStyle(this.hintElement, style, hintStyles[style]));
    }
    positionDropIndicator(ev) {
        this.lastDropPosition = this.getDropPosition(ev.dragEvent);
        this.updateDropIndicatorPosition();
    }
    calculateIndexToAdd(dragIndex, dropIndex) {
        if (dragIndex > dropIndex && this.lastDropPosition === dropPosition.after) {
            return dropIndex + 1;
        }
        else if (dragIndex > dropIndex && this.lastDropPosition === dropPosition.before) {
            return dropIndex;
        }
        else if (dragIndex < dropIndex && this.lastDropPosition === dropPosition.after) {
            return dropIndex;
        }
        else if (dragIndex < dropIndex && this.lastDropPosition === dropPosition.before) {
            return dropIndex - 1;
        }
    }
    decorateDropIndicator() {
        dropIndicatorClasses.forEach(className => this.renderer.addClass(this.dropIndicator, className));
        Object.keys(dropIndicatorStyles)
            .forEach(style => this.renderer.setStyle(this.dropIndicator, style, dropIndicatorStyles[style]));
    }
    getDropPosition(e) {
        if (this.dropTarget === this.dragTarget || !isPresent$1(this.dropTarget)) {
            return dropPosition.forbidden;
        }
        if (isDifferentParent(this.dropTarget, this.dragTarget)) {
            return dropPosition.forbidden;
        }
        const itemViewPortCoords = this.dropTarget.getBoundingClientRect();
        const itemDivisionsCount = 2;
        const itemDivisionHeight = itemViewPortCoords.height / itemDivisionsCount;
        const pointerPosition = e.clientY;
        const itemTop = itemViewPortCoords.top;
        let currentDropPosition = null;
        if (pointerPosition < itemTop + itemDivisionHeight) {
            currentDropPosition = dropPosition.before;
        }
        else if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {
            currentDropPosition = dropPosition.after;
        }
        if (currentDropPosition === dropPosition.before && isNextSibling(this.dropTarget, this.dragTarget)) {
            currentDropPosition = dropPosition.forbidden;
        }
        else if (currentDropPosition === dropPosition.after && isPreviousSibling(this.dropTarget, this.dragTarget)) {
            currentDropPosition = dropPosition.forbidden;
        }
        return currentDropPosition;
    }
    updateDropIndicatorPosition() {
        if (this.shouldHideDropIndicator() || !this.dropTarget) {
            this.hide();
            return;
        }
        this.show();
        const destinationItemOffset = getOffset(this.dropTarget);
        let indicatorOffsetTop = destinationItemOffset.top;
        const indicatorOffsetLeft = destinationItemOffset.left + this.dropIndicator.offsetWidth / 2;
        if (this.lastDropPosition === dropPosition.after) {
            indicatorOffsetTop += this.dropTarget.offsetHeight;
        }
        this.renderer.setStyle(this.dropIndicator, 'left', `${indicatorOffsetLeft}px`);
        this.renderer.setStyle(this.dropIndicator, 'top', `${indicatorOffsetTop}px`);
    }
    shouldHideDropIndicator() {
        return this.lastDropPosition === dropPosition.forbidden;
    }
    hide() {
        if (isPresent$1(this.dropIndicator)) {
            this.dropIndicator.style.display = 'none';
        }
    }
    show() {
        if (isPresent$1(this.dropIndicator)) {
            this.dropIndicator.style.display = '';
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: RowReorderService, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: RowReorderService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: RowReorderService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { rowReorder: [{
                type: Output
            }] } });

/**
 * Represents the status bar template of the Grid. Allows you to visualize the aggregates using custom rendering inside the template.
 * The template context has the following field:
 * - `aggregates`&mdash;The [SelectionAggregates]({% slug api_grid_selectionaggregates %}) object that contains all calculated aggregates.
 * Use the Angular [ngFor](link:site.data.urls.angular['ngfor']) structural directive combined with the [KeyValuePipe](https://angular.io/api/common/KeyValuePipe)
 * to loop through the aggregates as key-value pairs.
 */
class StatusBarTemplateDirective {
    templateRef;
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StatusBarTemplateDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: StatusBarTemplateDirective, isStandalone: true, selector: "[kendoGridStatusBarTemplate]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StatusBarTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridStatusBarTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }]; } });

/**
 * @hidden
 */
class ClipboardService {
    contextService;
    targetColField;
    targetRowIndex;
    constructor(contextService) {
        this.contextService = contextService;
    }
    createClipboardData(data, columns, options) {
        let result = {
            gridItems: [],
            dataString: ''
        };
        const fieldCols = columns.flatMap(c => c instanceof ColumnComponent && isPresent$1(c.field) ? [c] : []);
        const clipboardData = { items: [], dataStrings: [] };
        const colFields = fieldCols.map(c => c.field);
        if (options.wholeRow) {
            this.targetColField = fieldCols[0]?.field;
            this.targetRowIndex = data[0].dataRowIndex;
            data.forEach(item => {
                clipboardData.items.push({ dataItem: { ...item.dataItem }, fields: colFields });
                clipboardData.dataStrings.push(this.itemToString(item.dataItem, fieldCols));
            });
            result = {
                gridItems: options.operationType === 'cut' ? clipboardData.items.map(item => {
                    item.fields.forEach(field => item.dataItem[field] = null);
                    return item;
                }) : [...clipboardData.items],
                dataString: options.copyHeaders ? this.addHeaders(clipboardData.dataStrings.join(`\r\n`), fieldCols) : clipboardData.dataStrings.join(`\n`)
            };
        }
        else {
            if (options.target === 'selection') {
                const { tabular, groups } = this.groupSelection();
                const selectionDirective = this.contextService.grid.selectionDirective;
                const colIdentifier = selectionDirective.columnKey;
                if (tabular) {
                    const selectionKeys = groups[0].items.map(item => item.columnKey);
                    const selectedFieldCols = columns.flatMap((c, i) => (c instanceof ColumnComponent && c.field) && isPresent$1((selectionKeys.find(k => typeof colIdentifier === 'function' ? k === colIdentifier(c, i) : k === i))) ? [c] : []);
                    const selectedColFields = selectedFieldCols.map(c => c.field);
                    this.targetColField = selectedColFields[0];
                    result.dataString = data.flatMap(item => {
                        const itemString = this.itemToString(item.dataItem, selectedFieldCols);
                        const existingItem = isPresent$1(itemString);
                        if (!isPresent$1(this.targetRowIndex) && isPresent$1(itemString)) {
                            this.targetRowIndex = item.dataRowIndex;
                        }
                        if (options.operationType === 'cut') {
                            selectedColFields.forEach(f => item.dataItem[f] = null);
                        }
                        result.gridItems.push({
                            dataItem: item.dataItem,
                            fields: selectedColFields
                        });
                        return existingItem ? [itemString] : [];
                    }).join(`\r\n`);
                    if (options.copyHeaders) {
                        result.dataString = this.addHeaders(result.dataString, selectedFieldCols);
                    }
                }
                else { // split per row (uneven rows)
                    const rowIdentifier = selectionDirective.selectionKey;
                    result.dataString = data.flatMap(item => {
                        // determine cols per item
                        const key = rowIdentifier ?
                            typeof rowIdentifier === 'string' ? item.dataItem[rowIdentifier] : rowIdentifier({ index: item.dataRowIndex, dataItem: item.dataItem }) :
                            item.dataRowIndex;
                        const selectionKeys = groups.find(gr => gr.value === key).items.map(item => item.columnKey);
                        const selectedFieldCols = columns.flatMap((c, i) => (c instanceof ColumnComponent && c.field) && isPresent$1(selectionKeys.find(k => typeof colIdentifier === 'function' ? k === colIdentifier(c, i) : k === i)) ? [c] : []);
                        const selectedColFields = selectedFieldCols.map(c => c.field);
                        if (!this.targetColField) {
                            this.targetColField = selectedColFields[0];
                        }
                        const itemString = this.itemToString(item.dataItem, selectedFieldCols);
                        const existingItem = isPresent$1(itemString);
                        if (!isPresent$1(this.targetRowIndex) && existingItem) {
                            this.targetRowIndex = item.dataRowIndex;
                        }
                        if (existingItem) {
                            if (options.operationType === 'cut') {
                                selectedColFields.forEach(f => item.dataItem[f] = null);
                            }
                            result.gridItems.push({
                                dataItem: item.dataItem,
                                fields: selectedColFields
                            });
                        }
                        return existingItem ? options.copyHeaders ? [this.addHeaders(itemString, selectedFieldCols)] : [itemString] : [];
                    }).join(`\r\n`);
                }
            }
            else {
                const item = data[0];
                const col = columns[item.colIndex];
                const colField = col.field;
                const title = col.title;
                const copiedData = item.dataItem[colField];
                this.targetRowIndex = item.dataRowIndex;
                this.targetColField = colField;
                if (options.operationType === 'cut' && colField) {
                    item.dataItem[colField] = null;
                }
                result = {
                    gridItems: [{
                            dataItem: item.dataItem,
                            fields: colField ? [colField] : []
                        }],
                    dataString: options.copyHeaders ? [title || colField, copiedData].join(`\r\n`) : colField ? copiedData : ``
                };
            }
        }
        return result;
    }
    getGridData(data, columns, targetType, targetRowIndex, options) {
        const separator = data.includes(`\r\n`) ? `\r\n` : data.includes(`\n`) ? `\n` : null;
        const dataRows = separator ? data.split(separator).filter(rowData => rowData.length) : [data];
        this.targetRowIndex = targetRowIndex;
        if (targetType === 'activeCell') {
            if (options.wholeRow) {
                this.targetColField = columns.find(c => c instanceof ColumnComponent && c.field)?.field;
            }
            else {
                const activeCellIndex = this.contextService.grid.activeCell.colIndex;
                for (let i = 0; i < columns.length; i++) {
                    const col = columns[i];
                    if (col instanceof ColumnComponent && col.field && i >= activeCellIndex) {
                        this.targetColField = col.field;
                        break;
                    }
                }
            }
        }
        else {
            if (options.wholeRow || !options.isCellSelection) {
                this.targetColField = (columns.filter(c => c instanceof ColumnComponent && c.field))[0]['field'];
            }
            else {
                const { groups } = this.groupSelection();
                const selectionDirective = this.contextService.grid.selectionDirective;
                const colIdentifier = selectionDirective.columnKey;
                const visibleCols = columns.filter(c => c.isVisible);
                const selectionKeys = groups[0].items.map(item => item.columnKey);
                const selectedFieldCols = visibleCols.flatMap((c, i) => (c instanceof ColumnComponent && c.field) && isPresent$1(selectionKeys.find(k => typeof colIdentifier === 'function' ? k === colIdentifier(c, i) : k === i)) ? [c] : []);
                const selectedColFields = selectedFieldCols.map(c => c.field);
                this.targetColField = selectedColFields[0];
            }
        }
        const items = dataRows.map(rowString => {
            const cells = rowString.includes(`\t`) ? rowString.split(`\t`) : [rowString];
            const colFields = columns.flatMap(c => (c instanceof ColumnComponent) && c.field ? [c.field] : []);
            const targetColFieldIndex = colFields.indexOf(this.targetColField);
            const affectedFields = colFields.slice(targetColFieldIndex, targetColFieldIndex + cells.length);
            const item = {};
            colFields.slice(targetColFieldIndex, targetColFieldIndex + cells.length).forEach((colField, index) => item[colField] = cells[index]);
            return {
                dataItem: item,
                fields: affectedFields
            };
        });
        return items;
    }
    itemToString = (item, cols) => {
        if (!cols.length) {
            return null;
        }
        return cols.map(col => item[col.field]).join(`\t`);
    };
    groupSelection() {
        const selection = this.contextService.grid.selection;
        const groups = groupBy(selection, [{ field: 'itemKey' }])
            .map(gr => {
            gr.items.sort((a, b) => a.columnKey - b.columnKey);
            return gr;
        });
        for (let i = 1; i < groups.length; i++) {
            if (!this.areEqual(groups[i].items, groups[i - 1].items)) {
                return {
                    tabular: false,
                    groups
                };
            }
        }
        return {
            tabular: true,
            groups
        };
    }
    areEqual(arr1, arr2) {
        if (arr1.length !== arr2.length) {
            return false;
        }
        for (let i = 0; i < arr1.length; i++) {
            if (arr1[i].columnKey !== arr2[i].columnKey) {
                return false;
            }
        }
        return true;
    }
    addHeaders(initialData, cols) {
        const headersRowData = cols.map(c => c.title || c.field).join(`\t`);
        return `${headersRowData}\r\n${initialData}`;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ClipboardService, deps: [{ token: ContextService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ClipboardService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ClipboardService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: ContextService }]; } });

/**
 * @hidden
 */
class StatusBarComponent {
    aggregateService;
    hostClasses = true;
    get isStatusBarTemplate() {
        return this.statusBarTemplate ? '' : 'none';
    }
    statusBarTemplate;
    constructor(aggregateService) {
        this.aggregateService = aggregateService;
    }
    ngOnInit() {
        this.aggregateService.init();
    }
    get aggregates() {
        return this.aggregateService.aggregates;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StatusBarComponent, deps: [{ token: CellSelectionAggregateService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: StatusBarComponent, isStandalone: true, selector: "kendo-grid-status-bar", inputs: { statusBarTemplate: "statusBarTemplate" }, host: { properties: { "class.k-selection-aggregates": "this.hostClasses", "class.k-grid-selection-aggregates": "this.hostClasses", "style.display": "this.isStatusBarTemplate" } }, ngImport: i0, template: `
        <ng-template
            *ngIf="statusBarTemplate"
            [ngTemplateOutlet]="statusBarTemplate?.templateRef"
            [ngTemplateOutletContext]="{ aggregates: aggregates }">
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StatusBarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-status-bar',
                    template: `
        <ng-template
            *ngIf="statusBarTemplate"
            [ngTemplateOutlet]="statusBarTemplate?.templateRef"
            [ngTemplateOutletContext]="{ aggregates: aggregates }">
        </ng-template>
    `,
                    standalone: true,
                    imports: [NgIf, NgTemplateOutlet]
                }]
        }], ctorParameters: function () { return [{ type: CellSelectionAggregateService }]; }, propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-selection-aggregates']
            }, {
                type: HostBinding,
                args: ['class.k-grid-selection-aggregates']
            }], isStatusBarTemplate: [{
                type: HostBinding,
                args: ['style.display']
            }], statusBarTemplate: [{
                type: Input
            }] } });

const createElement = () => {
    if (!isDocumentAvailable()) {
        return;
    }
    const marquee = document.createElement("div");
    marquee.className = "k-marquee";
    const marqueeColor = document.createElement("div");
    marqueeColor.className = "k-marquee-color";
    marquee.appendChild(marqueeColor);
    return marquee;
};
const POINTER_OFFSET = 2;
const MINIMAL_DRAG_DISTANCE = 5;
const offsets = {
    topLeft: { x: POINTER_OFFSET, y: POINTER_OFFSET },
    topRight: { x: -POINTER_OFFSET, y: POINTER_OFFSET },
    bottomLeft: { x: POINTER_OFFSET, y: -POINTER_OFFSET },
    bottomRight: { x: -POINTER_OFFSET, y: -POINTER_OFFSET }
};
/**
 * @hidden
 */
class GridMarqueeDirective {
    draggable;
    selection;
    cellSelection;
    domEvents;
    host;
    renderer;
    // possibly add snap
    pressArgs;
    marqueeElement;
    pressTarget;
    subscriptions;
    selectionStarted = false;
    dragEndSubscription;
    constructor(draggable, selection, cellSelection, domEvents, host, renderer) {
        this.draggable = draggable;
        this.selection = selection;
        this.cellSelection = cellSelection;
        this.domEvents = domEvents;
        this.host = host;
        this.renderer = renderer;
    }
    ngOnInit() {
        this.subscriptions = (this.draggable.kendoPress.subscribe(this.start.bind(this)));
        this.subscriptions.add(this.draggable.kendoDrag.subscribe(this.moveMarquee.bind(this)));
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.clean();
    }
    start(args) {
        const isInvalidTarget = args.originalEvent.target.matches('.k-grid-content, .k-grid-content-locked, .k-grid-aria-root, .k-checkbox');
        const isRowReorderColumn = isPresent$1(args.originalEvent.target.closest('.k-drag-cell'));
        if (isInvalidTarget || isRowReorderColumn) {
            this.pressArgs = null;
            return;
        }
        this.pressArgs = args;
        this.pressTarget = null;
    }
    moveMarquee(args) {
        if (!this.pressTarget) {
            this.pressTarget = this.cellSelection.active ? this.cellSelection.mouseDownEventArgs : this.selection.mouseDownEventArgs;
        }
        const press = this.pressArgs;
        if (!press) {
            return;
        }
        if (!this.selectionStarted) {
            const distance = Math.sqrt((args.pageX - press.pageX) ** 2 + (args.pageY - press.pageY) ** 2);
            if (distance > MINIMAL_DRAG_DISTANCE) {
                this.selectionStarted = true;
                this.renderer.addClass(this.host.nativeElement, 'user-select-none');
                this.renderer.setStyle(this.host.nativeElement, 'user-select', 'none');
                this.dragEndSubscription = merge(this.domEvents.cellMouseup.pipe(take(1)), this.draggable.kendoRelease.pipe(delay(1), take(1)))
                    .subscribe(this.endSelection.bind(this));
            }
            else {
                return;
            }
        }
        this.initMarquee();
        const element = this.marqueeElement;
        const marqueeQuadrant = this.getMarqueeQuadrant(args.pageX, args.pageY, press.pageX, press.pageY);
        let left = Math.min(args.pageX, press.pageX);
        let top = Math.min(args.pageY, press.pageY);
        const width = Math.abs(args.pageX - press.pageX);
        const height = Math.abs(args.pageY - press.pageY);
        if (marqueeQuadrant) {
            left += offsets[marqueeQuadrant].x;
            top += offsets[marqueeQuadrant].y;
        }
        element.style.left = `${left}px`;
        element.style.top = `${top}px`;
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;
    }
    endSelection(args) {
        if (args.type === 'mouseup' || args.type === 'touchend') {
            if (this.cellSelection.active) {
                this.cellSelection.dragging = true;
                this.cellSelection.changes.emit(this.cellSelection.selectRange(this.pressTarget.rowIndex, this.pressTarget.column.leafIndex, args.rowIndex, args.column.leafIndex));
            }
            else if (this.selection.active) {
                this.selection.dragging = true;
                this.selection.changes.emit(this.selection.selectRange(this.pressTarget.rowIndex, args.rowIndex));
            }
        }
        this.clean();
    }
    clean() {
        if (this.marqueeElement) {
            document.body.removeChild(this.marqueeElement);
            this.marqueeElement = null;
        }
        if (this.dragEndSubscription) {
            this.dragEndSubscription.unsubscribe();
        }
        this.renderer.removeClass(this.host.nativeElement, 'user-select-none');
        this.renderer.removeStyle(this.host.nativeElement, 'user-select');
        this.dragEndSubscription = null;
        this.pressTarget = null;
        this.pressArgs = null;
        this.selectionStarted = false;
        // eslint-disable-next-line no-unused-expressions
        this.cellSelection.active ? this.cellSelection.dragging = false : this.selection.dragging = false;
    }
    initMarquee() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (!this.marqueeElement) {
            this.marqueeElement = createElement();
            document.body.appendChild(this.marqueeElement);
        }
    }
    getMarqueeQuadrant(pointerX, pointerY, startX, startY) {
        const leftHalf = pointerX < startX;
        const rightHalf = pointerX > startX;
        const topHalf = pointerY < startY;
        const bottomHalf = pointerY > startY;
        if (leftHalf && topHalf) {
            return 'topLeft';
        }
        if (leftHalf && bottomHalf) {
            return 'bottomLeft';
        }
        if (rightHalf && topHalf) {
            return 'topRight';
        }
        if (rightHalf && bottomHalf) {
            return 'bottomRight';
        }
        return null;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridMarqueeDirective, deps: [{ token: i1$3.DraggableDirective }, { token: SelectionService }, { token: CellSelectionService }, { token: DomEventsService }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: GridMarqueeDirective, isStandalone: true, selector: "[kendoGridSelectionMarquee]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridMarqueeDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridSelectionMarquee]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i1$3.DraggableDirective }, { type: SelectionService }, { type: CellSelectionService }, { type: DomEventsService }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; } });

/**
 * @hidden
 */
const update = (arr, idx, value) => ([
    ...arr.slice(0, idx + 1),
    ...(arr.slice(idx + 1).map(x => x + value))
]);
/**
 * @hidden
 */
class RowHeightService {
    total;
    rowHeight;
    detailRowHeight;
    offsets = [];
    heights = [];
    constructor(total = 0, rowHeight, detailRowHeight) {
        this.total = total;
        this.rowHeight = rowHeight;
        this.detailRowHeight = detailRowHeight;
        let agg = 0;
        for (let idx = 0; idx < total; idx++) {
            this.offsets.push(agg);
            agg += rowHeight;
            this.heights.push(rowHeight);
        }
    }
    height(rowIndex) {
        return this.heights[rowIndex];
    }
    expandDetail(rowIndex) {
        if (this.height(rowIndex) === this.rowHeight) {
            this.updateRowHeight(rowIndex, this.detailRowHeight);
        }
    }
    collapseDetail(rowIndex) {
        if (this.height(rowIndex) > this.rowHeight) {
            this.updateRowHeight(rowIndex, this.detailRowHeight * -1);
        }
    }
    isExpanded(rowIndex) {
        return this.height(rowIndex) > this.rowHeight;
    }
    index(position) {
        if (position < 0) {
            return undefined;
        }
        const result = this.offsets.reduce((prev, current, idx) => {
            if (prev !== undefined) {
                return prev;
            }
            else if (current === position) {
                return idx;
            }
            else if (current > position) {
                return idx - 1;
            }
            return undefined;
        }, undefined);
        return result === undefined ? this.total - 1 : result;
    }
    offset(rowIndex, adjustIndex = false) {
        if (adjustIndex) {
            let targetOffset = 0;
            let targetIndex = 0;
            for (let i = 0; i < rowIndex; i++) {
                targetOffset += this.rowHeight;
                targetIndex++;
                if (targetIndex === rowIndex) {
                    return targetOffset;
                }
                if (this.isExpanded(i)) {
                    targetOffset += this.detailRowHeight;
                    targetIndex++;
                    if (targetIndex === rowIndex) {
                        return targetOffset;
                    }
                }
            }
            return targetOffset;
        }
        return this.offsets[rowIndex];
    }
    totalHeight() {
        return this.heights.reduce((prev, curr) => prev + curr, 0);
    }
    updateRowHeight(rowIndex, value) {
        if (this.total > 0) {
            this.heights[rowIndex] += value;
            this.offsets = update(this.offsets, rowIndex, value);
        }
    }
}

/**
 * @hidden
 */
class ScrollAction {
    offset;
    constructor(offset) {
        this.offset = offset;
    }
}
/**
 * @hidden
 */
class PageAction {
    skip;
    take;
    constructor(skip, take) {
        this.skip = skip;
        this.take = take;
    }
}
/**
 * @hidden
 */
class ScrollBottomAction {
}
const SCROLL_BOTTOM_THRESHOLD = 2;
/**
 * @hidden
 */
class ScrollerService {
    scrollObservable;
    firstLoaded = 0;
    lastLoaded;
    lastScrollTop;
    take;
    total;
    rowHeightService;
    scrollSubscription;
    subscription;
    constructor(scrollObservable) {
        this.scrollObservable = scrollObservable;
    }
    create(rowHeightService, skip, take, total) {
        this.rowHeightService = rowHeightService;
        this.firstLoaded = skip;
        this.lastLoaded = skip + take;
        this.take = take;
        this.total = total;
        this.lastScrollTop = 0;
        const subject = new BehaviorSubject(new ScrollAction(this.rowHeightService.offset(skip)));
        this.subscription = Observable.create(observer => {
            this.unsubscribe();
            this.scrollSubscription = this.scrollObservable.subscribe(x => this.onScroll(x, observer));
        }).subscribe(x => subject.next(x));
        return subject;
    }
    destroy() {
        this.unsubscribe();
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    onScroll({ scrollTop, offsetHeight, scrollHeight, clientHeight }, observer) {
        if (!isDocumentAvailable() || (this.lastScrollTop === scrollTop)) {
            return;
        }
        const up = this.lastScrollTop >= scrollTop;
        this.lastScrollTop = scrollTop;
        let firstItemIndex = this.rowHeightService.index(scrollTop);
        let firstItemOffset = this.rowHeightService.offset(firstItemIndex);
        const lastItemIndex = this.rowHeightService.index(scrollTop + offsetHeight);
        if (!up) {
            if (lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total) {
                const overflow = (firstItemIndex + this.take) - this.total;
                if (overflow > 0) {
                    firstItemIndex = firstItemIndex - overflow;
                    firstItemOffset = this.rowHeightService.offset(firstItemIndex);
                }
                this.firstLoaded = firstItemIndex;
                observer.next(new ScrollAction(firstItemOffset));
                let nextTake = this.firstLoaded + this.take;
                this.lastLoaded = Math.min(nextTake, this.total);
                nextTake = nextTake > this.total ? this.total - this.firstLoaded : this.take;
                observer.next(new PageAction(this.firstLoaded, this.take));
            }
            else {
                const atBottom = scrollHeight - clientHeight - scrollTop < SCROLL_BOTTOM_THRESHOLD;
                if (atBottom) {
                    observer.next(new ScrollBottomAction());
                }
            }
        }
        if (up && firstItemIndex < this.firstLoaded) {
            const nonVisibleBuffer = Math.floor(this.take * 0.3);
            this.firstLoaded = Math.max(firstItemIndex - nonVisibleBuffer, 0);
            observer.next(new ScrollAction(this.rowHeightService.offset(this.firstLoaded)));
            this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);
            observer.next(new PageAction(this.firstLoaded, this.take));
        }
    }
    unsubscribe() {
        if (this.scrollSubscription) {
            this.scrollSubscription.unsubscribe();
            this.scrollSubscription = undefined;
        }
    }
}

/**
 * @hidden
 */
const columnsToResize = ({ columns }) => Math.max(1, resizableColumns(columns).length);
/**
 * @hidden
 */
const row = selector => element => element.querySelector(selector);
/**
 * @hidden
 */
const headerRow = index => element => element.querySelectorAll('thead>tr')[index];
/**
 * @hidden
 */
const cell = (index, selector = 'td') => element => element.querySelectorAll(`${selector}:not(.k-group-cell):not(.k-hierarchy-cell)`)[index];
/**
 * @hidden
 */
const offsetWidth = element => element.offsetWidth;
/**
 * @hidden
 */
const pipe = (...fns) => data => fns.reduce((state, fn) => state ? fn(state) : 0, data);
/**
 * @hidden
 */
class TableDirective {
    element;
    renderer;
    service;
    zone;
    cdr;
    locked = false;
    virtualColumns;
    get minWidth() {
        return this.firstResize ? 0 : null;
    }
    originalWidth;
    firstResize = false;
    subscription;
    autoFitSubscription;
    constructor(element, renderer, service, zone, cdr) {
        this.element = element;
        this.renderer = renderer;
        this.service = service;
        this.zone = zone;
        this.cdr = cdr;
    }
    ngOnInit() {
        const obs = this.service
            .changes.pipe(filter(e => this.locked === e.locked));
        this.subscription = obs.pipe(filter(e => e.type === 'start'), tap(this.initState.bind(this)), map(columnsToResize), switchMap((take) => obs.pipe(filter(e => e.type === 'resizeTable'), map(e => e.delta), bufferCount(take)))).subscribe(this.resize.bind(this));
        this.autoFitSubscription = this.service
            .registerTable({
            autoFit: this.autoFitObservable.bind(this),
            locked: this.locked
        });
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        if (this.autoFitSubscription) {
            this.autoFitSubscription();
            this.autoFitSubscription = null;
        }
    }
    initState() {
        this.firstResize = true;
        if (!this.virtualColumns || this.locked) {
            this.originalWidth = offsetWidth(this.element.nativeElement);
        }
    }
    resize(deltas) {
        if (!this.virtualColumns || this.locked) {
            const delta = deltas.reduce((sum, item) => sum + item, 0);
            const width = this.originalWidth + delta;
            this.renderer.setStyle(this.element.nativeElement, 'width', width + 'px');
        }
        this.cdr.detectChanges();
    }
    autoFitObservable(columnInfo) {
        return Observable.create(observer => {
            this.zone.runOutsideAngular(() => {
                this.renderer.addClass(this.element.nativeElement, 'k-autofitting');
                this.cdr.detectChanges();
                const widths = columnInfo.map(this.measureColumn.bind(this));
                this.renderer.removeClass(this.element.nativeElement, 'k-autofitting');
                observer.next(widths);
            });
        });
    }
    measureColumn(info) {
        const dom = this.element.nativeElement;
        const header = pipe(headerRow(info.level), cell(info.headerIndex, 'th'), offsetWidth)(dom);
        let data = 0;
        if (!info.isParentSpan || (info.isParentSpan && info.isLastInSpan)) {
            data = pipe(row('tbody>tr:not(.k-grouping-row):not(.k-grid-norecords)'), cell(info.index), offsetWidth)(dom);
        }
        const footer = pipe(row('tfoot>tr'), cell(info.index), offsetWidth)(dom);
        return Math.max(header, data, footer);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TableDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: ColumnResizingService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: TableDirective, isStandalone: true, selector: "[kendoGridResizableTable]", inputs: { locked: "locked", virtualColumns: "virtualColumns" }, host: { properties: { "style.min-width": "this.minWidth" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridResizableTable]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: ColumnResizingService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { locked: [{
                type: Input
            }], virtualColumns: [{
                type: Input
            }], minWidth: [{
                type: HostBinding,
                args: ['style.min-width']
            }] } });

const elementAt = (index, elements, elementOffset) => {
    for (let idx = 0, elementIdx = 0; idx < elements.length; idx++) {
        const offset = elementOffset(elements[idx]);
        if (elementIdx <= index && index <= elementIdx + offset - 1) {
            return elements[idx];
        }
        elementIdx += offset;
    }
};
const rowAt = (index, rows) => elementAt(index, rows, () => 1);
const cellAt = (index, cells) => elementAt(index, cells, cell => !hasClasses(cell, NON_DATA_CELL_CLASSES) ? parseInt(cell.getAttribute('colSpan'), 10) || 1 : 0);
const EMPTY_OBJECT = {};
/**
 * @hidden
 */
const SCROLLER_FACTORY_TOKEN = new InjectionToken('grid-scroll-service-factory');
/**
 * @hidden
 */
function DEFAULT_SCROLLER_FACTORY(observable) {
    return new ScrollerService(observable);
}
const wheelDeltaY = (e) => {
    const deltaY = e.wheelDeltaY;
    if (e.wheelDelta && (deltaY === undefined || deltaY)) {
        return e.wheelDelta;
    }
    else if (e.detail && e.axis === e.VERTICAL_AXIS) {
        return (-e.detail) * 10;
    }
    return 0;
};
const preventLockedScroll = (args, element) => {
    const delta = wheelDeltaY(args);
    const scrollTop = element.scrollTop;
    const allowScroll = (scrollTop === 0 && 0 < delta) || (element.scrollHeight <= element.offsetHeight + scrollTop && delta < 0);
    if (!allowScroll) {
        event.preventDefault();
    }
};
const translateY = (renderer, value) => el => renderer.setStyle(el, "transform", `translateY(${value}px)`);
const maybeNativeElement = el => el ? el.nativeElement : null;
const hasScrollbar = (el, parent) => el.nativeElement.offsetWidth > parent.nativeElement.clientWidth;
const setHeight = renderer => ({ el, height }) => renderer.setStyle(el, "height", `${height}px`);
const bufferSize = 1;
/**
 * @hidden
 */
class ListComponent {
    changeNotification;
    suspendService;
    groupsService;
    ngZone;
    renderer;
    scrollSyncService;
    resizeService;
    editService;
    supportService;
    navigationService;
    ctx;
    columnResizingService;
    changeDetector;
    pdfService;
    columnInfo;
    hostClass = true;
    hostRole = 'presentation';
    data;
    groups = [];
    total;
    rowHeight;
    stickyRowHeight;
    detailRowHeight;
    take;
    skip = 0;
    columns = new ColumnsContainer(() => []);
    detailTemplate;
    noRecordsTemplate;
    selectable = false;
    groupable = false;
    filterable;
    rowClass;
    rowSticky;
    loading;
    trackBy = defaultTrackBy;
    virtualColumns;
    isVirtual;
    cellLoadingTemplate;
    loadingTemplate;
    sort = new Array();
    size = 'medium';
    contentScroll = new EventEmitter();
    pageChange = new EventEmitter();
    scrollBottom = new EventEmitter();
    totalHeight;
    columnsStartIdx = 0;
    get showFooter() {
        return this.groupable && this.groupable.showFooter;
    }
    get totalWidth() {
        if (this.virtualColumns && this.columns.unlockedWidth) {
            return this.columns.unlockedWidth;
        }
    }
    container;
    lockedContainer;
    lockedTable;
    table;
    resizeSensors = new QueryList();
    scroller;
    subscriptions;
    scrollerSubscription;
    dispatcher = new Subject();
    rowHeightService;
    skipScroll;
    rebind;
    containerScrollTop = 0;
    viewportColumns;
    columnsEndIdx;
    viewportColumnsWidth;
    scrollLeft = 0;
    get lockedLeafColumns() {
        return this.columns.lockedLeafColumns;
    }
    get nonLockedLeafColumns() {
        return this.columns.nonLockedLeafColumns;
    }
    get nonLockedColumnsToRender() {
        if (this.virtualColumns && !this.pdfService.exporting) {
            return this.viewportColumns;
        }
        return this.nonLockedLeafColumns;
    }
    get leafColumns() {
        return this.columns.leafColumnsToRender;
    }
    get lockedWidth() {
        const groupCellsWidth = this.groups.length * GROUP_CELL_WIDTH;
        return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);
    }
    get nonLockedWidth() {
        if ((!this.rtl && this.lockedLeafColumns.length) || this.virtualColumns) {
            return sumColumnWidths(expandColumns(this.nonLockedColumnsToRender.toArray()));
        }
        return undefined;
    }
    get isLocked() {
        return this.lockedLeafColumns.length > 0;
    }
    rtl = false;
    columnUpdateFrame;
    hasLockedContainer;
    constructor(scrollerFactory, detailsService, changeNotification, suspendService, groupsService, ngZone, renderer, scrollSyncService, resizeService, editService, supportService, navigationService, scrollRequestService, ctx, columnResizingService, changeDetector, pdfService, columnInfo) {
        this.changeNotification = changeNotification;
        this.suspendService = suspendService;
        this.groupsService = groupsService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.scrollSyncService = scrollSyncService;
        this.resizeService = resizeService;
        this.editService = editService;
        this.supportService = supportService;
        this.navigationService = navigationService;
        this.ctx = ctx;
        this.columnResizingService = columnResizingService;
        this.changeDetector = changeDetector;
        this.pdfService = pdfService;
        this.columnInfo = columnInfo;
        this.scroller = scrollerFactory(this.dispatcher);
        this.subscriptions = detailsService.changes.subscribe(x => this.detailExpand(x));
        this.subscriptions.add(scrollRequestService.requests.subscribe(req => isPresent(req.adjustIndex) ? this.scrollTo(req.request, req.adjustIndex) : this.scrollToItem(req.request)));
    }
    ngOnInit() {
        this.init();
        this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowSync.bind(this)));
        this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowNavigationLocked.bind(this)));
        this.subscriptions.add(merge(this.columns.changes, this.resizeService.changes).subscribe(() => {
            if (this.virtualColumns) {
                this.ngZone.run(() => {
                    this.updateViewportColumns();
                    this.changeDetector.markForCheck();
                });
            }
        }));
        this.subscriptions.add(this.ctx.localization.changes.subscribe(({ rtl }) => this.rtl = rtl));
    }
    ngOnChanges(changes) {
        if (!isDocumentAvailable()) {
            return;
        }
        const changesInSkip = changes['skip'];
        const hasInitialSkip = changesInSkip && changesInSkip.firstChange && changesInSkip.currentValue > 0;
        if (hasInitialSkip) {
            this.handleInitialScrollToSkip();
        }
        if (isChanged$1("skip", changes) && !this.rebind) {
            this.skipScroll = true;
            this.container.nativeElement.scrollTop = this.rowHeightService.offset(this.skip);
        }
        if (anyChanged(['total', 'take'], changes)) {
            this.init();
        }
        this.rebind = false;
    }
    ngDoCheck() {
        if (this.virtualColumns && (!this.viewportColumns || this.viewportWidthChange())) {
            this.updateViewportColumns();
        }
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.skip && this.isVirtual) {
            this.container.nativeElement.scrollTop = this.rowHeightService.offset(this.skip);
        }
        this.resetNavigationViewport();
        this.attachContainerScroll();
        this.initResizeService();
    }
    ngAfterViewChecked() {
        const isLocked = this.isLocked;
        if (isLocked && !this.hasLockedContainer) {
            this.syncRowsHeight();
        }
        this.hasLockedContainer = isLocked;
    }
    syncRowsHeight() {
        if (this.lockedContainer) {
            syncRowsHeight(this.lockedTable.nativeElement, this.table.nativeElement);
        }
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
        if (this.resizeService) {
            this.resizeService.destroy();
        }
        this.cleanupScroller();
    }
    init() {
        if (this.suspendService.scroll) {
            return;
        }
        this.rowHeightService = new RowHeightService(this.total, this.rowHeight, this.detailRowHeight);
        this.totalHeight = this.rowHeightService.totalHeight();
        if (!isUniversal()) {
            this.ngZone.runOutsideAngular(this.createScroller.bind(this));
        }
    }
    lockedScroll() {
        if (!this.suspendService.scroll) {
            const lockedScrollTop = this.lockedContainer.nativeElement.scrollTop;
            if (lockedScrollTop !== this.containerScrollTop) {
                this.container.nativeElement.scrollTop = this.containerScrollTop = lockedScrollTop;
            }
        }
    }
    lockedMousewheel(args) {
        if (!args.ctrlKey) {
            preventLockedScroll(args, this.container.nativeElement);
            const scrollDelta = wheelDeltaY(args);
            this.container.nativeElement.scrollTop -= scrollDelta;
        }
    }
    lockedKeydown(args) {
        if (args.keyCode === Keys.PageDown || args.keyCode === Keys.PageUp) {
            const dir = args.keyCode === Keys.PageDown ? 1 : -1;
            const element = this.container.nativeElement;
            element.scrollTop += element.offsetHeight * dir * 0.8;
            args.preventDefault();
        }
    }
    detailExpand({ index, expand }) {
        if (expand) {
            this.rowHeightService.expandDetail(index);
        }
        else {
            this.rowHeightService.collapseDetail(index);
        }
        this.totalHeight = this.rowHeightService.totalHeight();
        this.resetNavigationViewport();
    }
    attachContainerScroll() {
        if (isUniversal()) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.subscriptions.add(fromEvent(this.container.nativeElement, 'scroll').pipe(map((event) => event.target), filter(() => !this.suspendService.scroll), tap((target) => {
                this.onContainerScroll(target);
                this.resetNavigationViewport();
                if (this.virtualColumns || this.isVirtual) {
                    this.handleColumnScroll();
                }
                const rowViewport = this.navigationService.viewport || EMPTY_OBJECT;
                const columnViewport = this.navigationService.columnViewport || EMPTY_OBJECT;
                this.contentScroll.emit({
                    scrollLeft: target.scrollLeft,
                    scrollTop: target.scrollTop,
                    startRow: rowViewport.firstItemIndex,
                    endRow: rowViewport.lastItemIndex,
                    startColumn: columnViewport.firstItemIndex,
                    endColumn: columnViewport.lastItemIndex
                });
            })).subscribe(this.dispatcher));
        });
        this.scrollSyncService.registerEmitter(this.container.nativeElement, 'body');
    }
    createScroller() {
        this.cleanupScroller();
        const observable = this.scroller
            .create(this.rowHeightService, this.skip, this.take, this.total);
        this.skipScroll = false;
        this.scrollerSubscription = observable.pipe(filter((x) => x instanceof PageAction), filter(() => {
            const temp = this.skipScroll;
            this.skipScroll = false;
            return !temp;
        }), tap(() => this.rebind = true))
            .subscribe((x) => this.ngZone.run(() => this.pageChange.emit(x)));
        this.scrollerSubscription.add(observable.pipe(filter((x) => x instanceof ScrollAction))
            .subscribe(this.scroll.bind(this)));
        this.scrollerSubscription.add(observable.pipe(filter((x) => x instanceof ScrollBottomAction))
            .subscribe(() => this.scrollBottom.emit()));
    }
    scroll({ offset = 0 }) {
        if (this.isVirtual) {
            [
                maybeNativeElement(this.table),
                maybeNativeElement(this.lockedTable)
            ].filter(isPresent).forEach(translateY(this.renderer, offset));
        }
        this.resetNavigationViewport();
    }
    onContainerScroll({ scrollTop }) {
        this.containerScrollTop = scrollTop;
        if (this.lockedContainer) {
            this.lockedContainer.nativeElement.scrollTop = scrollTop;
        }
    }
    handleInitialScrollToSkip() {
        const shouldScroll = () => this.isVirtual && this.skip > 0 && this.total > 0;
        const sub = this.changeNotification.changes
            .pipe(filter(shouldScroll))
            .subscribe(_ => {
            this.scrollTo({ row: this.skip });
            sub.unsubscribe();
        });
    }
    handleRowSync() {
        const isLocked = () => isPresent(this.lockedContainer);
        const onStable = () => this.ngZone.onStable.asObservable().pipe(take(1));
        return merge(this.changeNotification.changes, this.groupsService.changes
            .pipe(filter(isLocked), switchMapTo(onStable())), this.editService.changed, this.resizeService.changes, this.columnResizingService.changes
            .pipe(filter(change => change.type === 'end')), this.supportService.changes)
            .pipe(tap(() => this.resetNavigationViewport()), filter(isLocked))
            .subscribe(() => {
            const scrollTop = this.container.nativeElement.scrollTop;
            const scrollLeft = this.container.nativeElement.scrollLeft;
            this.syncRowsHeight();
            this.syncContainerHeight();
            this.lockedContainer.nativeElement.scrollTop = this.container.nativeElement.scrollTop = scrollTop;
            // fixes scroll left position in IE when editing
            this.container.nativeElement.scrollLeft = scrollLeft;
            this.resizeSensors.forEach(sensor => sensor.acceptSize());
        });
    }
    handleRowNavigationLocked() {
        return this.navigationService.changes.pipe(filter(() => isPresent(this.lockedContainer)), delay(10)).subscribe((args) => {
            if (this.lockedLeafColumns.length <= args.prevColIndex && args.colIndex < this.lockedLeafColumns.length) {
                const cell = this.navigationService.activeCell;
                if (cell && cell.colIndex + cell.colSpan < args.prevColIndex) {
                    this.container.nativeElement.scrollLeft = 0;
                }
            }
        });
    }
    scrollToVirtualRow(itemIndex, adjustIndexForDetailTemplate = true) {
        if (!isDocumentAvailable()) {
            return;
        }
        if (isPresent(this.detailTemplate) && adjustIndexForDetailTemplate) {
            itemIndex = Math.floor(itemIndex / 2);
        }
        const offset = this.rowHeightService.offset(itemIndex, !adjustIndexForDetailTemplate);
        this.container.nativeElement.scrollTop = offset;
        this.resetNavigationViewport();
    }
    scrollTo({ row, column }, adjustIndex = false) {
        if (isNumber(row)) {
            if (this.isVirtual) {
                this.scrollToVirtualRow(row, adjustIndex);
            }
            else {
                const element = rowAt(row, this.table.nativeElement.rows);
                if (element) {
                    this.container.nativeElement.scrollTop = element.offsetTop;
                }
            }
        }
        if (isNumber(column)) {
            column -= this.lockedLeafColumns.length;
            if (this.virtualColumns) {
                const columns = this.columns.leafColumnsToRender;
                let offset = 0;
                for (let idx = 0; idx < column; idx++) {
                    offset += columns[idx].width || 0;
                }
                const startOffset = this.lockedLeafColumns.length ? 0 : this.groups.length * GROUP_CELL_WIDTH + (this.detailTemplate && column > 0 ? GROUP_CELL_WIDTH : 0);
                this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(offset + startOffset);
            }
            else if (column === 0 && this.detailTemplate) {
                this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(0);
            }
            else {
                const firstRow = rowAt(0, this.table.nativeElement.rows);
                if (firstRow) {
                    const element = cellAt(column, firstRow.cells);
                    if (element) {
                        this.container.nativeElement.scrollLeft = this.elementScrollLeft(element);
                    }
                }
            }
        }
    }
    scrollToItem(item) {
        if (!isDocumentAvailable()) {
            return;
        }
        const data = this.ctx.grid.data;
        const gridData = Array.isArray(data) ? data : data.data;
        const gridDataItems = gridData.flatMap(recursiveFlatMap);
        const dataItemIndex = gridDataItems.findIndex(dataItem => dataItem[item.idField] === item.id);
        if (dataItemIndex !== -1) {
            const row = Array.from(this.table.nativeElement.rows).find((r) => {
                const dataAttribute = r.getAttribute('data-kendo-grid-item-index');
                return dataAttribute && +dataAttribute === this.ctx.grid.skip + dataItemIndex;
            });
            row && row.scrollIntoView();
            this.isVirtual && this.resetNavigationViewport();
        }
    }
    resetNavigationViewport() {
        if (!isDocumentAvailable) {
            return;
        }
        if (!this.container || !this.navigationService.tableEnabled ||
            !this.navigationService.needsViewport() || this.data.length === 0) {
            return;
        }
        const { scrollTop, offsetHeight } = this.container.nativeElement;
        const scrollBottom = scrollTop + offsetHeight;
        const firstItemIndex = this.rowHeightService.index(scrollTop);
        const lastItemIndex = this.rowHeightService.index(scrollBottom);
        const lastItemOffset = this.rowHeightService.offset(lastItemIndex);
        let viewportStart = firstItemIndex;
        let viewportEnd = lastItemIndex;
        if (isPresent(this.detailTemplate)) {
            viewportStart *= 2;
            viewportEnd *= 2;
            const firstItemHeight = this.rowHeightService.offset(firstItemIndex);
            if (firstItemHeight + this.rowHeight < scrollTop) {
                viewportStart++;
            }
            const lastItemHeight = this.rowHeightService.height(lastItemIndex);
            const lastItemExpanded = this.rowHeightService.isExpanded(lastItemIndex);
            const lastItemDetailOverflows = lastItemOffset + lastItemHeight > scrollBottom;
            if (lastItemExpanded && !lastItemDetailOverflows) {
                viewportEnd++;
            }
        }
        this.navigationService.setViewport(viewportStart, viewportEnd);
    }
    cleanupScroller() {
        if (this.scrollerSubscription) {
            this.scrollerSubscription.unsubscribe();
        }
        if (this.scroller) {
            this.scroller.destroy();
        }
    }
    initResizeService() {
        this.resizeService.connect(merge(...this.resizeSensors.map(sensor => sensor.resize)));
    }
    syncContainerHeight() {
        [maybeNativeElement(this.lockedContainer)]
            .filter(isPresent)
            .map(el => {
            el.style.height = '';
            let height = this.container.nativeElement.offsetHeight;
            if (hasScrollbar(this.table, this.container)) {
                height -= this.supportService.scrollbarWidth;
            }
            return { el, height };
        })
            .forEach(setHeight(this.renderer));
    }
    updateViewportColumns(range) {
        const columns = this.columns.nonLockedLeafColumns.toArray();
        // eslint-disable-next-line prefer-const
        let { startIdx, endIdx, offset } = range || this.calculateViewportColumns();
        const start = Math.max(0, startIdx - bufferSize);
        const end = Math.min(endIdx + bufferSize, columns.length - 1);
        if (start < startIdx) {
            for (let idx = startIdx - 1; idx >= start; idx--) {
                offset -= columns[idx].width;
            }
        }
        let currentColumns = columns.slice(start, end + 1);
        this.viewportColumnsWidth = currentColumns.reduce((total, column) => total + column.width, 0);
        const stickyBeforeStart = columns.slice(0, start).filter(c => c.sticky && !currentColumns.some(col => col === c));
        const stickyAfterEnd = columns.slice(end, columns.length).filter(c => c.sticky && !currentColumns.some(col => col === c));
        currentColumns = [...stickyBeforeStart, ...currentColumns, ...stickyAfterEnd];
        if (start > 0) {
            const offsetColumn = new ColumnBase();
            offsetColumn.width = offset;
            currentColumns.unshift(offsetColumn);
        }
        this.viewportColumns = new QueryList();
        this.viewportColumns.reset(currentColumns);
        this.columnsStartIdx = start;
        this.columnsEndIdx = end;
        this.columnInfo.columnRangeChange.emit({ start, end, offset });
        if (!range) {
            this.updateColumnViewport(startIdx, endIdx);
        }
    }
    handleColumnScroll() {
        const container = this.container.nativeElement;
        const scrollLeft = container.scrollLeft;
        if (this.scrollLeft !== scrollLeft) {
            this.scrollLeft = scrollLeft;
            const range = this.calculateViewportColumns();
            this.updateColumnViewport(range.startIdx, range.endIdx);
            if (range.startIdx < this.columnsStartIdx || this.columnsEndIdx < range.endIdx) {
                cancelAnimationFrame(this.columnUpdateFrame);
                this.columnUpdateFrame = requestAnimationFrame(() => {
                    this.ngZone.run(() => {
                        this.updateViewportColumns(range);
                        this.changeDetector.markForCheck();
                    });
                });
            }
        }
    }
    updateColumnViewport(startIdx, endIdx) {
        const lockedCount = this.lockedLeafColumns.length;
        const leafColumns = this.nonLockedLeafColumns.toArray();
        const viewportStart = lockedCount + startIdx + (this.detailTemplate && startIdx > 0 ? 1 : 0);
        let viewportEnd = lockedCount + endIdx + (this.detailTemplate ? 1 : 0);
        for (let idx = 0; idx < leafColumns.length; idx++) {
            const column = leafColumns[idx];
            if (column.isSpanColumn) {
                viewportEnd += column.childColumns.length;
            }
        }
        this.navigationService.setColumnViewport(viewportStart, viewportEnd);
    }
    calculateViewportColumns() {
        const { scrollLeft, clientWidth } = this.container.nativeElement;
        const columns = this.columns.nonLockedLeafColumns.toArray();
        const normalizedScrollLeft = this.normalizeScrollLeft(scrollLeft);
        const viewportEnd = normalizedScrollLeft + clientWidth;
        let startIdx;
        let endIdx = 0;
        let current = 0;
        let offset = 0;
        let idx;
        for (idx = 0; idx < columns.length; idx++) {
            const column = columns[idx];
            current += column.width || 0;
            if (startIdx === undefined && current > normalizedScrollLeft) {
                startIdx = idx;
                offset = current - (column.width || 0);
            }
            if (current >= viewportEnd) {
                endIdx = idx;
                break;
            }
        }
        if (!endIdx && idx > 0) {
            endIdx = columns.length - 1;
        }
        return { startIdx, endIdx, offset };
    }
    viewportWidthChange() {
        const currentWidth = this.viewportColumns.toArray().reduce((total, column) => total + column.width, 0);
        return currentWidth !== this.viewportColumnsWidth;
    }
    normalizeScrollLeft(position) {
        return this.rtl ? rtlScrollPosition(position, this.container.nativeElement, this.supportService.rtlScrollLeft) : position;
    }
    elementScrollLeft(element) {
        if (this.rtl) {
            return this.normalizeScrollLeft(this.container.nativeElement.scrollWidth - element.offsetLeft - element.offsetWidth);
        }
        return element.offsetLeft;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ListComponent, deps: [{ token: SCROLLER_FACTORY_TOKEN }, { token: DetailsService }, { token: ChangeNotificationService }, { token: SuspendService }, { token: GroupsService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: ScrollSyncService }, { token: ResizeService }, { token: EditService }, { token: BrowserSupportService }, { token: NavigationService }, { token: ScrollRequestService }, { token: ContextService }, { token: ColumnResizingService }, { token: i0.ChangeDetectorRef }, { token: PDFService }, { token: ColumnInfoService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ListComponent, isStandalone: true, selector: "kendo-grid-list", inputs: { data: "data", groups: "groups", total: "total", rowHeight: "rowHeight", stickyRowHeight: "stickyRowHeight", detailRowHeight: "detailRowHeight", take: "take", skip: "skip", columns: "columns", detailTemplate: "detailTemplate", noRecordsTemplate: "noRecordsTemplate", selectable: "selectable", groupable: "groupable", filterable: "filterable", rowClass: "rowClass", rowSticky: "rowSticky", loading: "loading", trackBy: "trackBy", virtualColumns: "virtualColumns", isVirtual: "isVirtual", cellLoadingTemplate: "cellLoadingTemplate", loadingTemplate: "loadingTemplate", sort: "sort", size: "size" }, outputs: { contentScroll: "contentScroll", pageChange: "pageChange", scrollBottom: "scrollBottom" }, host: { properties: { "class.k-grid-container": "this.hostClass", "attr.role": "this.hostRole" } }, providers: [
            {
                provide: SCROLLER_FACTORY_TOKEN,
                useValue: DEFAULT_SCROLLER_FACTORY
            }
        ], viewQueries: [{ propertyName: "container", first: true, predicate: ["container"], descendants: true, static: true }, { propertyName: "lockedContainer", first: true, predicate: ["lockedContainer"], descendants: true }, { propertyName: "lockedTable", first: true, predicate: ["lockedTable"], descendants: true }, { propertyName: "table", first: true, predicate: ["table"], descendants: true, static: true }, { propertyName: "resizeSensors", predicate: ResizeSensorComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div #lockedContainer class="k-grid-content-locked" role="presentation"
        *ngIf="isLocked" [style.width.px]="lockedWidth" tabindex="-1"
        [kendoEventsOutsideAngular]="{
            keydown: lockedKeydown,
            scroll: lockedScroll,
            mousewheel: lockedMousewheel,
            DOMMouseScroll: lockedMousewheel
        }"
        [scope]="this"
        >
        <div role="presentation">
            <table
                kendoGridResizableTable
                [locked]="true"
                #lockedTable
                class="k-grid-table"
                role="presentation"
                kendoGridTable
                [size]="size"
                [style.width.px]="lockedWidth">
                <colgroup kendoGridColGroup
                    [groups]="groups"
                    [columns]="$any(lockedLeafColumns)"
                    [detailTemplate]="detailTemplate"
                    [sort]="sort">
                </colgroup>
                <tbody kendoGridTableBody
                    role="presentation"
                    [groups]="groups"
                    [isLocked]="true"
                    [data]="data"
                    [noRecordsText]="''"
                    [columns]="$any(lockedLeafColumns)"
                    [totalColumnsCount]="leafColumns.length"
                    [totalColumns]="columns"
                    [detailTemplate]="detailTemplate"
                    [showGroupFooters]="showFooter"
                    [skip]="skip"
                    [selectable]="selectable"
                    [trackBy]="trackBy"
                    [filterable]="filterable"
                    [rowClass]="rowClass"
                    [isLoading]="loading"
                    [isVirtual]="isVirtual"
                    [cellLoadingTemplate]="cellLoadingTemplate">
                </tbody>
            </table>
            <kendo-resize-sensor></kendo-resize-sensor>
        </div>
        <div class="k-height-container" role="presentation">
            <div [style.height.px]="totalHeight"></div>
        </div>
    </div>
    <div 
        #container
        class="k-grid-content k-virtual-content"
        [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
        [lockedWidth]="lockedWidth + 1"
    >
        <div role="presentation">
            <table
                [style.width.px]="nonLockedWidth"
                #table
                kendoGridResizableTable
                [virtualColumns]="virtualColumns"
                class="k-grid-table"
                kendoGridTable
                [size]="size"
                role="presentation">
                <colgroup kendoGridColGroup
                    [groups]="isLocked ? [] : groups"
                    [columns]="$any(nonLockedColumnsToRender)"
                    [detailTemplate]="detailTemplate"
                    [sort]="sort">
                </colgroup>
                <tbody kendoGridTableBody
                    role="rowgroup"
                    [skipGroupDecoration]="isLocked"
                    [data]="data"
                    [groups]="groups"
                    [showGroupFooters]="showFooter"
                    [columns]="$any(nonLockedColumnsToRender)"
                    [allColumns]="$any(nonLockedLeafColumns)"
                    [detailTemplate]="detailTemplate"
                    [noRecordsTemplate]="noRecordsTemplate"
                    [lockedColumnsCount]="lockedLeafColumns.length"
                    [totalColumnsCount]="leafColumns.length"
                    [totalColumns]="columns"
                    [skip]="skip"
                    [selectable]="selectable"
                    [trackBy]="trackBy"
                    [filterable]="filterable"
                    [rowClass]="rowClass"
                    [rowSticky]="rowSticky"
                    [virtualColumns]="virtualColumns"
                    [isLoading]="loading"
                    [isVirtual]="isVirtual"
                    [cellLoadingTemplate]="cellLoadingTemplate">
                </tbody>
            </table>
            <kendo-resize-sensor *ngIf="isLocked"></kendo-resize-sensor>
        </div>
        <kendo-resize-sensor *ngIf="isLocked || virtualColumns"></kendo-resize-sensor>
        <div class="k-height-container" role="presentation">
            <div [style.height.px]="totalHeight"></div>
        </div>
        <div *ngIf="virtualColumns" class="k-width-container" role="presentation">
            <div [style.width.px]="totalWidth"></div>
        </div>
    </div>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: EventsOutsideAngularDirective, selector: "[kendoEventsOutsideAngular]", inputs: ["kendoEventsOutsideAngular", "scope"] }, { kind: "directive", type: TableDirective, selector: "[kendoGridResizableTable]", inputs: ["locked", "virtualColumns"] }, { kind: "directive", type: GridTableDirective, selector: "[kendoGridTable]", inputs: ["size"] }, { kind: "component", type: ColGroupComponent, selector: "[kendoGridColGroup]", inputs: ["columns", "groups", "detailTemplate", "sort"] }, { kind: "component", type: TableBodyComponent, selector: "[kendoGridTableBody]", inputs: ["columns", "allColumns", "groups", "detailTemplate", "noRecordsTemplate", "data", "skip", "selectable", "filterable", "noRecordsText", "isLocked", "isLoading", "isVirtual", "cellLoadingTemplate", "skipGroupDecoration", "showGroupFooters", "lockedColumnsCount", "totalColumnsCount", "virtualColumns", "trackBy", "rowSticky", "totalColumns", "rowClass"] }, { kind: "component", type: ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }, { kind: "directive", type: ResizableContainerDirective, selector: "[kendoGridResizableContainer]", inputs: ["lockedWidth", "kendoGridResizableContainer"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ListComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: SCROLLER_FACTORY_TOKEN,
                            useValue: DEFAULT_SCROLLER_FACTORY
                        }
                    ],
                    selector: 'kendo-grid-list',
                    template: `
    <div #lockedContainer class="k-grid-content-locked" role="presentation"
        *ngIf="isLocked" [style.width.px]="lockedWidth" tabindex="-1"
        [kendoEventsOutsideAngular]="{
            keydown: lockedKeydown,
            scroll: lockedScroll,
            mousewheel: lockedMousewheel,
            DOMMouseScroll: lockedMousewheel
        }"
        [scope]="this"
        >
        <div role="presentation">
            <table
                kendoGridResizableTable
                [locked]="true"
                #lockedTable
                class="k-grid-table"
                role="presentation"
                kendoGridTable
                [size]="size"
                [style.width.px]="lockedWidth">
                <colgroup kendoGridColGroup
                    [groups]="groups"
                    [columns]="$any(lockedLeafColumns)"
                    [detailTemplate]="detailTemplate"
                    [sort]="sort">
                </colgroup>
                <tbody kendoGridTableBody
                    role="presentation"
                    [groups]="groups"
                    [isLocked]="true"
                    [data]="data"
                    [noRecordsText]="''"
                    [columns]="$any(lockedLeafColumns)"
                    [totalColumnsCount]="leafColumns.length"
                    [totalColumns]="columns"
                    [detailTemplate]="detailTemplate"
                    [showGroupFooters]="showFooter"
                    [skip]="skip"
                    [selectable]="selectable"
                    [trackBy]="trackBy"
                    [filterable]="filterable"
                    [rowClass]="rowClass"
                    [isLoading]="loading"
                    [isVirtual]="isVirtual"
                    [cellLoadingTemplate]="cellLoadingTemplate">
                </tbody>
            </table>
            <kendo-resize-sensor></kendo-resize-sensor>
        </div>
        <div class="k-height-container" role="presentation">
            <div [style.height.px]="totalHeight"></div>
        </div>
    </div>
    <div 
        #container
        class="k-grid-content k-virtual-content"
        [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
        [lockedWidth]="lockedWidth + 1"
    >
        <div role="presentation">
            <table
                [style.width.px]="nonLockedWidth"
                #table
                kendoGridResizableTable
                [virtualColumns]="virtualColumns"
                class="k-grid-table"
                kendoGridTable
                [size]="size"
                role="presentation">
                <colgroup kendoGridColGroup
                    [groups]="isLocked ? [] : groups"
                    [columns]="$any(nonLockedColumnsToRender)"
                    [detailTemplate]="detailTemplate"
                    [sort]="sort">
                </colgroup>
                <tbody kendoGridTableBody
                    role="rowgroup"
                    [skipGroupDecoration]="isLocked"
                    [data]="data"
                    [groups]="groups"
                    [showGroupFooters]="showFooter"
                    [columns]="$any(nonLockedColumnsToRender)"
                    [allColumns]="$any(nonLockedLeafColumns)"
                    [detailTemplate]="detailTemplate"
                    [noRecordsTemplate]="noRecordsTemplate"
                    [lockedColumnsCount]="lockedLeafColumns.length"
                    [totalColumnsCount]="leafColumns.length"
                    [totalColumns]="columns"
                    [skip]="skip"
                    [selectable]="selectable"
                    [trackBy]="trackBy"
                    [filterable]="filterable"
                    [rowClass]="rowClass"
                    [rowSticky]="rowSticky"
                    [virtualColumns]="virtualColumns"
                    [isLoading]="loading"
                    [isVirtual]="isVirtual"
                    [cellLoadingTemplate]="cellLoadingTemplate">
                </tbody>
            </table>
            <kendo-resize-sensor *ngIf="isLocked"></kendo-resize-sensor>
        </div>
        <kendo-resize-sensor *ngIf="isLocked || virtualColumns"></kendo-resize-sensor>
        <div class="k-height-container" role="presentation">
            <div [style.height.px]="totalHeight"></div>
        </div>
        <div *ngIf="virtualColumns" class="k-width-container" role="presentation">
            <div [style.width.px]="totalWidth"></div>
        </div>
    </div>
    `,
                    standalone: true,
                    imports: [NgIf, EventsOutsideAngularDirective, TableDirective, GridTableDirective, ColGroupComponent, TableBodyComponent, ResizeSensorComponent, ResizableContainerDirective]
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [SCROLLER_FACTORY_TOKEN]
                }] }, { type: DetailsService }, { type: ChangeNotificationService }, { type: SuspendService }, { type: GroupsService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: ScrollSyncService }, { type: ResizeService }, { type: EditService }, { type: BrowserSupportService }, { type: NavigationService }, { type: ScrollRequestService }, { type: ContextService }, { type: ColumnResizingService }, { type: i0.ChangeDetectorRef }, { type: PDFService }, { type: ColumnInfoService }]; }, propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-grid-container']
            }], hostRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], data: [{
                type: Input
            }], groups: [{
                type: Input
            }], total: [{
                type: Input
            }], rowHeight: [{
                type: Input
            }], stickyRowHeight: [{
                type: Input
            }], detailRowHeight: [{
                type: Input
            }], take: [{
                type: Input
            }], skip: [{
                type: Input
            }], columns: [{
                type: Input
            }], detailTemplate: [{
                type: Input
            }], noRecordsTemplate: [{
                type: Input
            }], selectable: [{
                type: Input
            }], groupable: [{
                type: Input
            }], filterable: [{
                type: Input
            }], rowClass: [{
                type: Input
            }], rowSticky: [{
                type: Input
            }], loading: [{
                type: Input
            }], trackBy: [{
                type: Input
            }], virtualColumns: [{
                type: Input
            }], isVirtual: [{
                type: Input
            }], cellLoadingTemplate: [{
                type: Input
            }], loadingTemplate: [{
                type: Input
            }], sort: [{
                type: Input
            }], size: [{
                type: Input
            }], contentScroll: [{
                type: Output
            }], pageChange: [{
                type: Output
            }], scrollBottom: [{
                type: Output
            }], container: [{
                type: ViewChild,
                args: ['container', { static: true }]
            }], lockedContainer: [{
                type: ViewChild,
                args: ['lockedContainer', { static: false }]
            }], lockedTable: [{
                type: ViewChild,
                args: ['lockedTable', { static: false }]
            }], table: [{
                type: ViewChild,
                args: ['table', { static: true }]
            }], resizeSensors: [{
                type: ViewChildren,
                args: [ResizeSensorComponent]
            }] } });

/**
 * @hidden
 */
class ToolbarComponent {
    ctx;
    wrapper;
    context = {};
    role = 'toolbar';
    hostClasses = true;
    get sizeSmallClass() {
        return this.size === 'small';
    }
    get sizeMediumClass() {
        return this.size === 'medium' || !this.size;
    }
    set position(value) {
        this.context.position = value;
    }
    set size(size) {
        this._size = size;
        if (size === 'none') {
            this.wrapper.nativeElement.classList.remove('k-toolbar-sm', 'k-toolbar-md');
        }
    }
    get size() {
        return this._size;
    }
    clickHandler(ev) {
        if (this.navigable && isDocumentAvailable()) {
            const closestFocusable = closest$1(ev.target, isFocusable$1);
            const targetIndex = this.navigationService.navigableElements.indexOf(closestFocusable);
            if (targetIndex > -1) {
                this.navigationService.currentActiveIndex = targetIndex;
            }
            this.navigationService.updateFocus();
            if (ev.target === this.wrapper.nativeElement) {
                this.navigationService.focus();
            }
        }
    }
    arrowLeftListener() {
        if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
            this.navigationService.currentActiveIndex--;
            if (this.navigationService.currentActiveIndex < 0) {
                this.navigationService.currentActiveIndex = this.navigationService.navigableElements.length - 1;
            }
            this.navigationService.updateFocus();
        }
    }
    arrowRightListener() {
        if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
            this.navigationService.currentActiveIndex++;
            if (this.navigationService.currentActiveIndex >= this.navigationService.navigableElements.length) {
                this.navigationService.currentActiveIndex = 0;
            }
            this.navigationService.updateFocus();
        }
    }
    homeKeyListener(e) {
        if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
            e.preventDefault();
            this.navigationService.currentActiveIndex = 0;
            this.navigationService.updateFocus();
        }
    }
    endKeyListener(e) {
        if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
            e.preventDefault();
            this.navigationService.currentActiveIndex = this.navigationService.navigableElements.length - 1;
            this.navigationService.updateFocus();
        }
    }
    navigable;
    get toolbarTemplateRef() {
        return this.ctx.grid.toolbarTemplate ? this.ctx.grid.toolbarTemplate.templateRef : undefined;
    }
    _size = 'medium';
    navigationService;
    constructor(ctx, wrapper) {
        this.ctx = ctx;
        this.wrapper = wrapper;
        this.navigationService = this.ctx[`${this.wrapper.nativeElement.getAttribute('position')}ToolbarNavigation`];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ToolbarComponent, deps: [{ token: ContextService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ToolbarComponent, isStandalone: true, selector: "kendo-grid-toolbar", inputs: { position: "position", size: "size", navigable: "navigable" }, host: { listeners: { "click": "clickHandler($event)", "keydown.arrowleft": "arrowLeftListener($event)", "keydown.arrowright": "arrowRightListener($event)", "keydown.home": "homeKeyListener($event)", "keydown.end": "endKeyListener($event)" }, properties: { "attr.role": "this.role", "class.k-toolbar": "this.hostClasses", "class.k-grid-toolbar": "this.hostClasses", "class.k-toolbar-solid": "this.hostClasses", "class.k-toolbar-sm": "this.sizeSmallClass", "class.k-toolbar-md": "this.sizeMediumClass" } }, ngImport: i0, template: `
        <ng-template
            *ngIf="toolbarTemplateRef"
            [ngTemplateOutlet]="toolbarTemplateRef"
            [ngTemplateOutletContext]="context"></ng-template>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ToolbarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-toolbar',
                    template: `
        <ng-template
            *ngIf="toolbarTemplateRef"
            [ngTemplateOutlet]="toolbarTemplateRef"
            [ngTemplateOutletContext]="context"></ng-template>
    `,
                    standalone: true,
                    imports: [NgIf, NgTemplateOutlet]
                }]
        }], ctorParameters: function () { return [{ type: ContextService }, { type: i0.ElementRef }]; }, propDecorators: { role: [{
                type: HostBinding,
                args: ['attr.role']
            }], hostClasses: [{
                type: HostBinding,
                args: ['class.k-toolbar']
            }, {
                type: HostBinding,
                args: ['class.k-grid-toolbar']
            }, {
                type: HostBinding,
                args: ['class.k-toolbar-solid']
            }], sizeSmallClass: [{
                type: HostBinding,
                args: ['class.k-toolbar-sm']
            }], sizeMediumClass: [{
                type: HostBinding,
                args: ['class.k-toolbar-md']
            }], position: [{
                type: Input
            }], size: [{
                type: Input
            }], clickHandler: [{
                type: HostListener,
                args: ['click', ['$event']]
            }], arrowLeftListener: [{
                type: HostListener,
                args: ['keydown.arrowleft', ['$event']]
            }], arrowRightListener: [{
                type: HostListener,
                args: ['keydown.arrowright', ['$event']]
            }], homeKeyListener: [{
                type: HostListener,
                args: ['keydown.home', ['$event']]
            }], endKeyListener: [{
                type: HostListener,
                args: ['keydown.end', ['$event']]
            }], navigable: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class GridMessages extends ComponentMessages {
    /**
     * The text for the empty group panel.
     */
    groupPanelEmpty;
    /**
     * The no-records text.
     */
    noRecords;
    /**
     * The label of the pager. Follows the pattern **Page {currentPage} of {totalPages}** by default.
     * Тhe default label text when the current page is 1, and the total number of pages is 10 will be
     * **Page navigation, page 1 of 10**.
     *
     * The message consists of several parts - the current page number, the total number of pages, and a localizable string.
     * To allow for reordering its parts, the `pagerLabel` input accepts a string with placeholders for the current page
     * and total number of pages. The `{currentPage}` and `{totalPages}` placeholders will be replaced
     * internally with the respective actual values. [See example](slug:globalization_grid#toc-custom-messages).
     */
    pagerLabel;
    /**
     * The label for the **First page** button.
     */
    pagerFirstPage;
    /**
     * The label for the **Last page** button.
     */
    pagerLastPage;
    /**
     * The label for the **Previous page** button.
     */
    pagerPreviousPage;
    /**
     * The label for the **Next page** button.
     */
    pagerNextPage;
    /**
     * The text displayed before the pager input.
     */
    pagerPage;
    /**
     * The text displayed after the page-size selector.
     */
    pagerItemsPerPage;
    /**
     * The text displayed before the total-page number.
     */
    pagerOf;
    /**
     * The text displayed after the total number of items.
     */
    pagerItems;
    /**
     * The title attribute of the page number input element.
     */
    pagerPageNumberInputTitle;
    /**
     * The text of the aria-label attribute applied to the page number input element.
     */
    pagerInputLabel;
    /**
     * The text of the title and `aria-label` attributes applied to the page chooser in the Grid Pager.
     */
    pagerSelectPage;
    /**
     * The label of the filter cell or icon.
     */
    filter;
    /**
     * The label of the filter input.
     *
     * The filter input label consists of a two-part message - the name of the column and a localizable string.
     * For a column named **Product Name**, the default label will be **Product Name Filter**.
     *
     * To allow reordering the column name and the localizable part, the `filterInputLabel` accepts a string with a
     * placeholder for the column name, for example, **filter for {columnName}**. The `{columnName}` placeholder will be replaced
     * internally with the current column name, and the resulting label will be rendered as **filter for Product Name**.
     * [See example](slug:globalization_grid#toc-custom-messages).
     */
    filterInputLabel;
    /**
     * The title of the filter menu icon.
     *
     * The title consists of a two-part message - the name of the column and a localizable string.
     * For a column named **Product Name**, the default title will be **Product Name Filter Menu**.
     *
     * To allow reordering the column name and the localizable part, the `filterMenuTitle` accepts a string with a
     * placeholder for the column name, for example, **filter for {columnName}**. The `{columnName}` placeholder will be replaced
     * internally with the current column name, and the resulting title will be rendered as **filter for Product Name**.
     * [See example](slug:globalization_grid#toc-custom-messages).
     */
    filterMenuTitle;
    /**
     * The label of the filter menu operators DropDownList.
     *
     * The label consists of a two-part message - the name of the column and a localizable string.
     * For a column named **Product Name**, the default label will be **Product Name Filter Menu Operators**.
     *
     * To allow reordering the column name and the localizable part, the `filterMenuOperatorsDropDownLabel` accepts a string with a
     * placeholder for the column name, for example, **filter operators for {columnName**'. The `{columnName}` placeholder will be replaced
     * internally with the current column name, and the resulting label will be rendered as **filter operators for Product Name**.
     * [See example](slug:globalization_grid#toc-custom-messages).
     */
    filterMenuOperatorsDropDownLabel;
    /**
     * The label of the filter menu logic DropDownList.
     *
     * The label consists of a two-part message - the name of the column and a localizable string.
     * For a column named **Product Name**, the default label will be **Product Name Filter Menu Logic**.
     *
     * To allow reordering the column name and the localizable part, the `filterMenuLogicDropDownLabel` accepts a string with a
     * placeholder for the column name, for example, **filter logic for {columnName}**. The `{columnName}` placeholder will be replaced
     * internally with the current column name, and the resulting label will be rendered as **filter logic for Product Name**.
     * [See example](slug:globalization_grid#toc-custom-messages).
     */
    filterMenuLogicDropDownLabel;
    /**
     * The label of the filter cell operators DropDownList.
     *
     * The label consists of a two-part message - the name of the column and a localizable string.
     * For a column named **Product Name**, the default label will be **Filter cell operators for Product Name**.
     *
     * To allow reordering the column name and the localizable part, the `filterCellOperatorLabel` accepts a string with a
     * placeholder for the column name, for example, **Filter operators for {columnName}**. The `{columnName}` placeholder will be replaced
     * internally with the current column name, and the resulting label will be rendered as **Filter operators for Product Name**.
     * [See example](slug:globalization_grid#toc-custom-messages).
     */
    filterCellOperatorLabel;
    /**
     * The label of the boolean filter cell DropDownList.
     *
     * The label consists of a two-part message - the name of the column and a localizable string.
     * For a column named **Product Name**, the default label will be **Boolean filter cell for Product Name**.
     *
     * To allow reordering the column name and the localizable part, the `booleanFilterCellLabel` accepts a string with a
     * placeholder for the column name, for example, **Boolean Filter operator for {columnName}**. The `{columnName}` placeholder will be replaced
     * internally with the current column name, and the resulting label will be rendered as **Boolean Filter operator for Product Name**.
     * [See example](slug:globalization_grid#toc-custom-messages).
     */
    booleanFilterCellLabel;
    /**
     * The text of the `Equal` (**Is equal to**) filter operator.
     */
    filterEqOperator;
    /**
     * The text of the `NotEqual` (**Is not equal to**) filter operator.
     */
    filterNotEqOperator;
    /**
     * The text of the `IsNull` (**Is null**) filter operator.
     */
    filterIsNullOperator;
    /**
     * The text of the `IsNotNull` (**Is not null**) filter operator.
     */
    filterIsNotNullOperator;
    /**
     * The text of the `IsEmpty` (**Is empty**) filter operator.
     */
    filterIsEmptyOperator;
    /**
     * The text of the `IsNotEmpty` (**Is not empty**) filter operator.
     */
    filterIsNotEmptyOperator;
    /**
     * The text of the `StartsWith` (**Starts with**) filter operator.
     */
    filterStartsWithOperator;
    /**
     * The text of the `Contains` (**Contains**) filter operator.
     */
    filterContainsOperator;
    /**
     * The text of the `DoesNotContain` (**Does not contain**) filter operator.
     */
    filterNotContainsOperator;
    /**
     * The text of the `EndsWith` (**Ends with**) string filter operator.
     */
    filterEndsWithOperator;
    /**
     * The text of the `GreaterOrEqualTo` (**Is greater than or equal to**) numeric filter operator.
     */
    filterGteOperator;
    /**
     * The text of the `Greater` (**Is greater than**) numeric filter operator.
     */
    filterGtOperator;
    /**
     * The text of the `LessOrEqualTo` (**Is less than or equal to**) numeric filter operator.
     */
    filterLteOperator;
    /**
     * The text of the `Less` (**Is less than**) numeric filter operator.
     */
    filterLtOperator;
    /**
     * The text of the `IsTrue` Boolean filter option.
     */
    filterIsTrue;
    /**
     * The text of the `IsFalse` Boolean filter option.
     */
    filterIsFalse;
    /**
     * The text of the `(All)` option for Boolean filter.
     */
    filterBooleanAll;
    /**
     * The text of the `AfterOrEqualTo` (**Is after or equal to**) date filter operator.
     */
    filterAfterOrEqualOperator;
    /**
     * The text of the `After` (**Is after**) date filter operator.
     */
    filterAfterOperator;
    /**
     * The text of the `Before` (**Is before**) date filter operator.
     */
    filterBeforeOperator;
    /**
     * The text of the `BeforeOrEqualTo` (**Is before or equal to**) date filter operator.
     */
    filterBeforeOrEqualOperator;
    /**
     * The text of the **Filter** button.
     */
    filterFilterButton;
    /**
     * The text of the **Clear filter** button.
     */
    filterClearButton;
    /**
     * The text of the `And` filter logic.
     */
    filterAndLogic;
    /**
     * The text of the `Or` filter logic.
     */
    filterOrLogic;
    /**
     * The loading text. The `loading` property is part of the accessibility support of the Grid.
     * Its value is detectable by screen readers and is not otherwise visible.
     */
    loading;
    /**
     * The text of the `aria-label` attribute placed on the Grid focusable element.
     */
    gridLabel;
    /**
     * The title of the column menu icon.
     *
     * The title consists of a two-part message - the name of the column and a localizable string.
     * For a column named **Product Name**, the default title will be **Product Name Column Menu**.
     *
     * To allow reordering the column name and the localizable part, the `columnMenu` accepts a string with a
     * placeholder for the column name, for example, **menu for {columnName}**. The `{columnName}` placeholder will be replaced
     * internally with the current column name, and the resulting title will be rendered as **menu for Product Name**.
     * [See example](slug:globalization_grid#toc-custom-messages).
     */
    columnMenu;
    /**
     * The text that is displayed in the column menu for the set column position item.
     */
    setColumnPosition;
    /**
     * The text that is displayed in the column menu for the column items.
     */
    columns;
    /**
     * The text that is displayed in the column menu for the lock item.
     */
    lock;
    /**
     * The text that is displayed in the column menu for the unlock item.
     */
    unlock;
    /**
     * The text that is displayed in the column menu for the stick item.
     */
    stick;
    /**
     * The text that is displayed in the column menu for the unstick item.
     */
    unstick;
    /**
     * The label of the sort icon.
     */
    sortable;
    /**
     * The text that is displayed in the column menu for the ascending sort item.
     */
    sortAscending;
    /**
     * The text that is displayed in the column menu for the descending sort item.
     */
    sortDescending;
    /**
     * The text shown in the column menu for the autosize this column item.
     */
    autosizeThisColumn;
    /**
     * The text shown in the column menu for the autosize all columns item.
     */
    autosizeAllColumns;
    /**
     * The title of the Group Chip indicating the ascending sorting order of the groups.
     */
    sortedAscending;
    /**
     * The title of the Group Chip indicating the descending sorting order of the groups
     */
    sortedDescending;
    /**
     * The status announcement when a column is no longer sorted.
     */
    sortedDefault;
    /**
     * The text that is displayed in the column menu or in the column chooser item
     * for the **Apply** button of the columns.
     */
    columnsApply;
    /**
     * The text that is displayed in the column menu or in the column chooser item
     * for the **Reset** button of the columns.
     */
    columnsReset;
    /**
     * The title of the expand icon of detail rows.
     */
    detailExpand;
    /**
     * The title of the collapse icon of detail rows.
     */
    detailCollapse;
    /**
     * The text of the Today button of the Date filter.
     */
    filterDateToday;
    /**
     * The title of the Toggle button of the Date filter.
     */
    filterDateToggle;
    /**
     * The title of the Decrement button of the Numeric filter.
     */
    filterNumericDecrement;
    /**
     * The title of the Increment button of the Numeric filter.
     */
    filterNumericIncrement;
    /**
     * The labels of the checkbox column checkboxes.
     */
    selectionCheckboxLabel;
    /**
     * The label of the checkbox column select all checkbox.
     */
    selectAllCheckboxLabel;
    /**
     * The text of the title and `aria-label` attributes applied to the collapse icon of group rows.
     */
    groupCollapse;
    /**
     * The text of the title and `aria-label` attributes applied to the expand icon of group rows.
     */
    groupExpand;
    /**
     * The label for the top toolbar.
     */
    topToolbarLabel;
    /**
     * The label for the bottom toolbar.
     */
    bottomToolbarLabel;
    /**
     * The label for the group panel toolbar.
     */
    groupPanelLabel;
    /**
     * The label for the Grid drag row handle.
     */
    dragRowHandleLabel;
    /**
     * The title for the column menu Filter tab.
     */
    columnMenuFilterTabTitle;
    /**
     * The title for the column menu General tab.
     */
    columnMenuGeneralTabTitle;
    /**
     * The title for the column menu Columns tab.
     */
    columnMenuColumnsTabTitle;
    /**
     * The text for the Group pane Chip Menu Move as previous item.
     */
    groupChipMenuPrevious;
    /**
     * The text for the Group pane Chip Menu Move as next item.
     */
    groupChipMenuNext;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridMessages, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: GridMessages, selector: "kendo-grid-messages-base", inputs: { groupPanelEmpty: "groupPanelEmpty", noRecords: "noRecords", pagerLabel: "pagerLabel", pagerFirstPage: "pagerFirstPage", pagerLastPage: "pagerLastPage", pagerPreviousPage: "pagerPreviousPage", pagerNextPage: "pagerNextPage", pagerPage: "pagerPage", pagerItemsPerPage: "pagerItemsPerPage", pagerOf: "pagerOf", pagerItems: "pagerItems", pagerPageNumberInputTitle: "pagerPageNumberInputTitle", pagerInputLabel: "pagerInputLabel", pagerSelectPage: "pagerSelectPage", filter: "filter", filterInputLabel: "filterInputLabel", filterMenuTitle: "filterMenuTitle", filterMenuOperatorsDropDownLabel: "filterMenuOperatorsDropDownLabel", filterMenuLogicDropDownLabel: "filterMenuLogicDropDownLabel", filterCellOperatorLabel: "filterCellOperatorLabel", booleanFilterCellLabel: "booleanFilterCellLabel", filterEqOperator: "filterEqOperator", filterNotEqOperator: "filterNotEqOperator", filterIsNullOperator: "filterIsNullOperator", filterIsNotNullOperator: "filterIsNotNullOperator", filterIsEmptyOperator: "filterIsEmptyOperator", filterIsNotEmptyOperator: "filterIsNotEmptyOperator", filterStartsWithOperator: "filterStartsWithOperator", filterContainsOperator: "filterContainsOperator", filterNotContainsOperator: "filterNotContainsOperator", filterEndsWithOperator: "filterEndsWithOperator", filterGteOperator: "filterGteOperator", filterGtOperator: "filterGtOperator", filterLteOperator: "filterLteOperator", filterLtOperator: "filterLtOperator", filterIsTrue: "filterIsTrue", filterIsFalse: "filterIsFalse", filterBooleanAll: "filterBooleanAll", filterAfterOrEqualOperator: "filterAfterOrEqualOperator", filterAfterOperator: "filterAfterOperator", filterBeforeOperator: "filterBeforeOperator", filterBeforeOrEqualOperator: "filterBeforeOrEqualOperator", filterFilterButton: "filterFilterButton", filterClearButton: "filterClearButton", filterAndLogic: "filterAndLogic", filterOrLogic: "filterOrLogic", loading: "loading", gridLabel: "gridLabel", columnMenu: "columnMenu", setColumnPosition: "setColumnPosition", columns: "columns", lock: "lock", unlock: "unlock", stick: "stick", unstick: "unstick", sortable: "sortable", sortAscending: "sortAscending", sortDescending: "sortDescending", autosizeThisColumn: "autosizeThisColumn", autosizeAllColumns: "autosizeAllColumns", sortedAscending: "sortedAscending", sortedDescending: "sortedDescending", sortedDefault: "sortedDefault", columnsApply: "columnsApply", columnsReset: "columnsReset", detailExpand: "detailExpand", detailCollapse: "detailCollapse", filterDateToday: "filterDateToday", filterDateToggle: "filterDateToggle", filterNumericDecrement: "filterNumericDecrement", filterNumericIncrement: "filterNumericIncrement", selectionCheckboxLabel: "selectionCheckboxLabel", selectAllCheckboxLabel: "selectAllCheckboxLabel", groupCollapse: "groupCollapse", groupExpand: "groupExpand", topToolbarLabel: "topToolbarLabel", bottomToolbarLabel: "bottomToolbarLabel", groupPanelLabel: "groupPanelLabel", dragRowHandleLabel: "dragRowHandleLabel", columnMenuFilterTabTitle: "columnMenuFilterTabTitle", columnMenuGeneralTabTitle: "columnMenuGeneralTabTitle", columnMenuColumnsTabTitle: "columnMenuColumnsTabTitle", groupChipMenuPrevious: "groupChipMenuPrevious", groupChipMenuNext: "groupChipMenuNext" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridMessages, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'kendo-grid-messages-base'
                }]
        }], propDecorators: { groupPanelEmpty: [{
                type: Input
            }], noRecords: [{
                type: Input
            }], pagerLabel: [{
                type: Input
            }], pagerFirstPage: [{
                type: Input
            }], pagerLastPage: [{
                type: Input
            }], pagerPreviousPage: [{
                type: Input
            }], pagerNextPage: [{
                type: Input
            }], pagerPage: [{
                type: Input
            }], pagerItemsPerPage: [{
                type: Input
            }], pagerOf: [{
                type: Input
            }], pagerItems: [{
                type: Input
            }], pagerPageNumberInputTitle: [{
                type: Input
            }], pagerInputLabel: [{
                type: Input
            }], pagerSelectPage: [{
                type: Input
            }], filter: [{
                type: Input
            }], filterInputLabel: [{
                type: Input
            }], filterMenuTitle: [{
                type: Input
            }], filterMenuOperatorsDropDownLabel: [{
                type: Input
            }], filterMenuLogicDropDownLabel: [{
                type: Input
            }], filterCellOperatorLabel: [{
                type: Input
            }], booleanFilterCellLabel: [{
                type: Input
            }], filterEqOperator: [{
                type: Input
            }], filterNotEqOperator: [{
                type: Input
            }], filterIsNullOperator: [{
                type: Input
            }], filterIsNotNullOperator: [{
                type: Input
            }], filterIsEmptyOperator: [{
                type: Input
            }], filterIsNotEmptyOperator: [{
                type: Input
            }], filterStartsWithOperator: [{
                type: Input
            }], filterContainsOperator: [{
                type: Input
            }], filterNotContainsOperator: [{
                type: Input
            }], filterEndsWithOperator: [{
                type: Input
            }], filterGteOperator: [{
                type: Input
            }], filterGtOperator: [{
                type: Input
            }], filterLteOperator: [{
                type: Input
            }], filterLtOperator: [{
                type: Input
            }], filterIsTrue: [{
                type: Input
            }], filterIsFalse: [{
                type: Input
            }], filterBooleanAll: [{
                type: Input
            }], filterAfterOrEqualOperator: [{
                type: Input
            }], filterAfterOperator: [{
                type: Input
            }], filterBeforeOperator: [{
                type: Input
            }], filterBeforeOrEqualOperator: [{
                type: Input
            }], filterFilterButton: [{
                type: Input
            }], filterClearButton: [{
                type: Input
            }], filterAndLogic: [{
                type: Input
            }], filterOrLogic: [{
                type: Input
            }], loading: [{
                type: Input
            }], gridLabel: [{
                type: Input
            }], columnMenu: [{
                type: Input
            }], setColumnPosition: [{
                type: Input
            }], columns: [{
                type: Input
            }], lock: [{
                type: Input
            }], unlock: [{
                type: Input
            }], stick: [{
                type: Input
            }], unstick: [{
                type: Input
            }], sortable: [{
                type: Input
            }], sortAscending: [{
                type: Input
            }], sortDescending: [{
                type: Input
            }], autosizeThisColumn: [{
                type: Input
            }], autosizeAllColumns: [{
                type: Input
            }], sortedAscending: [{
                type: Input
            }], sortedDescending: [{
                type: Input
            }], sortedDefault: [{
                type: Input
            }], columnsApply: [{
                type: Input
            }], columnsReset: [{
                type: Input
            }], detailExpand: [{
                type: Input
            }], detailCollapse: [{
                type: Input
            }], filterDateToday: [{
                type: Input
            }], filterDateToggle: [{
                type: Input
            }], filterNumericDecrement: [{
                type: Input
            }], filterNumericIncrement: [{
                type: Input
            }], selectionCheckboxLabel: [{
                type: Input
            }], selectAllCheckboxLabel: [{
                type: Input
            }], groupCollapse: [{
                type: Input
            }], groupExpand: [{
                type: Input
            }], topToolbarLabel: [{
                type: Input
            }], bottomToolbarLabel: [{
                type: Input
            }], groupPanelLabel: [{
                type: Input
            }], dragRowHandleLabel: [{
                type: Input
            }], columnMenuFilterTabTitle: [{
                type: Input
            }], columnMenuGeneralTabTitle: [{
                type: Input
            }], columnMenuColumnsTabTitle: [{
                type: Input
            }], groupChipMenuPrevious: [{
                type: Input
            }], groupChipMenuNext: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class LocalizedMessagesDirective extends GridMessages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LocalizedMessagesDirective, deps: [{ token: i1$2.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: LocalizedMessagesDirective, isStandalone: true, selector: "[kendoGridLocalizedMessages]", providers: [
            {
                provide: GridMessages,
                useExisting: forwardRef(() => LocalizedMessagesDirective)
            }
        ], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LocalizedMessagesDirective, decorators: [{
            type: Directive,
            args: [{
                    providers: [
                        {
                            provide: GridMessages,
                            useExisting: forwardRef(() => LocalizedMessagesDirective)
                        }
                    ],
                    selector: '[kendoGridLocalizedMessages]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i1$2.LocalizationService }]; } });

const createControl = (source) => (acc, key) => {
    acc[key] = new FormControl(source[key]);
    return acc;
};
const validateColumnsField = (columns) => expandColumns(columns.toArray())
    .filter(isColumnComponent)
    .filter(({ field }) => !isValidFieldName(field))
    .forEach(({ field }) => console.warn(ColumnConfigurationErrorMessages.fieldName(field)));
const handleExpandCollapseGroupsService = (service, expandEmitter, collapseEmitter, map) => (service.changes.pipe(filter(({ group, emit }) => emit && isPresent(group)))
    .subscribe((x) => x.expand ? expandEmitter.emit(map(x)) : collapseEmitter.emit(map(x))));
const handleExpandCollapseDetailsService = (service, expandEmitter, collapseEmitter, map) => (service.changes.pipe(filter(({ dataItem }) => isPresent(dataItem)))
    .subscribe((x) => x.expand ? expandEmitter.emit(map(x)) : collapseEmitter.emit(map(x))));
const isInEditedCell = (element, gridElement) => closest(element, matchesClasses('k-grid-edit-cell')) &&
    closest(element, matchesNodeName('kendo-grid')) === gridElement;
const NOTIFY_DELAY = 500;
/**
 * Represents the Kendo UI for Angular Data Grid component.
 *
 * @example
 * ```html
 * <kendo-grid [data]="gridData"></kendo-grid>
 * ```
 */
class GridComponent {
    supportService;
    selectionService;
    cellSelectionService;
    wrapper;
    groupInfoService;
    groupsService;
    changeNotification;
    detailsService;
    editService;
    filterService;
    pdfService;
    responsiveService;
    renderer;
    excelService;
    ngZone;
    scrollSyncService;
    domEvents;
    columnResizingService;
    changeDetectorRef;
    columnReorderService;
    columnInfoService;
    navigationService;
    sortService;
    scrollRequestService;
    localization;
    ctx;
    sizingService;
    rowReorderService;
    /**
     * Sets the data of the Grid. If an array is provided, the Grid automatically gets the total count
     * ([more information and example]({% slug binding_grid %})).
     */
    set data(value) {
        this._data = value;
        if (this.selectable && this.selectableSettings?.enabled && this.isVirtual) {
            this.blockArrowSelection = false;
        }
        if (this.notifyTimeout) {
            clearTimeout(this.notifyTimeout);
            this.notifyTimeout = null;
        }
        if (this.rowReorderable) {
            this.ngZone.runOutsideAngular(() => {
                this.notifyTimeout = setTimeout(() => {
                    this.notifyReorderContainers();
                }, NOTIFY_DELAY);
            });
        }
    }
    get data() {
        return this._data;
    }
    get hintText() {
        return this.rowReorderService.getDefaultHintText(this.columnList, this.flatData);
    }
    /**
     * Defines the page size used by the Grid pager.
     * Required by the [paging]({% slug paging_grid %}) functionality.
     */
    pageSize;
    /**
     * Defines the height (in pixels) that is used when the `scrollable` option of the Grid is set.
     * To set the height of the Grid, you can also use `style.height`. The `style.height`
     * option supports units such as `px`, `%`, `em`, `rem`, and others.
     */
    height;
    /**
     * Represent the actual height of each Grid row (`tr`) element in the DOM.
     * Required by the [virtual scrolling functionality]({% slug scrollmmodes_grid %}).
     * Set the `rowHeight` option to the exact pixels as the height of the `tr` element appears in the DOM.
     */
    rowHeight;
    /**
     * Represent the actual height of each Grid detail row (`tr`) element in the DOM.
     * Required by the [virtual scrolling functionality]({% slug scrollmmodes_grid %}).
     * Set the `detailRowHeight` option to the exact pixels as the height of the detail Grid `tr` element appears in the DOM.
     */
    detailRowHeight;
    /**
     * Defines the number of records to be skipped by the pager.
     * Required by the [paging]({% slug paging_grid %}) functionality.
     */
    get skip() {
        return this._skip;
    }
    set skip(value) {
        if (typeof value === 'number' && value >= 0) {
            this._skip = this.rowReorderService.skip = value;
        }
    }
    /**
     * Defines the scroll mode used by the Grid.
     *
     * @default 'scrollable'
     */
    scrollable = 'scrollable';
    /**
     * Enables the [single-row selection](slug:grid_row_selection) of the Grid.
     *
     * @default false
     */
    selectable = false;
    /**
     * The descriptors by which the data will be sorted ([see example]({% slug sorting_grid %})).
     */
    set sort(value) {
        if (isArray(value)) {
            this._sort = value;
        }
    }
    get sort() {
        return this._sort;
    }
    /**
     * Specifies the sizing of various Grid building blocks (e.g. tables, buttons, inputs, dropdowns, etc.)
     * @default 'medium'
     */
    set size(size) {
        this._size = size;
        if (size === 'none') {
            this.wrapper.nativeElement.classList.remove('k-grid-sm', 'k-grid-md');
        }
        this.sizingService.changes.next(this.size);
    }
    get size() {
        return this._size;
    }
    /**
     * A function that defines how to track changes for the data rows.
     * By default, the Grid tracks changes by the index of the data item.
     * Edited rows are tracked by reference.
     * [See example](slug:track_changes_grid)
     */
    trackBy = defaultTrackBy;
    /**
     * The descriptor by which the data will be filtered ([see examples]({% slug filtering_grid %})).
     */
    filter;
    /**
     * The descriptors by which the data will be grouped ([see example]({% slug grouping_grid %})).
     */
    set group(value) {
        if (isArray(value)) {
            this._group = value;
        }
    }
    get group() {
        return this._group;
    }
    /**
     * If set to `true`, the grid will render only the columns in the current viewport.
     * @default false
     */
    virtualColumns = false;
    /**
     * @hidden
     */
    get showStatusBar() {
        return !!(this.selectable);
    }
    /**
     * @hidden
     */
    get showTopToolbar() {
        return this.toolbarTemplate && ['top', 'both'].indexOf(this.toolbarTemplate.position) > -1;
    }
    /**
     * @hidden
     */
    get showBottomToolbar() {
        return this.toolbarTemplate && ['bottom', 'both'].indexOf(this.toolbarTemplate.position) > -1;
    }
    /**
     * @hidden
     */
    get isLocked() {
        return this.lockedLeafColumns.length > 0;
    }
    /**
     * @hidden
     */
    get showTopPager() {
        const position = this.pageable.position;
        return !this.isVirtual && this.pageable !== false && ['top', 'both'].indexOf(position) > -1;
    }
    /**
     * @hidden
     */
    get showBottomPager() {
        const position = this.pageable.position;
        return !this.isVirtual && this.pageable !== false && position !== 'top';
    }
    /**
     * @hidden
     */
    get hasPager() {
        return this.showTopPager || this.showBottomPager;
    }
    /**
     * @hidden
     */
    get showGroupPanel() {
        return this.groupable && this.groupable.enabled !== false;
    }
    /**
     * @hidden
     */
    get groupableEmptyText() {
        return this.groupable.emptyText;
    }
    /**
     * @hidden
     */
    get marqueeSelection() {
        return this.selectionService.enableMarquee || this.cellSelectionService.enableMarquee;
    }
    /**
     * @hidden
     */
    gridData = () => { return this.flatData; };
    /**
     * Enables the [filtering]({% slug filtering_grid %}) of the Grid columns that have their `field` option set.
     * @default false
     */
    filterable = false;
    /**
     * Enables the [sorting]({% slug sorting_grid %}) of the Grid columns that have their `field` option set.
     * @default false
     */
    sortable = false;
    /**
     * Configures the pager of the Grid ([see example](slug:paging_grid_settings)).
     * @default false
     */
    pageable = false;
    get normalizedPageableSettings() {
        return normalize(this.pageable);
    }
    /**
     * If set to `true`, the user can group the Grid by dragging the column header cells ([see example]({% slug grouping_grid %})).
     * @default false
     */
    groupable = false;
    /**
     * Enables the [row reordering]({% slug reordering_rows_grid %}) of the Grid.
     * @default false
     */
    set rowReorderable(value) {
        this._rowReorderable = value;
        if (value) {
            this.rowReorderSubscription = this.rowReorderService.rowReorder.subscribe(args => {
                this.ngZone.run(() => {
                    this.rowReorder.emit(args);
                });
            });
        }
        else {
            this.rowReorderSubscription?.unsubscribe();
        }
    }
    get rowReorderable() {
        return this._rowReorderable;
    }
    /**
     * If set to `true`, the user can use dedicated shortcuts to interact with the Grid.
     * By default, navigation is disabled and the Grid content is accessible in the normal tab sequence.
     * To enable navigation through separate Grid sections only, provide a [`GridNavigableSection`]({% slug api_grid_gridnavigablesection %}) array.
     */
    set navigable(value) {
        if (typeof value === 'boolean') {
            this._navigable = value ? ['table', 'pager', 'toolbar'] : [];
            this.ctx.navigable = value;
            return;
        }
        else {
            this.ctx.navigable = value.includes('table');
        }
        this._navigable = value;
    }
    get navigable() {
        return this._navigable;
    }
    /**
     * @hidden
     *
     * An alias for `navigable` for users who migrate from Kendo UI for jQuery.
     */
    set navigatable(value) {
        this.navigable = value;
    }
    /**
     * @hidden
     */
    get navigatable() {
        return this.navigable;
    }
    /**
     * Indicates whether the Grid columns will be resized during initialization so that
     * they fit their headers and row content.
     * Columns with `autoSize` set to `false` are excluded.
     * To dynamically update the column width to match the new content,
     * refer to [this example]({% slug resizing_columns_grid %}).
     * @default false
     */
    autoSize = false;
    /**
     * Defines a function that is executed for every data row in the component
     * ([see example](slug:styling_grid_rows)).
     */
    set rowClass(fn) {
        if (isDevMode() && typeof fn !== 'function') {
            throw new Error(GridConfigurationErrorMessages.functionType('rowClass', fn));
        }
        this._rowClass = fn;
    }
    get rowClass() {
        return this._rowClass;
    }
    /**
     * Defines a function that is executed for every data row in the component,
     * and determines whether the row will be sticky, i.e. always visible after scrolling.
     */
    set rowSticky(fn) {
        if (isDevMode() && isPresent(fn) && typeof fn !== 'function') {
            throw new Error(GridConfigurationErrorMessages.functionType('rowSticky', fn));
        }
        if (isPresent(fn)) {
            this._rowSticky = fn;
        }
    }
    get rowSticky() {
        return this._rowSticky;
    }
    /**
     * Defines a Boolean function that is executed for each data row in the component
     * ([see example]({% slug grid_selection_custom %}#toc-setting-the-selected-rows)).
     * Determines whether the row will be selected.
     */
    set rowSelected(fn) {
        if (isDevMode() && typeof fn !== 'function') {
            throw new Error(GridConfigurationErrorMessages.functionType('rowSelected', fn));
        }
        this._rowSelected = fn;
    }
    get rowSelected() {
        return this._rowSelected;
    }
    /**
     * Defines a Boolean function that is executed for each data row in the component.
     * Determines whether the row will be selectable.
     */
    set isRowSelectable(fn) {
        if (isDevMode() && typeof fn !== 'function') {
            throw new Error(GridConfigurationErrorMessages.functionType('isRowSelectable', fn));
        }
        this._isRowSelectable = fn;
    }
    get isRowSelectable() {
        return this._isRowSelectable;
    }
    /**
     * Defines a function that determines the selected state of a data cell.
     * Returns an object with `selected` and `item` properties.
     * The cell is marked as selected only if the `selected` property equals `true`.
     *
     * The function is executed for each data cell and may be called more than once
     * as part of a change detection cycle. ([see example]({% slug grid_selection_custom %}#toc-setting-the-selected-cells))
     */
    set cellSelected(fn) {
        if (isDevMode() && typeof fn !== 'function') {
            throw new Error(GridConfigurationErrorMessages.functionType('cellSelected', fn));
        }
        this._cellSelected = fn;
    }
    get cellSelected() {
        return this._cellSelected;
    }
    /**
     * Returns the currently focused cell (if any).
     */
    get activeCell() {
        return this.navigationService.activeCell;
    }
    /**
     * Returns the currently focused row (if any).
     */
    get activeRow() {
        return this.navigationService.activeRow;
    }
    /**
     * Returns the current Grid selection.
     *
     * @hidden
     */
    get selection() {
        return (this.selectable || this.selectionDirective) ?
            this.defaultSelection ? this.defaultSelection.stateToArray() : this.selectionDirective.stateToArray() :
            [];
    }
    /**
     * If set to `true`, the user can resize columns by dragging the edges (resize handles) of their header cells
     * ([see example]({% slug resizing_columns_grid %})).
     *
     * @default false
     */
    resizable = false;
    /**
     * If set to `true`, the user can reorder columns by dragging their header cells
     * ([see example]({% slug reordering_columns_grid %})).
     *
     * @default false
     */
    reorderable = false;
    /**
     * Specifies if the loading indicator of the Grid will be displayed ([see example]({% slug binding_grid %})).
     *
     * @default false
     */
    set loading(value) {
        this._loading = value;
        this.rowReorderable && this.notifyReorderContainers();
    }
    get loading() {
        return this._loading;
    }
    /**
     * Specifies if the column menu of the columns will be displayed ([see example]({% slug columnmenu_grid %})).
     *
     * @default false
     */
    columnMenu = false;
    /**
     * Specifies if the header of the grid will be hidden. The header is visible by default.
     * The header includes column headers and the [filter row](slug:filter_row).
     * @default false
     */
    hideHeader = false;
    /**
     * Fires when the Grid filter is modified through the UI.
     * You have to handle the event yourself and filter the data.
     */
    filterChange = new EventEmitter();
    /**
     * Fires when the page of the Grid is changed ([see example]({% slug paging_grid %})).
     * You have to handle the event yourself and page the data.
     */
    pageChange = new EventEmitter();
    /**
     * Fires when the grouping of the Grid is changed.
     * You have to handle the event yourself and group the data ([see example]({% slug grouping_grid %})).
     */
    groupChange;
    /**
     * Fires when the sorting of the Grid is changed ([see example]({% slug sorting_grid %})).
     * You have to handle the event yourself and sort the data.
     */
    sortChange = new EventEmitter();
    /**
     * Fires when the user selects a Grid row.
     */
    selectionChange = new EventEmitter();
    /**
     * Fires when the user drops the dragged row and reordering is performed.
     */
    rowReorder = new EventEmitter();
    /**
     * Fires when the data state of the Grid is changed.
     */
    dataStateChange = new EventEmitter();
    /**
     * Fires when the user expands a group header.
     */
    groupExpand = new EventEmitter();
    /**
     * Fires when the user collapses a group header.
     */
    groupCollapse = new EventEmitter();
    /**
     * Fires when the user expands a master row.
     */
    detailExpand = new EventEmitter();
    /**
     * Fires when the user collapses a master row.
     */
    detailCollapse = new EventEmitter();
    /**
     * Fires when the user clicks the **Edit** command button to edit a row
     * ([see example])({% slug inline_editing_grid %}#toc-editing-records-1).
     */
    edit = new EventEmitter();
    /**
     * Fires when the user clicks the **Cancel** command button to close a row
     * ([see example]({% slug inline_editing_grid %}#toc-canceling-editing-1)).
     */
    cancel = new EventEmitter();
    /**
     * Fires when the user clicks the **Save** command button to save changes in a row
     * ([see example]({% slug inline_editing_grid %}#toc-saving-records-1)).
     */
    save = new EventEmitter();
    /**
     * Fires when the user clicks the **Remove** command button to remove a row
     * ([see example]({% slug inline_editing_grid %}#toc-removing-records-1)).
     */
    remove = new EventEmitter();
    /**
     * Fires when the user clicks the **Add** command button to add a new row
     * ([see example]({% slug inline_editing_grid %}#toc-adding-records-1)).
     */
    add = new EventEmitter();
    /**
     * Fires when the user leaves an edited cell ([see example](slug:editing_incell_grid)).
     */
    cellClose = new EventEmitter();
    /**
     * Fires when the user clicks a cell ([see example](slug:editing_incell_grid)).
     */
    cellClick;
    /**
     * Fires when the user clicks the **Export to PDF** command button.
     */
    pdfExport = new EventEmitter();
    /**
     * Fires when the user clicks the **Export to Excel** command button.
     */
    excelExport = new EventEmitter();
    /**
     * Fires when the user completes the resizing of the column.
     */
    columnResize;
    /**
     * Fires when the user completes the reordering of the column.
     */
    columnReorder = new EventEmitter();
    /**
     * Fires when the user changes the visibility of the columns from the column menu or column chooser.
     */
    columnVisibilityChange = new EventEmitter();
    /**
     * Fires when the user changes the locked state of the columns from the column menu or by reordering the columns.
     */
    columnLockedChange = new EventEmitter();
    /**
     * Fires when the user changes the sticky state of the columns from the column menu.
     */
    columnStickyChange = new EventEmitter();
    /**
     * Fires when the user scrolls to the last record on the page and enables endless scrolling
     * ([see example]({% slug scrollmmodes_grid %}#toc-endless-scrolling)).
     * You have to handle the event yourself and page the data.
     */
    scrollBottom = new EventEmitter();
    /**
     * Fires when the grid content is scrolled.
     * For performance reasons, the event is triggered outside the Angular zone. Enter the Angular zone if you make any changes that require change detection.
     */
    contentScroll = new EventEmitter();
    /**
     * A query list of all declared columns.
     */
    columns = new QueryList();
    get dir() {
        return this.direction;
    }
    hostClass = true;
    get sizeSmallClass() {
        return this.size === 'small';
    }
    get sizeMediumClass() {
        return this.size === 'medium' || !this.size;
    }
    get lockedClasses() {
        return this.lockedLeafColumns.length > 0;
    }
    get virtualClasses() {
        return this.isVirtual;
    }
    get noScrollbarClass() {
        return this.scrollbarWidth === 0;
    }
    detailTemplateChildren;
    get detailTemplate() {
        if (this._customDetailTemplate) {
            return this._customDetailTemplate;
        }
        return this.detailTemplateChildren ? this.detailTemplateChildren.first : undefined;
    }
    set detailTemplate(detailTemplate) {
        this._customDetailTemplate = detailTemplate;
    }
    cellLoadingTemplateChildren;
    get cellLoadingTemplate() {
        if (this._cellLoadingTemplate) {
            return this._customDetailTemplate;
        }
        return this.cellLoadingTemplateChildren ? this.cellLoadingTemplateChildren.first : undefined;
    }
    set cellLoadingTemplate(cellLoadingTemplate) {
        this._cellLoadingTemplate = cellLoadingTemplate;
    }
    loadingTemplateChildren;
    get loadingTemplate() {
        if (this._loadingTemplate) {
            return this._loadingTemplate;
        }
        return this.loadingTemplateChildren ? this.loadingTemplateChildren.first : undefined;
    }
    set loadingTemplate(loadingTemplate) {
        this._loadingTemplate = loadingTemplate;
    }
    statusBarTemplateChildren;
    get statusBarTemplate() {
        if (this._statusBarTemplate) {
            return this._statusBarTemplate;
        }
        return this.statusBarTemplateChildren ? this.statusBarTemplateChildren.first : undefined;
    }
    set statusBarTemplate(statusBarTemplate) {
        this._statusBarTemplate = statusBarTemplate;
    }
    noRecordsTemplateChildren;
    get noRecordsTemplate() {
        if (this._customNoRecordsTemplate) {
            return this._customNoRecordsTemplate;
        }
        return this.noRecordsTemplateChildren ? this.noRecordsTemplateChildren.first : undefined;
    }
    set noRecordsTemplate(customNoRecordsTemplate) {
        this._customNoRecordsTemplate = customNoRecordsTemplate;
    }
    pagerTemplateChildren;
    get pagerTemplate() {
        if (this._customPagerTemplate) {
            return this._customPagerTemplate;
        }
        return this.pagerTemplateChildren ? this.pagerTemplateChildren.first : undefined;
    }
    set pagerTemplate(customPagerTemplate) {
        this._customPagerTemplate = customPagerTemplate;
    }
    toolbarTemplateChildren;
    get toolbarTemplate() {
        if (this._customToolbarTemplate) {
            return this._customToolbarTemplate;
        }
        return this.toolbarTemplateChildren ? this.toolbarTemplateChildren.first : undefined;
    }
    set toolbarTemplate(customToolbarTemplate) {
        this._customToolbarTemplate = customToolbarTemplate;
    }
    columnMenuTemplates;
    lockedHeader;
    header;
    footer = new QueryList();
    ariaRoot;
    dragTargetContainer;
    dropTargetContainer;
    get scrollbarWidth() {
        return this.supportService.scrollbarWidth;
    }
    get headerPadding() {
        if (isUniversal()) {
            return '';
        }
        const padding = Math.max(0, this.scrollbarWidth) + 'px';
        const right = this.rtl ? 0 : padding;
        const left = this.rtl ? padding : 0;
        return `0 ${right} 0 ${left}`;
    }
    columnMenuOptions;
    columnList;
    selectionDirective = false;
    ariaRootId = `k-${guid()}`;
    /**
     * @hidden
     */
    showLicenseWatermark = false;
    columnsContainer = new ColumnsContainer(() => this.columnList.filterHierarchy(column => {
        if (!isUniversal()) {
            column.matchesMedia = this.matchesMedia(column);
        }
        return column.isVisible;
    }));
    view = new DataCollection(() => new DataResultIterator(this.data, this.skip, this.hasGroupFooters));
    get hasGroupFooters() {
        return this.columnsContainer.hasGroupFooter;
    }
    get showFooter() {
        return this.columnsContainer.hasFooter;
    }
    get showGroupFooters() {
        return this.groupable && this.groupable.showFooter;
    }
    get ariaRowCount() {
        return this.totalColumnLevels + 1 + this.view.total + (hasFilterRow(this.filterable) ? 1 : 0);
    }
    get ariaColCount() {
        return this.columnsContainer.leafColumnsToRender.length;
    }
    get navigation() {
        return this.navigationService;
    }
    shouldGenerateColumns = true;
    direction;
    notifyTimeout = null;
    _sort = new Array();
    _group = new Array();
    _skip = 0;
    _data = [];
    cachedWindowWidth = 0;
    defaultSelection;
    _rowSelected = null;
    _isRowSelectable = null;
    _cellSelected = null;
    _customDetailTemplate;
    _cellLoadingTemplate;
    _loadingTemplate;
    _statusBarTemplate;
    _customNoRecordsTemplate;
    _customPagerTemplate;
    _customToolbarTemplate;
    _rowReorderable = false;
    leafViewportColumns;
    viewportColumns;
    _navigable = [];
    _size = 'medium';
    _loading = false;
    get isVirtual() {
        return this.scrollable === 'virtual';
    }
    get isScrollable() {
        return this.scrollable !== 'none';
    }
    get visibleColumns() {
        return this.columnsContainer.allColumns;
    }
    get lockedColumns() {
        return this.columnsContainer.lockedColumns;
    }
    get nonLockedColumns() {
        return this.columnsContainer.nonLockedColumns;
    }
    get lockedLeafColumns() {
        return this.columnsContainer.lockedLeafColumns;
    }
    get stickyColumns() {
        return this.columns.filter(column => column.sticky);
    }
    get nonLockedLeafColumns() {
        return this.columnsContainer.nonLockedLeafColumns;
    }
    get leafColumns() {
        return this.columnsContainer.leafColumns;
    }
    get totalColumnLevels() {
        return this.columnsContainer.totalLevels;
    }
    get headerColumns() {
        if (this.virtualColumns && !this.pdfService.exporting) {
            return this.viewportColumns;
        }
        return this.nonLockedColumns;
    }
    get headerLeafColumns() {
        if (this.virtualColumns && !this.pdfService.exporting) {
            return this.leafViewportColumns;
        }
        return this.nonLockedLeafColumns;
    }
    get lockedWidth() {
        const groupCellsWidth = this.group.length * GROUP_CELL_WIDTH;
        return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);
    }
    get nonLockedWidth() {
        if ((!this.rtl && this.lockedLeafColumns.length) || this.virtualColumns) {
            return !this.virtualColumns ? this.columnsContainer.unlockedWidth :
                this.leafViewportColumns.reduce((acc, column) => acc + (column.width || 0), 0);
        }
        return undefined;
    }
    get selectableSettings() {
        if (this.selectionService) {
            return this.selectionService.options;
        }
        return undefined;
    }
    get columnMenuTemplate() {
        const template = this.columnMenuTemplates.first;
        return template ? template.templateRef : null;
    }
    get totalCount() {
        if (this.isVirtual || !isPresent(this.pageSize)) {
            return this.view.total;
        }
        return this.pageSize;
    }
    /**
     * @hidden
     */
    getDefaultSelectors(type) {
        return this.rowReorderService.defaultSelectors[type];
    }
    /**
     * @hidden
     */
    getHintSettings(type) {
        return this.rowReorderService[type];
    }
    /**
     * @hidden
     */
    blockArrowSelection = false;
    selectionSubscription;
    stateChangeSubscription;
    groupExpandCollapseSubscription;
    editServiceSubscription;
    detailsServiceSubscription;
    filterSubscription;
    sortSubscription;
    columnsChangeSubscription;
    pdfSubscription;
    excelSubscription;
    columnsContainerChangeSubscription;
    cellClickSubscription;
    footerChangeSubscription;
    columnResizingSubscription;
    columnReorderSubscription;
    detachElementEventHandlers;
    localizationSubscription;
    columnVisibilityChangeSubscription;
    columnLockedChangeSubscription;
    columnStickyChangeSubscription;
    focusElementSubscription;
    columnRangeChangeSubscription;
    rowReorderSubscription;
    rtl = false;
    _rowSticky;
    constructor(supportService, selectionService, cellSelectionService, wrapper, groupInfoService, groupsService, changeNotification, detailsService, editService, filterService, pdfService, responsiveService, renderer, excelService, ngZone, scrollSyncService, domEvents, columnResizingService, changeDetectorRef, columnReorderService, columnInfoService, navigationService, sortService, scrollRequestService, localization, ctx, sizingService, rowReorderService) {
        this.supportService = supportService;
        this.selectionService = selectionService;
        this.cellSelectionService = cellSelectionService;
        this.wrapper = wrapper;
        this.groupInfoService = groupInfoService;
        this.groupsService = groupsService;
        this.changeNotification = changeNotification;
        this.detailsService = detailsService;
        this.editService = editService;
        this.filterService = filterService;
        this.pdfService = pdfService;
        this.responsiveService = responsiveService;
        this.renderer = renderer;
        this.excelService = excelService;
        this.ngZone = ngZone;
        this.scrollSyncService = scrollSyncService;
        this.domEvents = domEvents;
        this.columnResizingService = columnResizingService;
        this.changeDetectorRef = changeDetectorRef;
        this.columnReorderService = columnReorderService;
        this.columnInfoService = columnInfoService;
        this.navigationService = navigationService;
        this.sortService = sortService;
        this.scrollRequestService = scrollRequestService;
        this.localization = localization;
        this.ctx = ctx;
        this.sizingService = sizingService;
        this.rowReorderService = rowReorderService;
        const isValid = validatePackage(packageMetadata);
        this.showLicenseWatermark = shouldShowValidationUI(isValid);
        this.ctx.grid = this;
        this.groupChange = new ZoneAwareEventEmitter(this.ngZone);
        this.cellClick = new ZoneAwareEventEmitter(this.ngZone);
        this.columnResize = new ZoneAwareEventEmitter(this.ngZone);
        this.localizationSubscription = this.localization.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        });
        this.groupInfoService.registerColumnsContainer(() => this.columnList);
        this.columnInfoService.init(this.columnsContainer, () => this.columnList);
        this.columnVisibilityChangeSubscription = this.columnInfoService.visibilityChange.subscribe((changed) => {
            this.columnVisibilityChange.emit(new ColumnVisibilityChangeEvent(changed));
        });
        this.columnLockedChangeSubscription = this.columnInfoService.lockedChange.subscribe((changed) => {
            this.columnLockedChange.emit(new ColumnLockedChangeEvent(changed));
        });
        this.columnStickyChangeSubscription = this.columnInfoService.stickyChange.subscribe((changed) => {
            this.columnStickyChange.emit(new ColumnStickyChangeEvent(changed));
        });
        this.groupExpandCollapseSubscription = handleExpandCollapseGroupsService(groupsService, this.groupExpand, this.groupCollapse, ({ group, groupIndex, parentGroup }) => ({ group, groupIndex, parentGroup }));
        this.detailsServiceSubscription = handleExpandCollapseDetailsService(detailsService, this.detailExpand, this.detailCollapse, args => args);
        this.filterSubscription = this.filterService.changes.subscribe(x => {
            this.filterChange.emit(x);
        });
        this.sortSubscription = this.sortService.changes.subscribe(x => {
            this.sortChange.emit(x);
        });
        this.attachStateChangesEmitter();
        this.attachEditHandlers();
        this.attachDomEventHandlers();
        this.pdfSubscription = this.pdfService.exportClick.subscribe(this.emitPDFExportEvent.bind(this));
        this.excelSubscription = this.excelService.exportClick.subscribe(this.saveAsExcel.bind(this));
        this.columnsContainerChange();
        this.handleColumnResize();
        this.columnList = new ColumnList(this.columns);
        this.columnReorderSubscription = this.columnReorderService
            .changes.subscribe(this.reorder.bind(this));
        this.columnRangeChangeSubscription = this.columnInfoService.columnRangeChange.subscribe(this.onColumnRangeChange.bind(this));
    }
    /**
     * Expands the specified master row ([see example]({% slug hierarchy_grid %})).
     *
     * This method is provided only for backwards-compatibility with legacy versions.
     * These versions tracked the expanded state internally using the data row index.
     *
     * For new development, use the [kendoGridDetailsExpandBy directive]({% slug api_grid_expanddetailsdirective %})
     * or provide an isDetailExpanded callback. See [Controlling the Expanded State]({% slug master_detail_expanded_state_grid %})
     * for examples on how to control the expanded state.
     *
     * @param index - The data row index of the master row.
     */
    expandRow(index) {
        this.toggleDetailRowLegacy(index, true);
    }
    /**
     * Collapses the specified master row ([see example]({% slug hierarchy_grid %})).
     *
     * This method is provided only for backwards-compatibility with legacy versions.
     * These versions tracked the expanded state internally using the data row index.
     *
     * For new development, use the [kendoGridDetailsExpandBy directive]({% slug api_grid_expanddetailsdirective %})
     * or provide an isDetailExpanded callback. See [Controlling the Expanded State]({% slug master_detail_expanded_state_grid %})
     * for examples on how to control the expanded state.
     *
     * @param index - The data row index of the master row.
     */
    collapseRow(index) {
        this.toggleDetailRowLegacy(index, false);
    }
    /**
     * Expands a group header item for the given index. For example,
     * `0_1` expands the second inner group of the first master group.
     *
     * This method is provided only for backwards-compatibility with legacy versions.
     * These versions tracked the expanded group state internally using the hierarchical group index.
     *
     * When a Grid is pageable, the indexes of the groups are offset by the current Grid [skip]({% slug api_grid_gridcomponent %}#toc-skip).
     *
     * @param {string} index - The underscore separated hierarchical index of the group.
     */
    expandGroup(index) {
        this.toggleGroupRowLegacy(index, true);
    }
    /**
     * Collapses a group header item for the given index. For example,
     * `0_1` collapses the second inner group of the first master group.
     *
     * This method is provided only for backwards-compatibility with legacy versions.
     * These versions tracked the expanded group state internally using the hierarchical group index.
     *
     * When a Grid is pageable, the indexes of the groups are offset by the current Grid [skip]({% slug api_grid_gridcomponent %}#toc-skip).
     *
     * @param {string} index - The underscore separated hierarchical index of the group.
     */
    collapseGroup(index) {
        this.toggleGroupRowLegacy(index, false);
    }
    /**
     * @hidden
     */
    resetGroupsState() {
        this.groupsService.reset();
    }
    /**
     * @hidden
     */
    onDataChange() {
        this.autoGenerateColumns();
        this.changeNotification.notify();
        this.pdfService.dataChanged.emit();
        if (isPresent(this.defaultSelection)) {
            this.defaultSelection.reset();
        }
        this.initSelectionService();
        this.updateNavigationMetadata();
    }
    ngOnChanges(changes) {
        if (isChanged$1("data", changes)) {
            this.onDataChange();
        }
        if (this.lockedLeafColumns.length && anyChanged(["pageSize", "skip", "sort", "group"], changes)) {
            this.changeNotification.notify();
        }
        if (anyChanged(["pageSize", "scrollable", 'virtualColumns'], changes)) {
            this.updateNavigationMetadata();
        }
        if (isChanged$1("virtualColumns", changes)) {
            this.viewportColumns = this.leafViewportColumns = null;
        }
        if (isChanged$1("height", changes, false)) {
            this.renderer.setStyle(this.wrapper.nativeElement, 'height', `${this.height}px`);
        }
        if (isChanged$1("filterable", changes) && this.lockedColumns.length) {
            this.syncHeaderHeight(this.ngZone.onStable.asObservable().pipe(take(1)));
        }
        if (anyChanged(["columnMenu", "sortable", "filterable"], changes, false)) {
            this.columnMenuOptions = this.columnMenu && Object.assign({
                filter: Boolean(this.filterable),
                sort: Boolean(this.sortable)
            }, this.columnMenu);
        }
        if (isChanged$1("scrollable", changes) && this.isScrollable) {
            this.ngZone.onStable.pipe(take(1)).subscribe(() => this.attachScrollSync());
        }
        if (isChanged$1("selectable", changes) && this.shouldResetSelection(changes['selectable'])) {
            if (this.defaultSelection) {
                this.defaultSelection.reset();
            }
            else if (this.selectionDirective) {
                this.selectionDirective.reset();
            }
        }
        if (isChanged$1('groupable', changes, true)) {
            this.groupable = changes['groupable'].currentValue;
        }
        if (isChanged$1('navigable', changes, true)) {
            if (this.navigationService.enabled) {
                this.navigationService.setActiveSections(this.navigable);
            }
            else {
                if (this.navigable.length) {
                    this.navigationService.init(this.navigationMetadata(), this.navigable);
                }
            }
        }
    }
    ngAfterContentInit() {
        this.shouldGenerateColumns = !this.columns.length;
        this.autoGenerateColumns();
        this.columnList = new ColumnList(this.columns);
        this.columnsChangeSubscription = this.columns.changes.subscribe(() => this.verifySettings());
    }
    ngAfterViewInit() {
        this.attachScrollSync();
        this.attachElementEventHandlers();
        this.updateNavigationMetadata();
        this.applyAutoSize();
        const toolbarComponentWrapper = this.wrapper?.nativeElement?.querySelector('kendo-toolbar');
        if (toolbarComponentWrapper) {
            this.renderer.addClass(toolbarComponentWrapper, 'k-grid-toolbar');
        }
    }
    ngAfterContentChecked() {
        this.columnsContainer.refresh();
        this.verifySettings();
        this.initSelectionService();
    }
    ngOnInit() {
        if (this.navigable.length) {
            this.navigationService.init(this.navigationMetadata(), this.navigable);
        }
    }
    ngOnDestroy() {
        if (this.selectionSubscription) {
            this.selectionSubscription.unsubscribe();
        }
        if (this.stateChangeSubscription) {
            this.stateChangeSubscription.unsubscribe();
        }
        if (this.groupExpandCollapseSubscription) {
            this.groupExpandCollapseSubscription.unsubscribe();
        }
        if (this.detailsServiceSubscription) {
            this.detailsServiceSubscription.unsubscribe();
        }
        if (this.editServiceSubscription) {
            this.editServiceSubscription.unsubscribe();
        }
        if (this.pdfSubscription) {
            this.pdfSubscription.unsubscribe();
        }
        if (this.filterSubscription) {
            this.filterSubscription.unsubscribe();
        }
        if (this.sortSubscription) {
            this.sortSubscription.unsubscribe();
        }
        if (this.columnsChangeSubscription) {
            this.columnsChangeSubscription.unsubscribe();
        }
        if (this.excelSubscription) {
            this.excelSubscription.unsubscribe();
        }
        if (this.columnsContainerChangeSubscription) {
            this.columnsContainerChangeSubscription.unsubscribe();
        }
        if (this.scrollSyncService) {
            this.scrollSyncService.destroy();
        }
        if (this.detachElementEventHandlers) {
            this.detachElementEventHandlers();
        }
        if (this.defaultSelection) {
            this.defaultSelection.destroy();
        }
        if (this.cellClickSubscription) {
            this.cellClickSubscription.unsubscribe();
        }
        if (this.footerChangeSubscription) {
            this.footerChangeSubscription.unsubscribe();
        }
        this.ngZone = null;
        if (this.columnResizingSubscription) {
            this.columnResizingSubscription.unsubscribe();
        }
        if (this.columnReorderSubscription) {
            this.columnReorderSubscription.unsubscribe();
        }
        if (this.localizationSubscription) {
            this.localizationSubscription.unsubscribe();
        }
        if (this.columnVisibilityChangeSubscription) {
            this.columnVisibilityChangeSubscription.unsubscribe();
        }
        if (this.columnLockedChangeSubscription) {
            this.columnLockedChangeSubscription.unsubscribe();
        }
        if (this.columnStickyChangeSubscription) {
            this.columnStickyChangeSubscription.unsubscribe();
        }
        if (this.focusElementSubscription) {
            this.focusElementSubscription.unsubscribe();
        }
        if (this.rowReorderSubscription) {
            this.rowReorderSubscription.unsubscribe();
        }
        this.columnRangeChangeSubscription.unsubscribe();
    }
    /**
     * @hidden
     */
    attachScrollSync() {
        if (isUniversal()) {
            return;
        }
        if (this.header) {
            this.scrollSyncService.registerEmitter(this.header.nativeElement, "header");
        }
        if (this.footer) {
            this.footerChangeSubscription = observe(this.footer)
                .subscribe(footers => footers
                .map(footer => footer.nativeElement)
                .filter(isPresent)
                .forEach(element => {
                this.scrollSyncService.registerEmitter(element, "footer");
                // sync footers and content scroll positions when footer visibility is changed dynamically
                element.scrollLeft = this.wrapper.nativeElement.querySelector('.k-grid-content')?.scrollLeft;
            }));
        }
    }
    /**
     * @hidden
     */
    get ariaLabel() {
        return this.localization.get('gridLabel');
    }
    /**
     * @hidden
     */
    messageFor = token => this.localization.get(token);
    /**
     * Switches the specified table row in the edit mode ([see example]({% slug inline_editing_grid %}#toc-editing-records-1)).
     *
     * @param rowIndex - The data row index that will be switched in the edit mode.
     * @param group - The [FormGroup](link:site.data.urls.angular['formgroupapi'])
     * that describes the edit form.
     * @param options - Additional options configuring the focus target once the editor opens.
     */
    editRow(rowIndex, group, options) {
        this.editService.editRow(rowIndex, group);
        if (isPresent(options) && options.skipFocus) {
            return;
        }
        const row = `tr[data-kendo-grid-item-index="${rowIndex}"]`;
        const columnIndex = options && options.columnIndex;
        const target = isNaN(columnIndex) ? row : `${row} td[data-kendo-grid-column-index="${columnIndex}"]`;
        this.focusEditElement(target);
    }
    /**
     * Closes the editor for a given row ([see example]({% slug inline_editing_grid %}#toc-canceling-editing-1)).
     *
     * @param {number} index - The row index that will be switched out of the edit mode. If no index is provided, it is assumed
     * that the new item editor will be closed.
     */
    closeRow(index) {
        this.editService.close(index);
    }
    /**
     * Creates a new row editor ([see example]({% slug inline_editing_grid %}#toc-adding-records-1)).
     *
     * @param {FormGroup} group - The [FormGroup](link:site.data.urls.angular['formgroupapi']) that describes
     * the edit form. If called with a data item, it will build the `FormGroup` from the data item fields.
     */
    addRow(group) {
        const isFormGroup = group instanceof FormGroup;
        if (!isFormGroup) {
            const fields = Object.keys(group).reduce(createControl(group), {}); // FormBuilder?
            group = new FormGroup(fields);
        }
        this.editService.addRow(group);
        this.focusEditElement('.k-grid-add-row');
    }
    /**
     * Puts the cell that is specified by the table row and column in edit mode ([see example](slug:editing_incell_grid)).
     *
     * @param {number} rowIndex - The data row index that will be switched in the edit mode.
     * @param {number|string|any} column - The leaf column index, or the field name or the column instance that should be edited.
     * @param {FormGroup} group - The [FormGroup](link:site.data.urls.angular['formgroupapi'])
     * that describes the edit form.
     */
    editCell(rowIndex, column, group) {
        const instance = this.columnInstance(column);
        this.editService.editCell(rowIndex, instance, group);
        this.focusEditElement('.k-grid-edit-cell');
    }
    /**
     * Closes the current cell in edit mode and fires
     * the [cellClose]({% slug api_grid_gridcomponent %}#toc-cellclose) event.
     *
     * @return {boolean} Indicates whether the edited cell was closed.
     * A `false` value indicates that the
     * [cellClose]({% slug api_grid_gridcomponent %}#toc-cellclose) event was prevented.
     */
    closeCell() {
        return !this.editService.closeCell();
    }
    /**
     * Closes the current cell in edit mode.
     */
    cancelCell() {
        this.editService.cancelCell();
    }
    /**
     * Returns a flag which indicates if a row or a cell is currently edited.
     *
     * @return {boolean} A flag which indicates if a row or a cell is currently edited.
     */
    isEditing() {
        return this.editService.isEditing();
    }
    /**
     * Returns a flag which indicates if a cell is currently edited.
     *
     * @return {boolean} A flag which indicates if a cell is currently being edited.
     */
    isEditingCell() {
        return this.editService.isEditingCell();
    }
    /**
     * Initiates the PDF export ([see example]({% slug pdfexport_grid %})).
     */
    saveAsPDF() {
        this.pdfService.save(this);
    }
    /**
     * Exports the Grid element to a Drawing [Group]({% slug api_kendo-drawing_group %}) by using the `kendo-grid-pdf` component options.
     * ([see example]({% slug pdfexport_grid %}#toc-exporting-multiple-grids-to-the-same-pdf)).
     *
     * @return {Promise} A promise that will be resolved with the Drawing `Group`.
     */
    drawPDF() {
        const promise = createPromise();
        this.pdfService.draw(this, promise);
        return promise;
    }
    /**
     * Initiates the Excel export ([see example]({% slug excelexport_grid %})).
     */
    saveAsExcel() {
        this.excelService.save(this);
    }
    /**
     * Applies the minimum possible width for the specified column,
     * so that the whole text fits without wrapping. This method expects the Grid
     * to be [resizable](slug:resizing_columns_grid). The method must be executed
     * after the Grid is already populated with data.
     * [See example](slug:resizing_columns_grid#toc-auto-fitting-the-content)
     */
    autoFitColumn(column) {
        this.columnResizingService.autoFit(column);
    }
    /**
     * Adjusts the width of the specified columns to fit the entire content, including headers, without wrapping.
     * If no columns are specified, `autoFitColumns` is applied to all columns.The method must be executed
     * after the Grid is already populated with data.
     * [See example](slug:resizing_columns_grid#toc-auto-fitting-the-content)
     *
     */
    autoFitColumns(columns = this.columns) {
        let cols;
        if (columns instanceof QueryList) {
            cols = columns.toArray();
        }
        else {
            cols = columns;
        }
        this.columnResizingService.autoFit(...cols);
    }
    /**
     * @hidden
     */
    notifyPageChange(source, event) {
        if (source === "list" && !this.isVirtual) {
            return;
        }
        this.pageChange.emit(event);
    }
    /**
     * @hidden
     */
    notifyScrollBottom() {
        if (this.scrollable === 'none') {
            return;
        }
        if (hasObservers(this.scrollBottom)) {
            this.ngZone.run(() => this.scrollBottom.emit({ sender: this }));
        }
    }
    /**
     * @hidden
     */
    focusEditElement(containerSelector) {
        if (this.focusElementSubscription) {
            this.focusElementSubscription.unsubscribe();
        }
        this.ngZone.runOutsideAngular(() => {
            this.focusElementSubscription = this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                const wrapper = this.wrapper.nativeElement;
                if (!this.setEditFocus(wrapper.querySelector(containerSelector)) && this.isLocked) {
                    this.setEditFocus(wrapper.querySelector(`.k-grid-content ${containerSelector}`));
                }
                this.focusElementSubscription = null;
            });
        });
    }
    /**
     * Focuses the last active or the first cell of the Grid.
     *
     * @returns {NavigationCell} The focused cell.
     */
    focus() {
        this.assertNavigable();
        return this.navigationService.focusCell();
    }
    /**
     * Focuses the cell with the specified row and column index.
     *
     * The row index is based on the logical structure of the Grid and does not correspond to the data item index.
     * Header rows are included, starting at index 0.
     * Group headers and footers are included.
     * The row indexing is absolute and does not change with paging.
     *
     * If the Grid is configured for scrolling, including virtual scrolling, the scroll position will be updated.
     * If the row is not present on the current page, the method will have no effect.
     *
     * @param rowIndex - The logical row index to focus. The top header row has an index 0.
     * @param colIndex - The column index to focus.
     * @returns {NavigationCell} The focused cell.
     *
     */
    focusCell(rowIndex, colIndex) {
        this.assertNavigable();
        return this.navigationService.focusCell(rowIndex, colIndex);
    }
    /**
     * Focuses the next cell, optionally wrapping to the next row.
     *
     * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.
     * @returns {NavigationCell} The focused cell. If the focus is already on the last cell, returns `null`.
     */
    focusNextCell(wrap = true) {
        this.assertNavigable();
        return this.navigationService.focusNextCell(wrap);
    }
    /**
     * Focuses the previous cell. Optionally wraps to the previous row.
     *
     * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.
     * @returns {NavigationCell} The focused cell. If the focus is already on the first cell, returns `null`.
     */
    focusPrevCell(wrap = true) {
        this.assertNavigable();
        return this.navigationService.focusPrevCell(wrap);
    }
    /**
     * Scrolls to the specified row and column ([see example](slug:scrollmmodes_grid#toc-scrolling-to-a-specific-row-and-column)).
     */
    scrollTo(request) {
        this.scrollRequestService.scrollTo(request, false);
    }
    /**
     * Scrolls to the specified data item and column ([see example](slug:scrollmmodes_grid#toc-scrolling-to-a-specific-item)).
     */
    scrollToItem(request) {
        this.scrollRequestService.scrollToItem(request);
    }
    /**
     * Changes the position of the specified column.
     * The reordering of columns operates only on the level
     * which is inferred by the source column.
     * For the `reorderColumn` method to work properly,
     * the `source` column has to be visible.
     *
     * @param {ColumnBase} source - The column whose position will be changed.
     * @param {number} destIndex - The new position of the column.
     * @param {ColumnReorderConfig} options - Additional options.
     *
     */
    reorderColumn(source, destIndex, options = { before: false }) {
        const columnsForLevel = sortColumns(this.allColumnsForLevel(source.level));
        let target = columnsForLevel[destIndex];
        if (!target) {
            return;
        }
        const lastNonLocked = target.isLocked &&
            !source.isLocked &&
            this.columnsContainer.nonLockedColumns.length === 1;
        if (lastNonLocked) {
            return;
        }
        if (isSpanColumnComponent(target) && !options.before) {
            target = target.childColumns.last;
        }
        this.reorder({
            before: options.before,
            source: source,
            target: target
        });
    }
    /**
     * A function which determines if a specific row is expanded.
     */
    set isDetailExpanded(callback) {
        this.detailsService.userCallback = callback;
    }
    get isDetailExpanded() {
        return this.detailsService.userCallback;
    }
    /**
     * A function which determines if a specific group row is expanded.
     */
    set isGroupExpanded(callback) {
        this.groupsService.userCallback = callback;
        this.groupable = isPresent(callback);
    }
    get isGroupExpanded() {
        return this.groupsService.userCallback;
    }
    /**
     * @hidden
     */
    handleReorderEvents(ev, evType) {
        this.rowReorderService[evType](ev);
    }
    /**
     * @hidden
     */
    get flatData() {
        return isArray(this.data) ? this.data : this.data.data;
    }
    /**
     * @hidden
     */
    updateNavigationMetadata() {
        this.navigationService.metadata = this.navigationMetadata();
    }
    /**
     * @hidden
     */
    reorder({ target, source, before, changeContainer }) {
        this.ngZone.run(() => {
            const columnsForLevel = sortColumns(this.allColumnsForLevel(source.level));
            let newIndex = columnsForLevel.indexOf(target);
            if (target.parent && target.parent.isSpanColumn) {
                newIndex = columnsForLevel.indexOf(target.parent);
                if (before) {
                    target = target.parent;
                }
            }
            const oldIndex = columnsForLevel.indexOf(source);
            if (changeContainer) {
                if (before && 0 < newIndex && oldIndex < newIndex) { // dropped before the first not locked column
                    newIndex--;
                }
                else if (!before && oldIndex > newIndex) { // dropped after the last locked column
                    newIndex++;
                }
            }
            const args = new ColumnReorderEvent({
                column: source,
                oldIndex: oldIndex,
                newIndex: newIndex
            });
            this.columnReorder.emit(args);
            if (args.isDefaultPrevented()) {
                return;
            }
            if (changeContainer) {
                this.columnLockedChange.emit(new ColumnLockedChangeEvent([source]));
            }
            this.updateColumnIndices({ columnsForLevel, source, target, before });
            if (source.locked !== target.locked) {
                source.locked = target.locked;
            }
            this.columnsContainer.refresh();
            this.changeDetectorRef.markForCheck();
        });
    }
    updateColumnIndices({ columnsForLevel, source, target, before }) {
        const expandedColumns = expandColumnsWithSpan(columnsForLevel);
        const sourceColumnIndex = expandedColumns.indexOf(source);
        let nextSourceIndex = 0;
        let nextIndex = 0;
        let toSkip = 1;
        // Possible only when called from the API.
        if (source.isSpanColumn) {
            toSkip += source.childColumns.length;
        }
        let i = 0;
        while (i < expandedColumns.length) {
            const column = expandedColumns[i];
            if (column === target) {
                nextSourceIndex = before ? nextIndex : nextIndex + 1;
                nextIndex = before ? nextIndex + toSkip : nextIndex;
                column.orderIndex = nextIndex;
                if (nextSourceIndex === nextIndex + 1) {
                    nextIndex += toSkip;
                }
            }
            else if (column === source) {
                i += toSkip;
                continue;
            }
            else {
                column.orderIndex = nextIndex;
            }
            nextIndex++;
            i++;
        }
        for (i = sourceColumnIndex; i < sourceColumnIndex + toSkip; i++) {
            expandedColumns[i].orderIndex = nextSourceIndex++;
        }
        this.updateIndicesForLevel(source.level + 1);
    }
    updateIndicesForLevel(level) {
        const colsForParentLevel = this.allColumnsForLevel(level - 1);
        const colsForLevel = [];
        sortColumns(colsForParentLevel).forEach((c) => {
            if (c.isColumnGroup) {
                colsForLevel.push(...c.childrenArray.sort((a, b) => a.orderIndex - b.orderIndex));
            }
        });
        expandColumnsWithSpan(colsForLevel).map((c, i) => c.orderIndex = i);
        if (level < this.columnList.totalColumnLevels()) {
            this.updateIndicesForLevel(level + 1);
        }
    }
    allColumnsForLevel(level) {
        return this.columnList.toArray().filter(column => column.level === level);
    }
    initSelectionService() {
        if (!this.selectable) {
            this.selectionService.ngOnDestroy();
            this.cellSelectionService.ngOnDestroy();
            return;
        }
        if (!this.selectionDirective && !isPresent(this.defaultSelection)) {
            this.defaultSelection = new Selection(this.ctx, this.changeDetectorRef);
        }
        const cellSelectionMode = this.selectable['cell'];
        const activeService = cellSelectionMode ? this.cellSelectionService : this.selectionService;
        const inactiveService = cellSelectionMode ? this.selectionService : this.cellSelectionService;
        if (inactiveService.active) {
            inactiveService.ngOnDestroy();
            activeService.addSubscriptions();
            inactiveService.active = false;
        }
        activeService.active = true;
        activeService.init({
            cellSelected: cellSelectionMode ? this.cellSelected : undefined,
            rowSelected: cellSelectionMode ? undefined : this.rowSelected,
            isRowSelectable: this.isRowSelectable,
            selectable: this.selectable,
            view: this.view,
            columns: cellSelectionMode ? this.columnList.toArray() : undefined
        });
        if (!this.selectionDirective && !this.selectableSettings.enabled) {
            this.defaultSelection.reset();
        }
        if (this.selectionSubscription) {
            this.selectionSubscription.unsubscribe();
        }
        if (cellSelectionMode) {
            this.selectionSubscription = this.cellSelectionService.changes.subscribe((event) => {
                this.ngZone.run(() => this.selectionChange.emit(event));
            });
        }
        else {
            this.selectionSubscription = this.selectionService.changes.subscribe((event) => {
                this.ngZone.run(() => this.selectionChange.emit(event));
            });
        }
    }
    setEditFocus(element) {
        if (element) {
            return this.navigationService.tryFocus(element);
        }
    }
    columnInstance(column) {
        let instance;
        if (typeof column === 'number') {
            instance = this.columnsContainer.lockedLeafColumns.toArray()
                .concat(this.columnsContainer.nonLockedLeafColumns.toArray())[column];
        }
        else if (typeof column === 'string') {
            instance = this.columnList.filter((item) => item.field === column)[0];
        }
        else {
            instance = column;
        }
        if (!instance && isDevMode()) {
            throw new Error(ColumnConfigurationErrorMessages.invalidColumn(column));
        }
        return instance;
    }
    verifySettings() {
        if (isDevMode()) {
            const locked = this.lockedLeafColumns.length || (this.columnMenu && this.columnMenu.lock);
            const stickyColumns = this.stickyColumns.length || (this.columnMenu && this.columnMenu.stick);
            if (locked && this.detailTemplate) {
                throw new Error(GridConfigurationErrorMessages.incompatibleFeatures('detail template', 'locked columns'));
            }
            if (stickyColumns && this.detailTemplate) {
                throw new Error(GridConfigurationErrorMessages.incompatibleFeatures('detail template', 'sticky columns'));
            }
            if (this.lockedLeafColumns.length && !this.nonLockedLeafColumns.length) {
                console.warn(GridConfigurationErrorMessages.nonLockedColumnPresent);
            }
            if ((locked || this.virtualColumns) && expandColumns(this.columnList.toArray()).filter(column => !column.width && !isColumnGroupComponent(column)).length) {
                console.warn(ColumnConfigurationErrorMessages.requiredWidth(locked ? 'Locked' : 'Virtual'));
            }
            if (locked && !this.isScrollable) {
                console.warn(ColumnConfigurationErrorMessages.requiredScroll('Locked'));
            }
            if (stickyColumns && !this.isScrollable) {
                console.warn(ColumnConfigurationErrorMessages.requiredScroll('Sticky'));
            }
            if (this.virtualColumns && !this.isScrollable) {
                console.warn(ColumnConfigurationErrorMessages.requiredScroll('Virtual'));
            }
            if (this.columnList.filter(isColumnGroupComponent).filter((x) => !x.hasChildren).length) {
                throw new Error(ColumnConfigurationErrorMessages.groupColumnContent);
            }
            if (this.columnList.filter(x => x.locked && x.parent && !x.parent.isLocked).length) {
                throw new Error(ColumnConfigurationErrorMessages.lockedParent);
            }
            if ((this.rowHeight || this.detailRowHeight) && !this.isVirtual) {
                console.warn(GridConfigurationErrorMessages.rowHeightVirtual);
            }
            if (!this.rowHeight && this.isVirtual) {
                console.warn(GridConfigurationErrorMessages.rowHeightVirtual);
            }
            if (!this.detailRowHeight && this.isVirtual && this.detailTemplate) {
                console.warn(GridConfigurationErrorMessages.rowHeightVirtual);
            }
            if (stickyColumns && expandColumns(this.columnList.toArray()).filter(column => !column.width && !isColumnGroupComponent(column)).length) {
                console.warn(ColumnConfigurationErrorMessages.requiredWidth('Sticky'));
            }
            if (this.rowSticky && this.scrollable === 'virtual') {
                throw new Error(GridConfigurationErrorMessages.incompatibleFeatures('sticky rows', 'row virtualization (scrollable="virtual")'));
            }
            if (this.rowSticky && this.groupable) {
                throw new Error(GridConfigurationErrorMessages.incompatibleFeatures('sticky rows', 'grouping'));
            }
            if (this.wrapper?.nativeElement?.querySelector('kendo-toolbar') && this.toolbarTemplate) {
                console.warn(GridConfigurationErrorMessages.unsupportedToolbarConfig);
            }
            validateColumnsField(this.columnList);
        }
    }
    autoGenerateColumns() {
        if (this.shouldGenerateColumns && !this.columns.length && this.view.length) {
            this.columns.reset(Object.keys(this.view.at(0)).map(field => {
                const column = new ColumnComponent();
                column.field = field;
                return column;
            }));
        }
    }
    attachStateChangesEmitter() {
        this.stateChangeSubscription =
            merge(this.pageChange.pipe(map(x => ({
                filter: this.filter, group: this.group, skip: x.skip, sort: this.sort, take: x.take
            }))), this.sortChange.pipe(map(sort => ({ filter: this.filter, group: this.group, skip: this.skip, sort: sort, take: this.pageSize }))), this.groupChange.pipe(map(group => ({
                filter: this.filter, group: group, skip: this.skip, sort: this.sort, take: this.pageSize
            }))), this.filterChange.pipe(map(filter => ({
                filter: filter, group: this.group, skip: 0, sort: this.sort, take: this.pageSize
            }))))
                .subscribe(x => {
                this.closeCell();
                this.cancelCell();
                if (this.selectable && this.selectableSettings?.enabled && this.isVirtual) {
                    this.blockArrowSelection = true;
                }
                this.dataStateChange.emit(x);
            });
    }
    attachEditHandlers() {
        if (!this.editService) {
            return;
        }
        this.editServiceSubscription = this.editService
            .changes.subscribe(this.emitCRUDEvent.bind(this));
    }
    emitCRUDEvent(args) {
        const { action, rowIndex, formGroup } = args;
        let dataItem = this.view.at(rowIndex - this.skip);
        if (action !== 'add' && !dataItem) {
            dataItem = formGroup.value;
        }
        this.closeCell();
        Object.assign(args, {
            dataItem: dataItem,
            sender: this
        });
        switch (action) {
            case 'add':
                this.add.emit(args);
                break;
            case 'cancel':
                this.cancel.emit(args);
                break;
            case 'edit':
                this.edit.emit(args);
                break;
            case 'remove':
                this.remove.emit(args);
                break;
            case 'save':
                this.save.emit(args);
                break;
            case 'cellClose':
                this.cellClose.emit(args);
                break;
            default: break;
        }
    }
    attachDomEventHandlers() {
        this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
            this.cellClick.emit(Object.assign({ sender: this }, args));
        });
    }
    attachElementEventHandlers() {
        if (isUniversal()) {
            return;
        }
        const wrapper = this.wrapper.nativeElement;
        const ariaRoot = this.ariaRoot.nativeElement;
        this.ngZone.runOutsideAngular(() => {
            const resizeCheck = this.resizeCheck.bind(this);
            const resizeSubscription = this.renderer.listen('window', 'resize', resizeCheck);
            const orientationSubscription = this.renderer.listen('window', 'orientationchange', resizeCheck);
            const documentClickSubscription = this.renderer.listen('document', 'click', (args) => {
                const activeElement = document.activeElement;
                if (this.editService.shouldCloseCell() &&
                    !closest(args.target, matchesClasses('k-animation-container k-grid-ignore-click')) &&
                    !(activeElement &&
                        (closest(activeElement, matchesClasses('k-animation-container')) ||
                            isInEditedCell(activeElement, this.wrapper.nativeElement)))) {
                    this.editService.closeCell(args);
                }
            });
            const windowBlurSubscription = this.renderer.listen('window', 'blur', (args) => {
                const activeElement = document.activeElement;
                if (activeElement && !(matchesNodeName('input')(activeElement) && activeElement.type === 'file' &&
                    isInEditedCell(activeElement, this.wrapper.nativeElement))) {
                    this.editService.closeCell(args);
                }
                this.domEvents.windowBlur.emit(args);
            });
            const clickSubscription = this.renderer.listen(wrapper, 'click', (args) => {
                this.domEvents.click.emit(args);
            });
            const keydownSubscription = this.renderer.listen(wrapper, 'keydown', (args) => {
                this.domEvents.keydown.emit(args);
            });
            // focusIn and focusOut are relative to the element with ARIA role "grid"
            let focused = false;
            const focusInSubscription = this.renderer.listen(ariaRoot, 'focusin', (args) => {
                this.domEvents.focus.emit(args);
                if (!focused) {
                    this.domEvents.focusIn.emit(args);
                    focused = true;
                }
            });
            const focusOutSubscription = this.renderer.listen(ariaRoot, 'focusout', (args) => {
                const next = args.relatedTarget || document.activeElement;
                const outside = !closest(next, (node) => node === ariaRoot);
                if (outside) {
                    this.domEvents.focusOut.emit(args);
                    focused = false;
                }
            });
            this.detachElementEventHandlers = () => {
                resizeSubscription();
                orientationSubscription();
                documentClickSubscription();
                windowBlurSubscription();
                clickSubscription();
                keydownSubscription();
                focusInSubscription();
                focusOutSubscription();
            };
        });
    }
    matchesMedia(c) {
        return this.responsiveService.matchesMedia(c.media);
    }
    resizeCheck() {
        if (window.innerWidth !== this.cachedWindowWidth) {
            this.cachedWindowWidth = window.innerWidth;
            let hasChanges = false;
            this.columnList.filterHierarchy(column => {
                const matchesMedia = this.matchesMedia(column);
                if (column.matchesMedia !== matchesMedia) {
                    hasChanges = true;
                    column.matchesMedia = matchesMedia;
                }
                return column.isVisible;
            });
            if (hasChanges) {
                this.ngZone.run(() => {
                    this.changeDetectorRef.markForCheck();
                });
            }
        }
    }
    emitPDFExportEvent() {
        const args = new PDFExportEvent();
        this.pdfExport.emit(args);
        if (!args.isDefaultPrevented()) {
            this.saveAsPDF();
        }
    }
    syncHeaderHeight(observable) {
        return observable
            .pipe(filter(() => isPresent(this.lockedHeader)))
            .subscribe(() => syncRowsHeight(this.lockedHeader.nativeElement.children[0], this.header.nativeElement.children[0]));
    }
    columnsContainerChange() {
        this.columnsContainerChangeSubscription =
            this.syncHeaderHeight(this.columnsContainer.changes.pipe(filter(() => this.lockedColumns.length > 0), switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1)))));
    }
    handleColumnResize() {
        const resizes = this.columnResizingService.changes;
        this.columnResizingSubscription = resizes.pipe(tap(e => {
            if (e.type === 'start') {
                this.renderer.addClass(this.wrapper.nativeElement, 'k-grid-column-resizing');
            }
            else if (e.type === 'end') {
                this.renderer.removeClass(this.wrapper.nativeElement, 'k-grid-column-resizing');
            }
        }), filter(e => e.type === 'start'), switchMap(() => resizes.pipe(takeUntil(resizes.pipe(filter(e => e.type === 'triggerAutoFit'))), filter(e => e.type === 'end'))))
            .subscribe(this.notifyResize.bind(this));
    }
    notifyResize(e) {
        const args = e.resizedColumns
            .filter(item => isTruthy(item.column.resizable) && !item.column.isColumnGroup)
            .map(item => ({
            column: item.column,
            newWidth: item.column.width,
            oldWidth: item.oldWidth
        }));
        this.columnResize.emit(args);
    }
    assertNavigable() {
        if (isDevMode() && !this.navigationService.enabled) {
            throw new Error(GridConfigurationErrorMessages.focusNavigable);
        }
    }
    _rowClass = () => null;
    navigationMetadata() {
        const isVirtual = this.isVirtual;
        const pageSize = this.pageSize;
        const dataRows = isVirtual ? this.view.total : pageSize;
        const addRowOffset = this.editService.hasNewItem ? 1 : 0;
        const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;
        const headerRows = this.totalColumnLevels + 1 + filterRowOffset + addRowOffset;
        return new NavigationMetadata(dataRows, headerRows, isVirtual, this.hasPager, isPresent(this.detailTemplate), this.wrapper, this.virtualColumns, this.columnsContainer);
    }
    applyAutoSize() {
        const cols = this.columns.filter((c) => this.autoSize ? c.autoSize !== false : c.autoSize);
        if (cols.length > 0) {
            this.ngZone.onStable.pipe(take(1)).subscribe(_ => this.autoFitColumns(cols));
        }
    }
    onColumnRangeChange(range) {
        const viewportColumns = this.viewportColumns = [];
        const columnsArray = this.columnsContainer.nonLockedLeafColumns.toArray();
        let leafViewportColumns = columnsArray.slice(range.start, range.end + 1);
        const stickyBeforeStart = columnsArray.slice(0, range.start).filter(c => c.sticky && !leafViewportColumns.some(col => col === c));
        const stickyAfterEnd = columnsArray.slice(range.end, columnsArray.length).filter(c => c.sticky && !leafViewportColumns.some(col => col === c));
        leafViewportColumns = [...stickyBeforeStart, ...leafViewportColumns, ...stickyAfterEnd];
        for (let idx = 0; idx < leafViewportColumns.length; idx++) {
            let column = leafViewportColumns[idx];
            while (column.parent) {
                column = column.parent;
            }
            const toAdd = [column];
            while (toAdd.length) {
                column = toAdd.shift();
                viewportColumns.push(column);
                if (column.isColumnGroup) {
                    toAdd.unshift(...column.childrenArray);
                }
            }
            const lastFromGroup = viewportColumns[viewportColumns.length - 1];
            column = leafViewportColumns[idx];
            while (column !== lastFromGroup && idx < leafViewportColumns.length) {
                idx++;
                column = leafViewportColumns[idx];
            }
        }
        if (range.start > 0) {
            const first = leafViewportColumns[0];
            let offset = range.offset;
            let current = viewportColumns[0];
            let index = 0;
            while (current !== first) {
                offset -= current.isColumnGroup ? 0 : current.width;
                index++;
                current = viewportColumns[index];
            }
            if (offset > 0) {
                const totalLevels = this.columnsContainer.totalLevels;
                let previous;
                for (let idx = 0; idx <= totalLevels; idx++) {
                    const offsetColumn = idx < totalLevels ? new ColumnGroupComponent(previous) : new ColumnBase(previous);
                    previous = offsetColumn;
                    offsetColumn.title = "\u00A0";
                    offsetColumn.width = offset;
                    viewportColumns.unshift(offsetColumn);
                }
            }
        }
        this.leafViewportColumns = viewportColumns.filter(c => !c.isColumnGroup);
    }
    toggleDetailRowLegacy(index, expand) {
        const hasCallback = typeof this.isDetailExpanded === 'function';
        if (isDevMode() && hasCallback) {
            throw new Error(GridConfigurationErrorMessages.expandCollapseMethods('expandRow', 'collapseRow', 'kendoGridDetailsExpandBy', 'isDetailExpanded'));
        }
        if (!isDevMode() && hasCallback) {
            return;
        }
        if (this.detailsService.isExpanded(index, null) !== expand) {
            this.detailsService.toggleRow(index, null);
        }
    }
    toggleGroupRowLegacy(index, expand) {
        const hasCallback = typeof this.isGroupExpanded === 'function';
        if (isDevMode() && hasCallback) {
            throw new Error(GridConfigurationErrorMessages.expandCollapseMethods('expandGroup', 'collapseGroup', 'kendoGridExpandGroupBy', 'isGroupExpanded'));
        }
        if (!isDevMode() && hasCallback) {
            return;
        }
        if (this.groupsService.isExpanded({ groupIndex: index }) !== expand) {
            this.groupsService.toggleRow({ index }, false);
            if (this.ctx.groupBindingDirective) {
                this.ctx.groupBindingDirective[`group${expand ? 'Expand' : 'Collapse'}`]({ groupIndex: index });
            }
        }
    }
    shouldResetSelection(selectableChanges) {
        const previousValue = selectableChanges.previousValue;
        if (!previousValue) {
            // Selection was disabled, no need to reset.
            return false;
        }
        const currentValue = selectableChanges.currentValue;
        if (!currentValue || currentValue.enabled === false) {
            // Selection disabled, reset.
            return true;
        }
        return previousValue.cell !== currentValue.cell;
    }
    notifyReorderContainers() {
        this.dragTargetContainer?.notify();
        this.dropTargetContainer?.notify();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridComponent, deps: [{ token: BrowserSupportService }, { token: SelectionService }, { token: CellSelectionService }, { token: i0.ElementRef }, { token: GroupInfoService }, { token: GroupsService }, { token: ChangeNotificationService }, { token: DetailsService }, { token: EditService }, { token: FilterService }, { token: PDFService }, { token: ResponsiveService }, { token: i0.Renderer2 }, { token: ExcelService }, { token: i0.NgZone }, { token: ScrollSyncService }, { token: DomEventsService }, { token: ColumnResizingService }, { token: i0.ChangeDetectorRef }, { token: ColumnReorderService }, { token: ColumnInfoService }, { token: NavigationService }, { token: SortService }, { token: ScrollRequestService }, { token: i1$2.LocalizationService }, { token: ContextService }, { token: SizingOptionsService }, { token: RowReorderService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: GridComponent, isStandalone: true, selector: "kendo-grid", inputs: { data: "data", pageSize: "pageSize", height: "height", rowHeight: "rowHeight", detailRowHeight: "detailRowHeight", skip: "skip", scrollable: "scrollable", selectable: "selectable", sort: "sort", size: "size", trackBy: "trackBy", filter: "filter", group: "group", virtualColumns: "virtualColumns", filterable: "filterable", sortable: "sortable", pageable: "pageable", groupable: "groupable", rowReorderable: "rowReorderable", navigable: "navigable", navigatable: "navigatable", autoSize: "autoSize", rowClass: "rowClass", rowSticky: "rowSticky", rowSelected: "rowSelected", isRowSelectable: "isRowSelectable", cellSelected: "cellSelected", resizable: "resizable", reorderable: "reorderable", loading: "loading", columnMenu: "columnMenu", hideHeader: "hideHeader", isDetailExpanded: "isDetailExpanded", isGroupExpanded: "isGroupExpanded" }, outputs: { filterChange: "filterChange", pageChange: "pageChange", groupChange: "groupChange", sortChange: "sortChange", selectionChange: "selectionChange", rowReorder: "rowReorder", dataStateChange: "dataStateChange", groupExpand: "groupExpand", groupCollapse: "groupCollapse", detailExpand: "detailExpand", detailCollapse: "detailCollapse", edit: "edit", cancel: "cancel", save: "save", remove: "remove", add: "add", cellClose: "cellClose", cellClick: "cellClick", pdfExport: "pdfExport", excelExport: "excelExport", columnResize: "columnResize", columnReorder: "columnReorder", columnVisibilityChange: "columnVisibilityChange", columnLockedChange: "columnLockedChange", columnStickyChange: "columnStickyChange", scrollBottom: "scrollBottom", contentScroll: "contentScroll" }, host: { properties: { "attr.dir": "this.dir", "class.k-grid": "this.hostClass", "class.k-grid-sm": "this.sizeSmallClass", "class.k-grid-md": "this.sizeMediumClass", "class.k-grid-lockedcolumns": "this.lockedClasses", "class.k-grid-virtual": "this.virtualClasses", "class.k-grid-no-scrollbar": "this.noScrollbarClass" } }, providers: [
            BrowserSupportService,
            LocalizationService,
            ColumnInfoService,
            SelectionService,
            CellSelectionService,
            DetailsService,
            GroupsService,
            GroupInfoService,
            ChangeNotificationService,
            EditService,
            PDFService,
            SuspendService,
            {
                provide: CELL_CONTEXT,
                useValue: EMPTY_CELL_CONTEXT
            },
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.grid'
            },
            FilterService,
            ResponsiveService,
            PagerContextService,
            PagerNavigationService,
            ExcelService,
            ScrollSyncService,
            ResizeService,
            LocalDataChangesService,
            DomEventsService,
            ColumnResizingService,
            SinglePopupService,
            DragAndDropService,
            DragHintService,
            DropCueService,
            ColumnReorderService,
            NavigationService,
            FocusRoot,
            IdService,
            CellSelectionAggregateService,
            ScrollRequestService,
            SortService,
            ContextService,
            SizingOptionsService,
            RowReorderService,
            ClipboardService
        ], queries: [{ propertyName: "columns", predicate: ColumnBase }, { propertyName: "detailTemplateChildren", predicate: DetailTemplateDirective }, { propertyName: "cellLoadingTemplateChildren", predicate: CellLoadingTemplateDirective }, { propertyName: "loadingTemplateChildren", predicate: LoadingTemplateDirective }, { propertyName: "statusBarTemplateChildren", predicate: StatusBarTemplateDirective }, { propertyName: "noRecordsTemplateChildren", predicate: NoRecordsTemplateDirective }, { propertyName: "pagerTemplateChildren", predicate: PagerTemplateDirective }, { propertyName: "toolbarTemplateChildren", predicate: ToolbarTemplateDirective }, { propertyName: "columnMenuTemplates", predicate: ColumnMenuTemplateDirective }], viewQueries: [{ propertyName: "lockedHeader", first: true, predicate: ["lockedHeader"], descendants: true }, { propertyName: "header", first: true, predicate: ["header"], descendants: true }, { propertyName: "ariaRoot", first: true, predicate: ["ariaRoot"], descendants: true, static: true }, { propertyName: "dragTargetContainer", first: true, predicate: DragTargetContainerDirective, descendants: true }, { propertyName: "dropTargetContainer", first: true, predicate: DropTargetContainerDirective, descendants: true }, { propertyName: "footer", predicate: ["footer"], descendants: true }], exportAs: ["kendoGrid"], usesOnChanges: true, ngImport: i0, template: `
        <ng-container kendoGridLocalizedMessages
            i18n-groupPanelEmpty="kendo.grid.groupPanelEmpty|The label visible in the Grid group panel when it is empty"
            groupPanelEmpty="Drag a column header and drop it here to group by that column"

            i18n-noRecords="kendo.grid.noRecords|The label visible in the Grid when there are no records"
            noRecords="No records available."

            i18n-pagerLabel="kendo.grid.pagerLabel|The label for the Grid pager"
            pagerLabel="{{ 'Page navigation, page {currentPage} of {totalPages}' }}"

            i18n-pagerFirstPage="kendo.grid.pagerFirstPage|The label for the first page button in Grid pager"
            pagerFirstPage="Go to the first page"

            i18n-pagerPreviousPage="kendo.grid.pagerPreviousPage|The label for the previous page button in Grid pager"
            pagerPreviousPage="Go to the previous page"

            i18n-pagerNextPage="kendo.grid.pagerNextPage|The label for the next page button in Grid pager"
            pagerNextPage="Go to the next page"

            i18n-pagerLastPage="kendo.grid.pagerLastPage|The label for the last page button in Grid pager"
            pagerLastPage="Go to the last page"

            i18n-pagerPage="kendo.grid.pagerPage|The label before the current page number in the Grid pager"
            pagerPage="Page"

            i18n-pagerOf="kendo.grid.pagerOf|The label before the total pages number in the Grid pager"
            pagerOf="of"

            i18n-pagerItems="kendo.grid.pagerItems|The label after the total pages number in the Grid pager"
            pagerItems="items"

            i18n-pagerPageNumberInputTitle="kendo.grid.pagerPageNumberInputTitle|The label for the pager input in the Grid pager"
            pagerPageNumberInputTitle="Page Number"

            i18n-pagerItemsPerPage="kendo.grid.pagerItemsPerPage|The label for the page size chooser in the Grid pager"
            pagerItemsPerPage="items per page"

            i18n-pagerInputLabel="kendo.grid.pagerInputLabel|The text of the aria-label attribute applied to the input element for entering the page number"
            pagerInputLabel="Type a page number"

            i18n-filter="kendo.grid.filter|The label of the filter cell or icon"
            filter="Filter"

            i18n-filterInputLabel="kendo.grid.filterInputLabel|The label of the filter row and menu inputs"
            filterInputLabel="{{ '{columnName} Filter' }}"

            i18n-filterMenuTitle="kendo.grid.filterMenuTitle|The title of the filter menu icon"
            filterMenuTitle="{{ '{columnName} Filter Menu' }}"

            i18n-filterMenuOperatorsDropDownLabel="kendo.grid.filterMenuOperatorsDropDownLabel|The label of the filter menu operators dropdown"
            filterMenuOperatorsDropDownLabel="{{ '{columnName} Filter Operators' }}"
            
            i18n-filterCellOperatorLabel="kendo.grid.filterCellOperatorLabel|The label of the filter cell operators dropdown"
            filterCellOperatorLabel="{{ 'Filter cell operators for {columnName}' }}"

            i18n-booleanFilterCellLabel="kendo.grid.booleanFilterCellLabel|The label of the boolean filter cell dropdown"
            booleanFilterCellLabel="{{ 'Boolean filter cell for {columnName}' }}"

            i18n-filterMenuLogicDropDownLabel="kendo.grid.filterMenuLogicDropDownLabel|The label of the filter menu logic dropdown"
            filterMenuLogicDropDownLabel="{{ '{columnName} Filter Logic' }}"

            i18n-filterEqOperator="kendo.grid.filterEqOperator|The text of the equal filter operator"
            filterEqOperator="Is equal to"

            i18n-filterNotEqOperator="kendo.grid.filterNotEqOperator|The text of the not equal filter operator"
            filterNotEqOperator="Is not equal to"

            i18n-filterIsNullOperator="kendo.grid.filterIsNullOperator|The text of the is null filter operator"
            filterIsNullOperator="Is null"

            i18n-filterIsNotNullOperator="kendo.grid.filterIsNotNullOperator|The text of the is not null filter operator"
            filterIsNotNullOperator="Is not null"

            i18n-filterIsEmptyOperator="kendo.grid.filterIsEmptyOperator|The text of the is empty filter operator"
            filterIsEmptyOperator="Is empty"

            i18n-filterIsNotEmptyOperator="kendo.grid.filterIsNotEmptyOperator|The text of the is not empty filter operator"
            filterIsNotEmptyOperator="Is not empty"

            i18n-filterStartsWithOperator="kendo.grid.filterStartsWithOperator|The text of the starts with filter operator"
            filterStartsWithOperator="Starts with"

            i18n-filterContainsOperator="kendo.grid.filterContainsOperator|The text of the contains filter operator"
            filterContainsOperator="Contains"

            i18n-filterNotContainsOperator="kendo.grid.filterNotContainsOperator|The text of the does not contain filter operator"
            filterNotContainsOperator="Does not contain"

            i18n-filterEndsWithOperator="kendo.grid.filterEndsWithOperator|The text of the ends with filter operator"
            filterEndsWithOperator="Ends with"

            i18n-filterGteOperator="kendo.grid.filterGteOperator|The text of the greater than or equal filter operator"
            filterGteOperator="Is greater than or equal to"

            i18n-filterGtOperator="kendo.grid.filterGtOperator|The text of the greater than filter operator"
            filterGtOperator="Is greater than"

            i18n-filterLteOperator="kendo.grid.filterLteOperator|The text of the less than or equal filter operator"
            filterLteOperator="Is less than or equal to"

            i18n-filterLtOperator="kendo.grid.filterLtOperator|The text of the less than filter operator"
            filterLtOperator="Is less than"

            i18n-filterIsTrue="kendo.grid.filterIsTrue|The text of the IsTrue boolean filter option"
            filterIsTrue="Is True"

            i18n-filterIsFalse="kendo.grid.filterIsFalse|The text of the IsFalse boolean filter option"
            filterIsFalse="Is False"

            i18n-filterBooleanAll="kendo.grid.filterBooleanAll|The text of the (All) boolean filter option"
            filterBooleanAll="(All)"

            i18n-filterAfterOrEqualOperator="kendo.grid.filterAfterOrEqualOperator|The text of the after or equal date filter operator"
            filterAfterOrEqualOperator="Is after or equal to"

            i18n-filterAfterOperator="kendo.grid.filterAfterOperator|The text of the after date filter operator"
            filterAfterOperator="Is after"

            i18n-filterBeforeOperator="kendo.grid.filterBeforeOperator|The text of the before date filter operator"
            filterBeforeOperator="Is before"

            i18n-filterBeforeOrEqualOperator="kendo.grid.filterBeforeOrEqualOperator|The text of the before or equal date filter operator"
            filterBeforeOrEqualOperator="Is before or equal to"

            i18n-filterFilterButton="kendo.grid.filterFilterButton|The text of the filter button"
            filterFilterButton="Filter"

            i18n-filterClearButton="kendo.grid.filterClearButton|The text of the clear filter button"
            filterClearButton="Clear"

            i18n-filterAndLogic="kendo.grid.filterAndLogic|The text of the And filter logic"
            filterAndLogic="And"

            i18n-filterOrLogic="kendo.grid.filterOrLogic|The text of the Or filter logic"
            filterOrLogic="Or"

            i18n-loading="kendo.grid.loading|The loading text"
            loading="Loading"

            i18n-gridLabel="kendo.grid.gridLabel|The Grid aria-label"
            gridLabel="Data table"

            i18n-columnMenu="kendo.grid.columnMenu|The title of the column menu icon"
            columnMenu="{{ '{columnName} Column Menu' }}"

            i18n-columns="kendo.grid.columns|The text shown in the column menu for the columns item"
            columns="Columns"

            i18n-lock="kendo.grid.lock|The text shown in the column menu for the lock item"
            lock="Lock"

            i18n-unlock="kendo.grid.unlock|The text shown in the column menu for the unlock item"
            unlock="Unlock"

            i18n-setColumnPosition="kendo.grid.setColumnPosition|The text shown in the column menu for the set column position item"
            setColumnPosition="Set Column Position"

            i18n-stick="kendo.grid.stick|The text shown in the column menu for the stick item"
            stick="Stick"

            i18n-unstick="kendo.grid.unstick|The text shown in the column menu for the unstick item"
            unstick="Unstick"

            i18n-sortable="kendo.grid.sortable|The label of the sort icon"
            sortable="Sortable"

            i18n-sortAscending="kendo.grid.sortAscending|The text shown in the column menu for the sort ascending item"
            sortAscending="Sort Ascending"

            i18n-sortDescending="kendo.grid.sortDescending|The text shown in the column menu for the sort descending item"
            sortDescending="Sort Descending"

            i18n-autosizeAllColumns="kendo.grid.autosizeAllColumns|The text shown in the column menu for the autosize all columns item"
            autosizeAllColumns="Autosize All Columns"

            i18n-autosizeThisColumn="kendo.grid.autosizeThisColumn|The text shown in the column menu for the autosize this column item"
            autosizeThisColumn="Autosize This Column"

            i18n-sortedDefault="kendo.grid.sortedDefault|The status announcement when a column is no longer sorted"
            sortedDefault="Not Sorted"

            i18n-sortedAscending="kendo.grid.sortedAscending|The title of the Group Chip indicating the ascending sorting order of the groups"
            sortedAscending="Sorted Ascending"
            
            i18n-sortedDescending="kendo.grid.sortedDescending|The title of the Group Chip indicating the descending sorting order of the groups"
            sortedDescending="Sorted Descending"

            i18n-columnsApply="kendo.grid.columnsApply|The text shown in the column menu or column chooser for the columns apply button"
            columnsApply="Apply"

            i18n-columnsReset="kendo.grid.columnsReset|The text shown in the column menu or column chooser for the columns reset button"
            columnsReset="Reset"

            i18n-detailExpand="kendo.grid.detailExpand|The title of the expand icon of detail rows."
            detailExpand="Expand Details"

            i18n-detailCollapse="kendo.grid.detailCollapse|The title of the collapse icon of detail rows."
            detailCollapse="Collapse Details"

            i18n-filterDateToday="kendo.grid.filterDateToday|The text of the Today button of the Date filter."
            filterDateToday="TODAY"

            i18n-filterDateToggle="kendo.grid.filterDateToggle|The title of the Toggle button of the Date filter."
            filterDateToggle="Toggle Calendar"

            i18n-filterNumericDecrement="kendo.grid.filterNumericDecrement|The title of the Decrement button of the Numeric filter."
            filterNumericDecrement="Decrement"

            i18n-filterNumericIncrement="kendo.grid.filterNumericIncrement|The title of the Increment button of the Numeric filter."
            filterNumericIncrement="Increment"

            i18n-selectionCheckboxLabel="kendo.grid.selectionCheckboxLabel|The labels of the checkbox column checkboxes."
            selectionCheckboxLabel="Select Row"

            i18n-selectAllCheckboxLabel="kendo.grid.selectAllCheckboxLabel|The label of the checkbox column select all checkbox."
            selectAllCheckboxLabel="Select All Rows"

            i18n-groupCollapse="kendo.grid.groupCollapse|The text of the title and aria-label attributes applied to the collapse icon of group rows."
            groupCollapse="Collapse Group"

            i18n-groupExpand="kendo.grid.groupExpand|The text of the title and aria-label attributes applied to the expand icon of group rows."
            groupExpand="Expand Group"

            i18n-pagerSelectPage="kendo.grid.pagerSelectPage|The text of the title and aria-label attributes applied to the page chooser in the Grid Pager"
            pagerSelectPage="Select page"

            i18n-topToolbarLabel="kendo.grid.topToolbarLabel|The label for the Grid top toolbar"
            topToolbarLabel="Top toolbar"

            i18n-bottomToolbarLabel="kendo.grid.bottomToolbarLabel|The label for the Grid bottom toolbar"
            bottomToolbarLabel="Bottom toolbar"

            i18n-groupPanelLabel="kendo.grid.groupPanelLabel|The label for the Grid group panel toolbar"
            groupPanelLabel="Group panel"

            i18n-dragRowHandleLabel="kendo.grid.dragRowHandleLabel|The label for the Grid drag row handle"
            dragRowHandleLabel="Drag row"

            i18n-columnMenuFilterTabTitle="kendo.grid.columnMenuFilterTabTitle|The title for the column menu Filter tab"
            columnMenuFilterTabTitle="Filter"

            i18n-columnMenuGeneralTabTitle="kendo.grid.columnMenuGeneralTabTitle|The title for the column menu General tab"
            columnMenuGeneralTabTitle="General"

            i18n-columnMenuColumnsTabTitle="kendo.grid.columnMenuColumnsTabTitle|The title for the column menu Columns tab"
            columnMenuColumnsTabTitle="Columns"

            i18n-groupChipMenuPrevious="kendo.grid.groupChipMenuPrevious|The text for the Group pane Chip Menu Move as previous item"
            groupChipMenuPrevious="Move as previous"

            i18n-groupChipMenuNext="kendo.grid.groupChipMenuNext|The text for the Group pane Chip Menu Move as next item"
            groupChipMenuNext="Move as next"
        >
        </ng-container>
        <kendo-grid-toolbar
            *ngIf="showTopToolbar"
            [size]="size"
            [attr.aria-label]="messageFor('topToolbarLabel')"
            [navigable]="navigation.toolbarEnabled"
            [attr.aria-controls]="ariaRootId"
            position="top"></kendo-grid-toolbar>
        <ng-content select="kendo-toolbar"></ng-content>
        <kendo-pager
            *ngIf="showTopPager"
            #topPager
            [navigable]="navigation.pagerEnabled"
            class="k-grid-pager k-grid-pager-top"
            [pageSize]="pageSize"
            [total]="view.total"
            [skip]="skip"
            [size]="size"
            [responsive]="normalizedPageableSettings.responsive && !pagerTemplate"
            [buttonCount]="normalizedPageableSettings.buttonCount"
            [info]="normalizedPageableSettings.info"
            [pageSizeValues]="normalizedPageableSettings.pageSizes"
            [previousNext]="normalizedPageableSettings.previousNext"
            [type]="normalizedPageableSettings.type"
            (pageChange)="notifyPageChange('pager', $event)">
            <ng-template kendoPagerTemplate>
                <ng-container
                    [ngTemplateOutlet]="pagerTemplate ? pagerTemplate?.templateRef : defaultPager"
                    [ngTemplateOutletContext]="topPager.templateContext"></ng-container>
            </ng-template>
            <kendo-pager-messages
                [ariaLabel]="messageFor('pagerLabel')"
                [firstPage]="messageFor('pagerFirstPage')"
                [inputLabel]="messageFor('pagerInputLabel')"
                [previousPage]="messageFor('pagerPreviousPage')"
                [nextPage]="messageFor('pagerNextPage')"
                [lastPage]="messageFor('pagerLastPage')"
                [selectPage]="messageFor('pagerSelectPage')"
                [page]="messageFor('pagerPage')"
                [itemsPerPage]="messageFor('pagerItemsPerPage')"
                [items]="messageFor('pagerItems')"
                [of]="messageFor('pagerOf')"
                [pageNumberInputTitle]="messageFor('pagerPageNumberInputTitle')">
            </kendo-pager-messages>
        </kendo-pager>
        <kendo-grid-group-panel
            *ngIf="showGroupPanel"
            [navigable]="navigation.toolbarEnabled"
            [text]="groupableEmptyText"
            [groups]="group"
            role="toolbar"
            [attr.aria-label]="messageFor('groupPanelLabel')"
            [attr.aria-controls]="ariaRootId"
            (change)="groupChange.emit($event)">
        </kendo-grid-group-panel>
        <div #ariaRoot
            class="k-grid-aria-root"
            role="grid"
            kendoDragTargetContainer
            kendoDropTargetContainer
            mode="manual"
            [dragDisabled]="!rowReorderable"
            [dropDisabled]="!rowReorderable"
            [dragTargetFilter]="getDefaultSelectors('dragTarget')"
            [dropTargetFilter]="getDefaultSelectors('dropTarget')"
            [dragHandle]="getDefaultSelectors('handle')"
            [hint]="{hintTemplate: defaultHint}"
            (onPress)="handleReorderEvents($event, 'press')"
            (onDragStart)="handleReorderEvents($event, 'dragStart')"
            (onDrag)="handleReorderEvents($event, 'drag')"
            (onDragEnter)="handleReorderEvents($event, 'dragEnter')"
            (onDragLeave)="handleReorderEvents($event, 'dragLeave')"
            (onDragEnd)="handleReorderEvents($event, 'dragEnd')"
            (onDrop)="handleReorderEvents($event, 'drop')"
            [dragData]="gridData"
            [id]="ariaRootId"
            [attr.aria-label]="ariaLabel"
            [attr.aria-rowcount]="ariaRowCount"
            [attr.aria-colcount]="ariaColCount">
            <ng-container *ngIf="isScrollable">
                <div *ngIf="!hideHeader"
                    class="k-grid-header"
                    role="presentation"
                    [style.padding]="headerPadding">
                    <div *ngIf="isLocked"
                        #lockedHeader
                        role="presentation"
                        class="k-grid-header-locked"
                        [style.width.px]="lockedWidth">
                        <table
                            kendoGridResizableTable
                            [locked]="true"
                            role="presentation"
                            class="k-grid-header-table"
                            [style.width.px]="lockedWidth"
                            kendoGridTable
                            [size]="size">
                            <colgroup kendoGridColGroup
                                [columns]="$any(lockedLeafColumns)"
                                [groups]="group"
                                [detailTemplate]="detailTemplate">
                            </colgroup>
                            <thead kendoGridHeader
                                role="rowgroup"
                                [resizable]="resizable"
                                [scrollable]="true"
                                [columns]="$any(lockedColumns)"
                                [totalColumnLevels]="totalColumnLevels"
                                [sort]="sort"
                                [groups]="group"
                                [filter]="filter"
                                [filterable]="filterable"
                                [groupable]="showGroupPanel"
                                [reorderable]="reorderable"
                                [sortable]="sortable"
                                [columnMenu]="columnMenuOptions"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [totalColumnsCount]="leafColumns.length"
                                [totalColumns]="columnsContainer"
                                [detailTemplate]="detailTemplate"
                                [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                            </thead>
                        </table>
                    </div>
                    <div #header class="k-grid-header-wrap" role="presentation" data-scrollable
                        [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
                        [lockedWidth]="lockedWidth + scrollbarWidth + 2">
                        <table
                            role="presentation"
                            class="k-grid-header-table"
                            [style.width.px]="nonLockedWidth"
                            kendoGridResizableTable
                            [virtualColumns]="virtualColumns"
                            kendoGridTable
                            [size]="size">
                            <colgroup kendoGridColGroup
                                [columns]="headerLeafColumns"
                                [groups]="isLocked ? [] : group"
                                [detailTemplate]="detailTemplate">
                            </colgroup>
                            <thead kendoGridHeader
                                [resizable]="resizable"
                                role="rowgroup"
                                [scrollable]="true"
                                [columns]="headerColumns"
                                [totalColumnLevels]="totalColumnLevels"
                                [sort]="sort"
                                [filter]="filter"
                                [filterable]="filterable"
                                [groupable]="showGroupPanel"
                                [reorderable]="reorderable"
                                [groups]="isLocked ? [] : group"
                                [sortable]="sortable"
                                [columnMenu]="columnMenuOptions"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [lockedColumnsCount]="lockedLeafColumns.length"
                                [totalColumnsCount]="leafColumns.length"
                                [totalColumns]="columnsContainer"
                                [detailTemplate]="detailTemplate"
                                [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                            </thead>
                        </table>
                        <div *ngIf="virtualColumns" class="k-width-container" role="presentation">
                            <div [style.width.px]="columnsContainer.unlockedWidth"></div>
                        </div>
                    </div>
                </div>
                <kendo-grid-list
                    [data]="$any(view)"
                    [rowHeight]="rowHeight"
                    [detailRowHeight]="detailRowHeight"
                    [total]="totalCount"
                    [take]="pageSize"
                    [groups]="group"
                    [groupable]="groupable"
                    [skip]="skip"
                    [trackBy]="trackBy"
                    [columns]="columnsContainer"
                    [selectable]="selectable"
                    [filterable]="filterable"
                    [detailTemplate]="detailTemplate"
                    [noRecordsTemplate]="noRecordsTemplate"
                    [size]="size"
                    (pageChange)="notifyPageChange('list', $event)"
                    [rowClass]="rowClass"
                    [rowSticky]="rowSticky"
                    [loading]="loading"
                    [isVirtual]="isVirtual"
                    [cellLoadingTemplate]="cellLoadingTemplate?.templateRef"
                    [loadingTemplate]="loadingTemplate?.templateRef"
                    [virtualColumns]="virtualColumns"
                    (scrollBottom)="notifyScrollBottom()"
                    (contentScroll)="contentScroll.emit($event)"
                    kendoDraggable
                    kendoGridSelectionMarquee
                    [enableDrag]="marqueeSelection"
                    [sort]="sort">
                </kendo-grid-list>
                <div
                    *ngIf="showFooter"
                    class="k-grid-footer"
                    [style.padding]="headerPadding">
                    <div
                        *ngIf="lockedLeafColumns.length"
                        class="k-grid-footer-locked"
                        [style.width.px]="lockedWidth">
                        <table
                            role="presentation"
                            class="k-grid-footer-table"
                            kendoGridResizableTable
                            [locked]="true"
                            [style.width.px]="lockedWidth"
                            kendoGridTable
                            [size]="size">
                            <colgroup kendoGridColGroup
                                [columns]="$any(lockedLeafColumns)"
                                [groups]="group"
                                [detailTemplate]="detailTemplate">
                            </colgroup>
                            <tfoot kendoGridFooter
                                [scrollable]="true"
                                [groups]="group"
                                [columns]="$any(lockedLeafColumns)"
                                [detailTemplate]="detailTemplate"
                                [logicalRowIndex]="ariaRowCount"
                                [totalColumns]="columnsContainer">
                            </tfoot>
                        </table>
                    </div>
                    <div #footer
                        class="k-grid-footer-wrap" data-scrollable
                        [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
                        [lockedWidth]="lockedWidth + scrollbarWidth + 3">
                        <table
                            role="presentation"
                            class="k-grid-footer-table"
                            [style.width.px]="nonLockedWidth"
                            kendoGridTable
                            kendoGridResizableTable
                            [size]="size">
                            <colgroup kendoGridColGroup
                                [columns]="$any(headerLeafColumns)"
                                [groups]="isLocked ? [] : group"
                                [detailTemplate]="detailTemplate">
                            </colgroup>
                            <tfoot kendoGridFooter
                                [logicalRowIndex]="ariaRowCount"
                                [scrollable]="true"
                                [groups]="isLocked ? [] : group"
                                [columns]="$any(headerColumns)"
                                [lockedColumnsCount]="lockedLeafColumns.length"
                                [detailTemplate]="detailTemplate"
                                [totalColumns]="columnsContainer">
                            </tfoot>
                        </table>
                    </div>
                </div>
            </ng-container>
            <ng-container *ngIf="!isScrollable">
                <table
                    [style.table-layout]="resizable ? 'fixed' : null"
                    kendoGridTable
                    kendoGridResizableTable
                    role="presentation"
                    [size]="size">
                    <colgroup kendoGridColGroup
                        [columns]="$any(leafColumns)"
                        [groups]="group"
                        [detailTemplate]="detailTemplate">
                    </colgroup>
                    <thead kendoGridHeader
                        *ngIf="!hideHeader"
                        [resizable]="resizable"
                        [scrollable]="false"
                        [columns]="$any(visibleColumns)"
                        [totalColumnLevels]="totalColumnLevels"
                        [totalColumns]="columnsContainer"
                        [groups]="group"
                        [groupable]="showGroupPanel"
                        [reorderable]="reorderable"
                        [sort]="sort"
                        [sortable]="sortable"
                        [filter]="filter"
                        [filterable]="filterable"
                        [columnMenu]="columnMenuOptions"
                        [columnMenuTemplate]="columnMenuTemplate"
                        [detailTemplate]="detailTemplate"
                        [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                    </thead>
                    <tbody kendoGridTableBody
                        [isLoading]="loading"
                        [groups]="group"
                        [data]="$any(view)"
                        [skip]="skip"
                        [columns]="$any(leafColumns)"
                        [selectable]="selectable"
                        [filterable]="filterable"
                        [noRecordsTemplate]="noRecordsTemplate"
                        [detailTemplate]="detailTemplate"
                        [showGroupFooters]="showGroupFooters"
                        [trackBy]="trackBy"
                        [rowClass]="rowClass"
                        kendoDraggable
                        kendoGridSelectionMarquee
                        [enableDrag]="marqueeSelection">
                    </tbody>
                    <tfoot kendoGridFooter
                        *ngIf="showFooter"
                        [scrollable]="false"
                        [logicalRowIndex]="ariaRowCount"
                        [groups]="group"
                        [columns]="$any(leafColumns)"
                        [detailTemplate]="detailTemplate"
                        [totalColumns]="columnsContainer">
                    </tfoot>
                </table>
            </ng-container>
            <div [loadingTemplate]="loadingTemplate" *ngIf="loading" kendoGridLoading></div>
        </div>
        <kendo-grid-status-bar
            *ngIf="showStatusBar"
            [statusBarTemplate]="statusBarTemplate">
        </kendo-grid-status-bar>
        <kendo-pager
            *ngIf="showBottomPager"
            #bottomPager
            class="k-grid-pager"
            [navigable]="navigation.pagerEnabled"
            [pageSize]="pageSize"
            [total]="view.total"
            [skip]="skip"
            [size]="size"
            [responsive]="normalizedPageableSettings.responsive && !pagerTemplate"
            [buttonCount]="normalizedPageableSettings.buttonCount"
            [info]="normalizedPageableSettings.info"
            [pageSizeValues]="normalizedPageableSettings.pageSizes"
            [previousNext]="normalizedPageableSettings.previousNext"
            [type]="normalizedPageableSettings.type"
            (pageChange)="notifyPageChange('pager', $event)">
            <ng-template kendoPagerTemplate>
                <ng-container 
                    [ngTemplateOutlet]="pagerTemplate ? pagerTemplate?.templateRef : defaultPager"
                    [ngTemplateOutletContext]="bottomPager.templateContext"></ng-container>
            </ng-template>
            <kendo-pager-messages
                [ariaLabel]="messageFor('pagerLabel')"
                [firstPage]="messageFor('pagerFirstPage')"
                [inputLabel]="messageFor('pagerInputLabel')"
                [previousPage]="messageFor('pagerPreviousPage')"
                [nextPage]="messageFor('pagerNextPage')"
                [lastPage]="messageFor('pagerLastPage')"
                [selectPage]="messageFor('pagerSelectPage')"
                [page]="messageFor('pagerPage')"
                [itemsPerPage]="messageFor('pagerItemsPerPage')"
                [items]="messageFor('pagerItems')"
                [of]="messageFor('pagerOf')"
                [pageNumberInputTitle]="messageFor('pagerPageNumberInputTitle')">
            </kendo-pager-messages>
        </kendo-pager>
        <kendo-grid-toolbar
            class="k-grid-toolbar-bottom"
            *ngIf="showBottomToolbar"
            [size]="size"
            [navigable]="navigation.toolbarEnabled"
            [attr.aria-label]="messageFor('bottomToolbarLabel')"
            [attr.aria-controls]="ariaRootId"
            position="bottom">
        </kendo-grid-toolbar>

        <ng-template #defaultHint>
            <kendo-icon-wrapper
                [name]="getHintSettings('hintIcon')"
                [svgIcon]="getHintSettings('hintSVGIcon')"
                innerCssClass="k-drag-status">
            </kendo-icon-wrapper>
            {{hintText}}
        </ng-template>

        <ng-template #defaultPager>
            <div class="k-pager-numbers-wrap">
                <kendo-pager-prev-buttons [size]="size" *ngIf="normalizedPageableSettings.previousNext"></kendo-pager-prev-buttons>
                <kendo-pager-numeric-buttons
                    [size]="size"
                    *ngIf="normalizedPageableSettings.type === 'numeric' && normalizedPageableSettings.buttonCount > 0"
                    [buttonCount]="normalizedPageableSettings.buttonCount">
                </kendo-pager-numeric-buttons>
                <kendo-pager-input [size]="size" *ngIf="normalizedPageableSettings.type === 'input'"></kendo-pager-input>
                <kendo-pager-next-buttons [size]="size" *ngIf="normalizedPageableSettings.previousNext"></kendo-pager-next-buttons>
            </div>
            <kendo-pager-page-sizes *ngIf="normalizedPageableSettings.pageSizes"
                [size]="size"
                [pageSizes]="normalizedPageableSettings.pageSizes">
            </kendo-pager-page-sizes>
            <kendo-pager-info *ngIf="normalizedPageableSettings.info">
            </kendo-pager-info>
        </ng-template>
        <div kendoWatermarkOverlay *ngIf="showLicenseWatermark"></div>
    `, isInline: true, dependencies: [{ kind: "directive", type: LocalizedMessagesDirective, selector: "[kendoGridLocalizedMessages]" }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: ToolbarComponent, selector: "kendo-grid-toolbar", inputs: ["position", "size", "navigable"] }, { kind: "component", type: GroupPanelComponent, selector: "kendo-grid-group-panel", inputs: ["text", "navigable", "groups"], outputs: ["change"] }, { kind: "directive", type: TableDirective, selector: "[kendoGridResizableTable]", inputs: ["locked", "virtualColumns"] }, { kind: "directive", type: GridTableDirective, selector: "[kendoGridTable]", inputs: ["size"] }, { kind: "component", type: ColGroupComponent, selector: "[kendoGridColGroup]", inputs: ["columns", "groups", "detailTemplate", "sort"] }, { kind: "component", type: HeaderComponent, selector: "[kendoGridHeader]", inputs: ["totalColumnLevels", "columns", "groups", "detailTemplate", "scrollable", "filterable", "sort", "filter", "sortable", "groupable", "lockedColumnsCount", "resizable", "reorderable", "columnMenu", "columnMenuTemplate", "totalColumnsCount", "totalColumns", "tabIndex", "size"] }, { kind: "directive", type: ResizableContainerDirective, selector: "[kendoGridResizableContainer]", inputs: ["lockedWidth", "kendoGridResizableContainer"] }, { kind: "component", type: ListComponent, selector: "kendo-grid-list", inputs: ["data", "groups", "total", "rowHeight", "stickyRowHeight", "detailRowHeight", "take", "skip", "columns", "detailTemplate", "noRecordsTemplate", "selectable", "groupable", "filterable", "rowClass", "rowSticky", "loading", "trackBy", "virtualColumns", "isVirtual", "cellLoadingTemplate", "loadingTemplate", "sort", "size"], outputs: ["contentScroll", "pageChange", "scrollBottom"] }, { kind: "directive", type: DragTargetContainerDirective, selector: "[kendoDragTargetContainer]", inputs: ["hint", "dragTargetFilter", "dragHandle", "dragDelay", "threshold", "dragTargetId", "dragData", "dragDisabled", "mode"], outputs: ["onDragReady", "onPress", "onDragStart", "onDrag", "onRelease", "onDragEnd"], exportAs: ["kendoDragTargetContainer"] }, { kind: "directive", type: DropTargetContainerDirective, selector: "[kendoDropTargetContainer]", inputs: ["dropTargetFilter", "dropDisabled"], outputs: ["onDragEnter", "onDragOver", "onDragLeave", "onDrop"], exportAs: ["kendoDropTargetContainer"] }, { kind: "directive", type: DraggableDirective, selector: "[kendoDraggable]", inputs: ["enableDrag"], outputs: ["kendoPress", "kendoDrag", "kendoRelease"] }, { kind: "directive", type: GridMarqueeDirective, selector: "[kendoGridSelectionMarquee]" }, { kind: "component", type: FooterComponent, selector: "[kendoGridFooter]", inputs: ["columns", "groups", "detailTemplate", "scrollable", "lockedColumnsCount", "logicalRowIndex", "totalColumns"] }, { kind: "component", type: TableBodyComponent, selector: "[kendoGridTableBody]", inputs: ["columns", "allColumns", "groups", "detailTemplate", "noRecordsTemplate", "data", "skip", "selectable", "filterable", "noRecordsText", "isLocked", "isLoading", "isVirtual", "cellLoadingTemplate", "skipGroupDecoration", "showGroupFooters", "lockedColumnsCount", "totalColumnsCount", "virtualColumns", "trackBy", "rowSticky", "totalColumns", "rowClass"] }, { kind: "component", type: LoadingComponent, selector: "[kendoGridLoading]", inputs: ["loadingTemplate"] }, { kind: "component", type: StatusBarComponent, selector: "kendo-grid-status-bar", inputs: ["statusBarTemplate"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "component", type: WatermarkOverlayComponent, selector: "div[kendoWatermarkOverlay]" }, { kind: "component", type: i42.CustomMessagesComponent, selector: "kendo-datapager-messages, kendo-pager-messages" }, { kind: "component", type: i42.PagerInfoComponent, selector: "kendo-datapager-info, kendo-pager-info" }, { kind: "component", type: i42.PagerInputComponent, selector: "kendo-datapager-input, kendo-pager-input", inputs: ["size"] }, { kind: "component", type: i42.PagerNextButtonsComponent, selector: "kendo-datapager-next-buttons, kendo-pager-next-buttons", inputs: ["size"] }, { kind: "component", type: i42.PagerNumericButtonsComponent, selector: "kendo-datapager-numeric-buttons, kendo-pager-numeric-buttons", inputs: ["buttonCount", "size"] }, { kind: "component", type: i42.PagerPageSizesComponent, selector: "kendo-datapager-page-sizes, kendo-pager-page-sizes", inputs: ["pageSizes", "size"] }, { kind: "component", type: i42.PagerPrevButtonsComponent, selector: "kendo-datapager-prev-buttons, kendo-pager-prev-buttons", inputs: ["size"] }, { kind: "directive", type: i42.PagerTemplateDirective, selector: "[kendoDataPagerTemplate], [kendoPagerTemplate]" }, { kind: "component", type: i42.PagerComponent, selector: "kendo-datapager, kendo-pager", inputs: ["externalTemplate", "total", "skip", "pageSize", "buttonCount", "info", "type", "pageSizeValues", "previousNext", "navigable", "size", "responsive"], outputs: ["pageChange", "pageSizeChange"], exportAs: ["kendoDataPager", "kendoPager"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridComponent, decorators: [{
            type: Component,
            args: [{
                    encapsulation: ViewEncapsulation.None,
                    exportAs: 'kendoGrid',
                    providers: [
                        BrowserSupportService,
                        LocalizationService,
                        ColumnInfoService,
                        SelectionService,
                        CellSelectionService,
                        DetailsService,
                        GroupsService,
                        GroupInfoService,
                        ChangeNotificationService,
                        EditService,
                        PDFService,
                        SuspendService,
                        {
                            provide: CELL_CONTEXT,
                            useValue: EMPTY_CELL_CONTEXT
                        },
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.grid'
                        },
                        FilterService,
                        ResponsiveService,
                        PagerContextService,
                        PagerNavigationService,
                        ExcelService,
                        ScrollSyncService,
                        ResizeService,
                        LocalDataChangesService,
                        DomEventsService,
                        ColumnResizingService,
                        SinglePopupService,
                        DragAndDropService,
                        DragHintService,
                        DropCueService,
                        ColumnReorderService,
                        NavigationService,
                        FocusRoot,
                        IdService,
                        CellSelectionAggregateService,
                        ScrollRequestService,
                        SortService,
                        ContextService,
                        SizingOptionsService,
                        RowReorderService,
                        ClipboardService
                    ],
                    selector: 'kendo-grid',
                    template: `
        <ng-container kendoGridLocalizedMessages
            i18n-groupPanelEmpty="kendo.grid.groupPanelEmpty|The label visible in the Grid group panel when it is empty"
            groupPanelEmpty="Drag a column header and drop it here to group by that column"

            i18n-noRecords="kendo.grid.noRecords|The label visible in the Grid when there are no records"
            noRecords="No records available."

            i18n-pagerLabel="kendo.grid.pagerLabel|The label for the Grid pager"
            pagerLabel="{{ 'Page navigation, page {currentPage} of {totalPages}' }}"

            i18n-pagerFirstPage="kendo.grid.pagerFirstPage|The label for the first page button in Grid pager"
            pagerFirstPage="Go to the first page"

            i18n-pagerPreviousPage="kendo.grid.pagerPreviousPage|The label for the previous page button in Grid pager"
            pagerPreviousPage="Go to the previous page"

            i18n-pagerNextPage="kendo.grid.pagerNextPage|The label for the next page button in Grid pager"
            pagerNextPage="Go to the next page"

            i18n-pagerLastPage="kendo.grid.pagerLastPage|The label for the last page button in Grid pager"
            pagerLastPage="Go to the last page"

            i18n-pagerPage="kendo.grid.pagerPage|The label before the current page number in the Grid pager"
            pagerPage="Page"

            i18n-pagerOf="kendo.grid.pagerOf|The label before the total pages number in the Grid pager"
            pagerOf="of"

            i18n-pagerItems="kendo.grid.pagerItems|The label after the total pages number in the Grid pager"
            pagerItems="items"

            i18n-pagerPageNumberInputTitle="kendo.grid.pagerPageNumberInputTitle|The label for the pager input in the Grid pager"
            pagerPageNumberInputTitle="Page Number"

            i18n-pagerItemsPerPage="kendo.grid.pagerItemsPerPage|The label for the page size chooser in the Grid pager"
            pagerItemsPerPage="items per page"

            i18n-pagerInputLabel="kendo.grid.pagerInputLabel|The text of the aria-label attribute applied to the input element for entering the page number"
            pagerInputLabel="Type a page number"

            i18n-filter="kendo.grid.filter|The label of the filter cell or icon"
            filter="Filter"

            i18n-filterInputLabel="kendo.grid.filterInputLabel|The label of the filter row and menu inputs"
            filterInputLabel="{{ '{columnName} Filter' }}"

            i18n-filterMenuTitle="kendo.grid.filterMenuTitle|The title of the filter menu icon"
            filterMenuTitle="{{ '{columnName} Filter Menu' }}"

            i18n-filterMenuOperatorsDropDownLabel="kendo.grid.filterMenuOperatorsDropDownLabel|The label of the filter menu operators dropdown"
            filterMenuOperatorsDropDownLabel="{{ '{columnName} Filter Operators' }}"
            
            i18n-filterCellOperatorLabel="kendo.grid.filterCellOperatorLabel|The label of the filter cell operators dropdown"
            filterCellOperatorLabel="{{ 'Filter cell operators for {columnName}' }}"

            i18n-booleanFilterCellLabel="kendo.grid.booleanFilterCellLabel|The label of the boolean filter cell dropdown"
            booleanFilterCellLabel="{{ 'Boolean filter cell for {columnName}' }}"

            i18n-filterMenuLogicDropDownLabel="kendo.grid.filterMenuLogicDropDownLabel|The label of the filter menu logic dropdown"
            filterMenuLogicDropDownLabel="{{ '{columnName} Filter Logic' }}"

            i18n-filterEqOperator="kendo.grid.filterEqOperator|The text of the equal filter operator"
            filterEqOperator="Is equal to"

            i18n-filterNotEqOperator="kendo.grid.filterNotEqOperator|The text of the not equal filter operator"
            filterNotEqOperator="Is not equal to"

            i18n-filterIsNullOperator="kendo.grid.filterIsNullOperator|The text of the is null filter operator"
            filterIsNullOperator="Is null"

            i18n-filterIsNotNullOperator="kendo.grid.filterIsNotNullOperator|The text of the is not null filter operator"
            filterIsNotNullOperator="Is not null"

            i18n-filterIsEmptyOperator="kendo.grid.filterIsEmptyOperator|The text of the is empty filter operator"
            filterIsEmptyOperator="Is empty"

            i18n-filterIsNotEmptyOperator="kendo.grid.filterIsNotEmptyOperator|The text of the is not empty filter operator"
            filterIsNotEmptyOperator="Is not empty"

            i18n-filterStartsWithOperator="kendo.grid.filterStartsWithOperator|The text of the starts with filter operator"
            filterStartsWithOperator="Starts with"

            i18n-filterContainsOperator="kendo.grid.filterContainsOperator|The text of the contains filter operator"
            filterContainsOperator="Contains"

            i18n-filterNotContainsOperator="kendo.grid.filterNotContainsOperator|The text of the does not contain filter operator"
            filterNotContainsOperator="Does not contain"

            i18n-filterEndsWithOperator="kendo.grid.filterEndsWithOperator|The text of the ends with filter operator"
            filterEndsWithOperator="Ends with"

            i18n-filterGteOperator="kendo.grid.filterGteOperator|The text of the greater than or equal filter operator"
            filterGteOperator="Is greater than or equal to"

            i18n-filterGtOperator="kendo.grid.filterGtOperator|The text of the greater than filter operator"
            filterGtOperator="Is greater than"

            i18n-filterLteOperator="kendo.grid.filterLteOperator|The text of the less than or equal filter operator"
            filterLteOperator="Is less than or equal to"

            i18n-filterLtOperator="kendo.grid.filterLtOperator|The text of the less than filter operator"
            filterLtOperator="Is less than"

            i18n-filterIsTrue="kendo.grid.filterIsTrue|The text of the IsTrue boolean filter option"
            filterIsTrue="Is True"

            i18n-filterIsFalse="kendo.grid.filterIsFalse|The text of the IsFalse boolean filter option"
            filterIsFalse="Is False"

            i18n-filterBooleanAll="kendo.grid.filterBooleanAll|The text of the (All) boolean filter option"
            filterBooleanAll="(All)"

            i18n-filterAfterOrEqualOperator="kendo.grid.filterAfterOrEqualOperator|The text of the after or equal date filter operator"
            filterAfterOrEqualOperator="Is after or equal to"

            i18n-filterAfterOperator="kendo.grid.filterAfterOperator|The text of the after date filter operator"
            filterAfterOperator="Is after"

            i18n-filterBeforeOperator="kendo.grid.filterBeforeOperator|The text of the before date filter operator"
            filterBeforeOperator="Is before"

            i18n-filterBeforeOrEqualOperator="kendo.grid.filterBeforeOrEqualOperator|The text of the before or equal date filter operator"
            filterBeforeOrEqualOperator="Is before or equal to"

            i18n-filterFilterButton="kendo.grid.filterFilterButton|The text of the filter button"
            filterFilterButton="Filter"

            i18n-filterClearButton="kendo.grid.filterClearButton|The text of the clear filter button"
            filterClearButton="Clear"

            i18n-filterAndLogic="kendo.grid.filterAndLogic|The text of the And filter logic"
            filterAndLogic="And"

            i18n-filterOrLogic="kendo.grid.filterOrLogic|The text of the Or filter logic"
            filterOrLogic="Or"

            i18n-loading="kendo.grid.loading|The loading text"
            loading="Loading"

            i18n-gridLabel="kendo.grid.gridLabel|The Grid aria-label"
            gridLabel="Data table"

            i18n-columnMenu="kendo.grid.columnMenu|The title of the column menu icon"
            columnMenu="{{ '{columnName} Column Menu' }}"

            i18n-columns="kendo.grid.columns|The text shown in the column menu for the columns item"
            columns="Columns"

            i18n-lock="kendo.grid.lock|The text shown in the column menu for the lock item"
            lock="Lock"

            i18n-unlock="kendo.grid.unlock|The text shown in the column menu for the unlock item"
            unlock="Unlock"

            i18n-setColumnPosition="kendo.grid.setColumnPosition|The text shown in the column menu for the set column position item"
            setColumnPosition="Set Column Position"

            i18n-stick="kendo.grid.stick|The text shown in the column menu for the stick item"
            stick="Stick"

            i18n-unstick="kendo.grid.unstick|The text shown in the column menu for the unstick item"
            unstick="Unstick"

            i18n-sortable="kendo.grid.sortable|The label of the sort icon"
            sortable="Sortable"

            i18n-sortAscending="kendo.grid.sortAscending|The text shown in the column menu for the sort ascending item"
            sortAscending="Sort Ascending"

            i18n-sortDescending="kendo.grid.sortDescending|The text shown in the column menu for the sort descending item"
            sortDescending="Sort Descending"

            i18n-autosizeAllColumns="kendo.grid.autosizeAllColumns|The text shown in the column menu for the autosize all columns item"
            autosizeAllColumns="Autosize All Columns"

            i18n-autosizeThisColumn="kendo.grid.autosizeThisColumn|The text shown in the column menu for the autosize this column item"
            autosizeThisColumn="Autosize This Column"

            i18n-sortedDefault="kendo.grid.sortedDefault|The status announcement when a column is no longer sorted"
            sortedDefault="Not Sorted"

            i18n-sortedAscending="kendo.grid.sortedAscending|The title of the Group Chip indicating the ascending sorting order of the groups"
            sortedAscending="Sorted Ascending"
            
            i18n-sortedDescending="kendo.grid.sortedDescending|The title of the Group Chip indicating the descending sorting order of the groups"
            sortedDescending="Sorted Descending"

            i18n-columnsApply="kendo.grid.columnsApply|The text shown in the column menu or column chooser for the columns apply button"
            columnsApply="Apply"

            i18n-columnsReset="kendo.grid.columnsReset|The text shown in the column menu or column chooser for the columns reset button"
            columnsReset="Reset"

            i18n-detailExpand="kendo.grid.detailExpand|The title of the expand icon of detail rows."
            detailExpand="Expand Details"

            i18n-detailCollapse="kendo.grid.detailCollapse|The title of the collapse icon of detail rows."
            detailCollapse="Collapse Details"

            i18n-filterDateToday="kendo.grid.filterDateToday|The text of the Today button of the Date filter."
            filterDateToday="TODAY"

            i18n-filterDateToggle="kendo.grid.filterDateToggle|The title of the Toggle button of the Date filter."
            filterDateToggle="Toggle Calendar"

            i18n-filterNumericDecrement="kendo.grid.filterNumericDecrement|The title of the Decrement button of the Numeric filter."
            filterNumericDecrement="Decrement"

            i18n-filterNumericIncrement="kendo.grid.filterNumericIncrement|The title of the Increment button of the Numeric filter."
            filterNumericIncrement="Increment"

            i18n-selectionCheckboxLabel="kendo.grid.selectionCheckboxLabel|The labels of the checkbox column checkboxes."
            selectionCheckboxLabel="Select Row"

            i18n-selectAllCheckboxLabel="kendo.grid.selectAllCheckboxLabel|The label of the checkbox column select all checkbox."
            selectAllCheckboxLabel="Select All Rows"

            i18n-groupCollapse="kendo.grid.groupCollapse|The text of the title and aria-label attributes applied to the collapse icon of group rows."
            groupCollapse="Collapse Group"

            i18n-groupExpand="kendo.grid.groupExpand|The text of the title and aria-label attributes applied to the expand icon of group rows."
            groupExpand="Expand Group"

            i18n-pagerSelectPage="kendo.grid.pagerSelectPage|The text of the title and aria-label attributes applied to the page chooser in the Grid Pager"
            pagerSelectPage="Select page"

            i18n-topToolbarLabel="kendo.grid.topToolbarLabel|The label for the Grid top toolbar"
            topToolbarLabel="Top toolbar"

            i18n-bottomToolbarLabel="kendo.grid.bottomToolbarLabel|The label for the Grid bottom toolbar"
            bottomToolbarLabel="Bottom toolbar"

            i18n-groupPanelLabel="kendo.grid.groupPanelLabel|The label for the Grid group panel toolbar"
            groupPanelLabel="Group panel"

            i18n-dragRowHandleLabel="kendo.grid.dragRowHandleLabel|The label for the Grid drag row handle"
            dragRowHandleLabel="Drag row"

            i18n-columnMenuFilterTabTitle="kendo.grid.columnMenuFilterTabTitle|The title for the column menu Filter tab"
            columnMenuFilterTabTitle="Filter"

            i18n-columnMenuGeneralTabTitle="kendo.grid.columnMenuGeneralTabTitle|The title for the column menu General tab"
            columnMenuGeneralTabTitle="General"

            i18n-columnMenuColumnsTabTitle="kendo.grid.columnMenuColumnsTabTitle|The title for the column menu Columns tab"
            columnMenuColumnsTabTitle="Columns"

            i18n-groupChipMenuPrevious="kendo.grid.groupChipMenuPrevious|The text for the Group pane Chip Menu Move as previous item"
            groupChipMenuPrevious="Move as previous"

            i18n-groupChipMenuNext="kendo.grid.groupChipMenuNext|The text for the Group pane Chip Menu Move as next item"
            groupChipMenuNext="Move as next"
        >
        </ng-container>
        <kendo-grid-toolbar
            *ngIf="showTopToolbar"
            [size]="size"
            [attr.aria-label]="messageFor('topToolbarLabel')"
            [navigable]="navigation.toolbarEnabled"
            [attr.aria-controls]="ariaRootId"
            position="top"></kendo-grid-toolbar>
        <ng-content select="kendo-toolbar"></ng-content>
        <kendo-pager
            *ngIf="showTopPager"
            #topPager
            [navigable]="navigation.pagerEnabled"
            class="k-grid-pager k-grid-pager-top"
            [pageSize]="pageSize"
            [total]="view.total"
            [skip]="skip"
            [size]="size"
            [responsive]="normalizedPageableSettings.responsive && !pagerTemplate"
            [buttonCount]="normalizedPageableSettings.buttonCount"
            [info]="normalizedPageableSettings.info"
            [pageSizeValues]="normalizedPageableSettings.pageSizes"
            [previousNext]="normalizedPageableSettings.previousNext"
            [type]="normalizedPageableSettings.type"
            (pageChange)="notifyPageChange('pager', $event)">
            <ng-template kendoPagerTemplate>
                <ng-container
                    [ngTemplateOutlet]="pagerTemplate ? pagerTemplate?.templateRef : defaultPager"
                    [ngTemplateOutletContext]="topPager.templateContext"></ng-container>
            </ng-template>
            <kendo-pager-messages
                [ariaLabel]="messageFor('pagerLabel')"
                [firstPage]="messageFor('pagerFirstPage')"
                [inputLabel]="messageFor('pagerInputLabel')"
                [previousPage]="messageFor('pagerPreviousPage')"
                [nextPage]="messageFor('pagerNextPage')"
                [lastPage]="messageFor('pagerLastPage')"
                [selectPage]="messageFor('pagerSelectPage')"
                [page]="messageFor('pagerPage')"
                [itemsPerPage]="messageFor('pagerItemsPerPage')"
                [items]="messageFor('pagerItems')"
                [of]="messageFor('pagerOf')"
                [pageNumberInputTitle]="messageFor('pagerPageNumberInputTitle')">
            </kendo-pager-messages>
        </kendo-pager>
        <kendo-grid-group-panel
            *ngIf="showGroupPanel"
            [navigable]="navigation.toolbarEnabled"
            [text]="groupableEmptyText"
            [groups]="group"
            role="toolbar"
            [attr.aria-label]="messageFor('groupPanelLabel')"
            [attr.aria-controls]="ariaRootId"
            (change)="groupChange.emit($event)">
        </kendo-grid-group-panel>
        <div #ariaRoot
            class="k-grid-aria-root"
            role="grid"
            kendoDragTargetContainer
            kendoDropTargetContainer
            mode="manual"
            [dragDisabled]="!rowReorderable"
            [dropDisabled]="!rowReorderable"
            [dragTargetFilter]="getDefaultSelectors('dragTarget')"
            [dropTargetFilter]="getDefaultSelectors('dropTarget')"
            [dragHandle]="getDefaultSelectors('handle')"
            [hint]="{hintTemplate: defaultHint}"
            (onPress)="handleReorderEvents($event, 'press')"
            (onDragStart)="handleReorderEvents($event, 'dragStart')"
            (onDrag)="handleReorderEvents($event, 'drag')"
            (onDragEnter)="handleReorderEvents($event, 'dragEnter')"
            (onDragLeave)="handleReorderEvents($event, 'dragLeave')"
            (onDragEnd)="handleReorderEvents($event, 'dragEnd')"
            (onDrop)="handleReorderEvents($event, 'drop')"
            [dragData]="gridData"
            [id]="ariaRootId"
            [attr.aria-label]="ariaLabel"
            [attr.aria-rowcount]="ariaRowCount"
            [attr.aria-colcount]="ariaColCount">
            <ng-container *ngIf="isScrollable">
                <div *ngIf="!hideHeader"
                    class="k-grid-header"
                    role="presentation"
                    [style.padding]="headerPadding">
                    <div *ngIf="isLocked"
                        #lockedHeader
                        role="presentation"
                        class="k-grid-header-locked"
                        [style.width.px]="lockedWidth">
                        <table
                            kendoGridResizableTable
                            [locked]="true"
                            role="presentation"
                            class="k-grid-header-table"
                            [style.width.px]="lockedWidth"
                            kendoGridTable
                            [size]="size">
                            <colgroup kendoGridColGroup
                                [columns]="$any(lockedLeafColumns)"
                                [groups]="group"
                                [detailTemplate]="detailTemplate">
                            </colgroup>
                            <thead kendoGridHeader
                                role="rowgroup"
                                [resizable]="resizable"
                                [scrollable]="true"
                                [columns]="$any(lockedColumns)"
                                [totalColumnLevels]="totalColumnLevels"
                                [sort]="sort"
                                [groups]="group"
                                [filter]="filter"
                                [filterable]="filterable"
                                [groupable]="showGroupPanel"
                                [reorderable]="reorderable"
                                [sortable]="sortable"
                                [columnMenu]="columnMenuOptions"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [totalColumnsCount]="leafColumns.length"
                                [totalColumns]="columnsContainer"
                                [detailTemplate]="detailTemplate"
                                [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                            </thead>
                        </table>
                    </div>
                    <div #header class="k-grid-header-wrap" role="presentation" data-scrollable
                        [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
                        [lockedWidth]="lockedWidth + scrollbarWidth + 2">
                        <table
                            role="presentation"
                            class="k-grid-header-table"
                            [style.width.px]="nonLockedWidth"
                            kendoGridResizableTable
                            [virtualColumns]="virtualColumns"
                            kendoGridTable
                            [size]="size">
                            <colgroup kendoGridColGroup
                                [columns]="headerLeafColumns"
                                [groups]="isLocked ? [] : group"
                                [detailTemplate]="detailTemplate">
                            </colgroup>
                            <thead kendoGridHeader
                                [resizable]="resizable"
                                role="rowgroup"
                                [scrollable]="true"
                                [columns]="headerColumns"
                                [totalColumnLevels]="totalColumnLevels"
                                [sort]="sort"
                                [filter]="filter"
                                [filterable]="filterable"
                                [groupable]="showGroupPanel"
                                [reorderable]="reorderable"
                                [groups]="isLocked ? [] : group"
                                [sortable]="sortable"
                                [columnMenu]="columnMenuOptions"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [lockedColumnsCount]="lockedLeafColumns.length"
                                [totalColumnsCount]="leafColumns.length"
                                [totalColumns]="columnsContainer"
                                [detailTemplate]="detailTemplate"
                                [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                            </thead>
                        </table>
                        <div *ngIf="virtualColumns" class="k-width-container" role="presentation">
                            <div [style.width.px]="columnsContainer.unlockedWidth"></div>
                        </div>
                    </div>
                </div>
                <kendo-grid-list
                    [data]="$any(view)"
                    [rowHeight]="rowHeight"
                    [detailRowHeight]="detailRowHeight"
                    [total]="totalCount"
                    [take]="pageSize"
                    [groups]="group"
                    [groupable]="groupable"
                    [skip]="skip"
                    [trackBy]="trackBy"
                    [columns]="columnsContainer"
                    [selectable]="selectable"
                    [filterable]="filterable"
                    [detailTemplate]="detailTemplate"
                    [noRecordsTemplate]="noRecordsTemplate"
                    [size]="size"
                    (pageChange)="notifyPageChange('list', $event)"
                    [rowClass]="rowClass"
                    [rowSticky]="rowSticky"
                    [loading]="loading"
                    [isVirtual]="isVirtual"
                    [cellLoadingTemplate]="cellLoadingTemplate?.templateRef"
                    [loadingTemplate]="loadingTemplate?.templateRef"
                    [virtualColumns]="virtualColumns"
                    (scrollBottom)="notifyScrollBottom()"
                    (contentScroll)="contentScroll.emit($event)"
                    kendoDraggable
                    kendoGridSelectionMarquee
                    [enableDrag]="marqueeSelection"
                    [sort]="sort">
                </kendo-grid-list>
                <div
                    *ngIf="showFooter"
                    class="k-grid-footer"
                    [style.padding]="headerPadding">
                    <div
                        *ngIf="lockedLeafColumns.length"
                        class="k-grid-footer-locked"
                        [style.width.px]="lockedWidth">
                        <table
                            role="presentation"
                            class="k-grid-footer-table"
                            kendoGridResizableTable
                            [locked]="true"
                            [style.width.px]="lockedWidth"
                            kendoGridTable
                            [size]="size">
                            <colgroup kendoGridColGroup
                                [columns]="$any(lockedLeafColumns)"
                                [groups]="group"
                                [detailTemplate]="detailTemplate">
                            </colgroup>
                            <tfoot kendoGridFooter
                                [scrollable]="true"
                                [groups]="group"
                                [columns]="$any(lockedLeafColumns)"
                                [detailTemplate]="detailTemplate"
                                [logicalRowIndex]="ariaRowCount"
                                [totalColumns]="columnsContainer">
                            </tfoot>
                        </table>
                    </div>
                    <div #footer
                        class="k-grid-footer-wrap" data-scrollable
                        [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
                        [lockedWidth]="lockedWidth + scrollbarWidth + 3">
                        <table
                            role="presentation"
                            class="k-grid-footer-table"
                            [style.width.px]="nonLockedWidth"
                            kendoGridTable
                            kendoGridResizableTable
                            [size]="size">
                            <colgroup kendoGridColGroup
                                [columns]="$any(headerLeafColumns)"
                                [groups]="isLocked ? [] : group"
                                [detailTemplate]="detailTemplate">
                            </colgroup>
                            <tfoot kendoGridFooter
                                [logicalRowIndex]="ariaRowCount"
                                [scrollable]="true"
                                [groups]="isLocked ? [] : group"
                                [columns]="$any(headerColumns)"
                                [lockedColumnsCount]="lockedLeafColumns.length"
                                [detailTemplate]="detailTemplate"
                                [totalColumns]="columnsContainer">
                            </tfoot>
                        </table>
                    </div>
                </div>
            </ng-container>
            <ng-container *ngIf="!isScrollable">
                <table
                    [style.table-layout]="resizable ? 'fixed' : null"
                    kendoGridTable
                    kendoGridResizableTable
                    role="presentation"
                    [size]="size">
                    <colgroup kendoGridColGroup
                        [columns]="$any(leafColumns)"
                        [groups]="group"
                        [detailTemplate]="detailTemplate">
                    </colgroup>
                    <thead kendoGridHeader
                        *ngIf="!hideHeader"
                        [resizable]="resizable"
                        [scrollable]="false"
                        [columns]="$any(visibleColumns)"
                        [totalColumnLevels]="totalColumnLevels"
                        [totalColumns]="columnsContainer"
                        [groups]="group"
                        [groupable]="showGroupPanel"
                        [reorderable]="reorderable"
                        [sort]="sort"
                        [sortable]="sortable"
                        [filter]="filter"
                        [filterable]="filterable"
                        [columnMenu]="columnMenuOptions"
                        [columnMenuTemplate]="columnMenuTemplate"
                        [detailTemplate]="detailTemplate"
                        [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                    </thead>
                    <tbody kendoGridTableBody
                        [isLoading]="loading"
                        [groups]="group"
                        [data]="$any(view)"
                        [skip]="skip"
                        [columns]="$any(leafColumns)"
                        [selectable]="selectable"
                        [filterable]="filterable"
                        [noRecordsTemplate]="noRecordsTemplate"
                        [detailTemplate]="detailTemplate"
                        [showGroupFooters]="showGroupFooters"
                        [trackBy]="trackBy"
                        [rowClass]="rowClass"
                        kendoDraggable
                        kendoGridSelectionMarquee
                        [enableDrag]="marqueeSelection">
                    </tbody>
                    <tfoot kendoGridFooter
                        *ngIf="showFooter"
                        [scrollable]="false"
                        [logicalRowIndex]="ariaRowCount"
                        [groups]="group"
                        [columns]="$any(leafColumns)"
                        [detailTemplate]="detailTemplate"
                        [totalColumns]="columnsContainer">
                    </tfoot>
                </table>
            </ng-container>
            <div [loadingTemplate]="loadingTemplate" *ngIf="loading" kendoGridLoading></div>
        </div>
        <kendo-grid-status-bar
            *ngIf="showStatusBar"
            [statusBarTemplate]="statusBarTemplate">
        </kendo-grid-status-bar>
        <kendo-pager
            *ngIf="showBottomPager"
            #bottomPager
            class="k-grid-pager"
            [navigable]="navigation.pagerEnabled"
            [pageSize]="pageSize"
            [total]="view.total"
            [skip]="skip"
            [size]="size"
            [responsive]="normalizedPageableSettings.responsive && !pagerTemplate"
            [buttonCount]="normalizedPageableSettings.buttonCount"
            [info]="normalizedPageableSettings.info"
            [pageSizeValues]="normalizedPageableSettings.pageSizes"
            [previousNext]="normalizedPageableSettings.previousNext"
            [type]="normalizedPageableSettings.type"
            (pageChange)="notifyPageChange('pager', $event)">
            <ng-template kendoPagerTemplate>
                <ng-container 
                    [ngTemplateOutlet]="pagerTemplate ? pagerTemplate?.templateRef : defaultPager"
                    [ngTemplateOutletContext]="bottomPager.templateContext"></ng-container>
            </ng-template>
            <kendo-pager-messages
                [ariaLabel]="messageFor('pagerLabel')"
                [firstPage]="messageFor('pagerFirstPage')"
                [inputLabel]="messageFor('pagerInputLabel')"
                [previousPage]="messageFor('pagerPreviousPage')"
                [nextPage]="messageFor('pagerNextPage')"
                [lastPage]="messageFor('pagerLastPage')"
                [selectPage]="messageFor('pagerSelectPage')"
                [page]="messageFor('pagerPage')"
                [itemsPerPage]="messageFor('pagerItemsPerPage')"
                [items]="messageFor('pagerItems')"
                [of]="messageFor('pagerOf')"
                [pageNumberInputTitle]="messageFor('pagerPageNumberInputTitle')">
            </kendo-pager-messages>
        </kendo-pager>
        <kendo-grid-toolbar
            class="k-grid-toolbar-bottom"
            *ngIf="showBottomToolbar"
            [size]="size"
            [navigable]="navigation.toolbarEnabled"
            [attr.aria-label]="messageFor('bottomToolbarLabel')"
            [attr.aria-controls]="ariaRootId"
            position="bottom">
        </kendo-grid-toolbar>

        <ng-template #defaultHint>
            <kendo-icon-wrapper
                [name]="getHintSettings('hintIcon')"
                [svgIcon]="getHintSettings('hintSVGIcon')"
                innerCssClass="k-drag-status">
            </kendo-icon-wrapper>
            {{hintText}}
        </ng-template>

        <ng-template #defaultPager>
            <div class="k-pager-numbers-wrap">
                <kendo-pager-prev-buttons [size]="size" *ngIf="normalizedPageableSettings.previousNext"></kendo-pager-prev-buttons>
                <kendo-pager-numeric-buttons
                    [size]="size"
                    *ngIf="normalizedPageableSettings.type === 'numeric' && normalizedPageableSettings.buttonCount > 0"
                    [buttonCount]="normalizedPageableSettings.buttonCount">
                </kendo-pager-numeric-buttons>
                <kendo-pager-input [size]="size" *ngIf="normalizedPageableSettings.type === 'input'"></kendo-pager-input>
                <kendo-pager-next-buttons [size]="size" *ngIf="normalizedPageableSettings.previousNext"></kendo-pager-next-buttons>
            </div>
            <kendo-pager-page-sizes *ngIf="normalizedPageableSettings.pageSizes"
                [size]="size"
                [pageSizes]="normalizedPageableSettings.pageSizes">
            </kendo-pager-page-sizes>
            <kendo-pager-info *ngIf="normalizedPageableSettings.info">
            </kendo-pager-info>
        </ng-template>
        <div kendoWatermarkOverlay *ngIf="showLicenseWatermark"></div>
    `,
                    standalone: true,
                    imports: [
                        LocalizedMessagesDirective, NgIf, ToolbarComponent, GroupPanelComponent,
                        TableDirective, GridTableDirective, ColGroupComponent, HeaderComponent, ResizableContainerDirective,
                        ListComponent, DragTargetContainerDirective, DropTargetContainerDirective, DraggableDirective,
                        GridMarqueeDirective, FooterComponent, TableBodyComponent, LoadingComponent, StatusBarComponent,
                        IconWrapperComponent, WatermarkOverlayComponent, ...KENDO_PAGER, NgTemplateOutlet
                    ]
                }]
        }], ctorParameters: function () { return [{ type: BrowserSupportService }, { type: SelectionService }, { type: CellSelectionService }, { type: i0.ElementRef }, { type: GroupInfoService }, { type: GroupsService }, { type: ChangeNotificationService }, { type: DetailsService }, { type: EditService }, { type: FilterService }, { type: PDFService }, { type: ResponsiveService }, { type: i0.Renderer2 }, { type: ExcelService }, { type: i0.NgZone }, { type: ScrollSyncService }, { type: DomEventsService }, { type: ColumnResizingService }, { type: i0.ChangeDetectorRef }, { type: ColumnReorderService }, { type: ColumnInfoService }, { type: NavigationService }, { type: SortService }, { type: ScrollRequestService }, { type: i1$2.LocalizationService }, { type: ContextService }, { type: SizingOptionsService }, { type: RowReorderService }]; }, propDecorators: { data: [{
                type: Input
            }], pageSize: [{
                type: Input
            }], height: [{
                type: Input
            }], rowHeight: [{
                type: Input
            }], detailRowHeight: [{
                type: Input
            }], skip: [{
                type: Input
            }], scrollable: [{
                type: Input
            }], selectable: [{
                type: Input
            }], sort: [{
                type: Input
            }], size: [{
                type: Input
            }], trackBy: [{
                type: Input
            }], filter: [{
                type: Input
            }], group: [{
                type: Input
            }], virtualColumns: [{
                type: Input
            }], filterable: [{
                type: Input
            }], sortable: [{
                type: Input
            }], pageable: [{
                type: Input
            }], groupable: [{
                type: Input
            }], rowReorderable: [{
                type: Input
            }], navigable: [{
                type: Input
            }], navigatable: [{
                type: Input
            }], autoSize: [{
                type: Input
            }], rowClass: [{
                type: Input
            }], rowSticky: [{
                type: Input
            }], rowSelected: [{
                type: Input
            }], isRowSelectable: [{
                type: Input
            }], cellSelected: [{
                type: Input
            }], resizable: [{
                type: Input
            }], reorderable: [{
                type: Input
            }], loading: [{
                type: Input
            }], columnMenu: [{
                type: Input
            }], hideHeader: [{
                type: Input
            }], filterChange: [{
                type: Output
            }], pageChange: [{
                type: Output
            }], groupChange: [{
                type: Output
            }], sortChange: [{
                type: Output
            }], selectionChange: [{
                type: Output
            }], rowReorder: [{
                type: Output
            }], dataStateChange: [{
                type: Output
            }], groupExpand: [{
                type: Output
            }], groupCollapse: [{
                type: Output
            }], detailExpand: [{
                type: Output
            }], detailCollapse: [{
                type: Output
            }], edit: [{
                type: Output
            }], cancel: [{
                type: Output
            }], save: [{
                type: Output
            }], remove: [{
                type: Output
            }], add: [{
                type: Output
            }], cellClose: [{
                type: Output
            }], cellClick: [{
                type: Output
            }], pdfExport: [{
                type: Output
            }], excelExport: [{
                type: Output
            }], columnResize: [{
                type: Output
            }], columnReorder: [{
                type: Output
            }], columnVisibilityChange: [{
                type: Output
            }], columnLockedChange: [{
                type: Output
            }], columnStickyChange: [{
                type: Output
            }], scrollBottom: [{
                type: Output
            }], contentScroll: [{
                type: Output
            }], columns: [{
                type: ContentChildren,
                args: [ColumnBase]
            }], dir: [{
                type: HostBinding,
                args: ['attr.dir']
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-grid']
            }], sizeSmallClass: [{
                type: HostBinding,
                args: ['class.k-grid-sm']
            }], sizeMediumClass: [{
                type: HostBinding,
                args: ['class.k-grid-md']
            }], lockedClasses: [{
                type: HostBinding,
                args: ['class.k-grid-lockedcolumns']
            }], virtualClasses: [{
                type: HostBinding,
                args: ['class.k-grid-virtual']
            }], noScrollbarClass: [{
                type: HostBinding,
                args: ['class.k-grid-no-scrollbar']
            }], detailTemplateChildren: [{
                type: ContentChildren,
                args: [DetailTemplateDirective]
            }], cellLoadingTemplateChildren: [{
                type: ContentChildren,
                args: [CellLoadingTemplateDirective]
            }], loadingTemplateChildren: [{
                type: ContentChildren,
                args: [LoadingTemplateDirective]
            }], statusBarTemplateChildren: [{
                type: ContentChildren,
                args: [StatusBarTemplateDirective]
            }], noRecordsTemplateChildren: [{
                type: ContentChildren,
                args: [NoRecordsTemplateDirective]
            }], pagerTemplateChildren: [{
                type: ContentChildren,
                args: [PagerTemplateDirective]
            }], toolbarTemplateChildren: [{
                type: ContentChildren,
                args: [ToolbarTemplateDirective]
            }], columnMenuTemplates: [{
                type: ContentChildren,
                args: [ColumnMenuTemplateDirective]
            }], lockedHeader: [{
                type: ViewChild,
                args: ['lockedHeader', { static: false }]
            }], header: [{
                type: ViewChild,
                args: ['header', { static: false }]
            }], footer: [{
                type: ViewChildren,
                args: ['footer']
            }], ariaRoot: [{
                type: ViewChild,
                args: ['ariaRoot', { static: true }]
            }], dragTargetContainer: [{
                type: ViewChild,
                args: [DragTargetContainerDirective]
            }], dropTargetContainer: [{
                type: ViewChild,
                args: [DropTargetContainerDirective]
            }], isDetailExpanded: [{
                type: Input
            }], isGroupExpanded: [{
                type: Input
            }] } });

/**
 * Custom component messages override default component messages
 * ([see example](slug:globalization_grid#toc-custom-messages)).
 */
class CustomMessagesComponent extends GridMessages {
    service;
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CustomMessagesComponent, deps: [{ token: i1$2.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: CustomMessagesComponent, isStandalone: true, selector: "kendo-grid-messages", providers: [
            {
                provide: GridMessages,
                useExisting: forwardRef(() => CustomMessagesComponent)
            }
        ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CustomMessagesComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: GridMessages,
                            useExisting: forwardRef(() => CustomMessagesComponent)
                        }
                    ],
                    selector: 'kendo-grid-messages',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i1$2.LocalizationService }]; } });

/**
 * A directive which encapsulates the in-memory handling of data operations such as [paging]({% slug paging_grid %}),
 * [sorting]({% slug sorting_grid %}), and [grouping]({% slug grouping_grid %})
 * ([more information and examples]({% slug local_data_grid %}#toc-using-the-data-binding-directive)).
 *
 * @example
 * ```html
 * <kendo-grid [kendoGridBinding]="gridData" ...></kendo-grid>
 * ```
 */
class DataBindingDirective {
    grid;
    changeDetector;
    localDataChangesService;
    rowReorderService;
    /**
     * Defines the number of records that will be skipped by the pager.
     * @default 0
     */
    set skip(value) {
        if (!isPresent(value)) {
            value = 0;
        }
        this.grid.skip = this.state.skip = value;
        if (this.rowReorderService) {
            this.rowReorderService.skip = value;
        }
    }
    /**
     * Defines the descriptors by which the data will be sorted.
     */
    set sort(value) {
        this.grid.sort = this.state.sort = value;
    }
    /**
     * Defines the descriptor by which the data will be filtered.
     */
    set filter(value) {
        this.grid.filter = this.state.filter = value;
    }
    /**
     * Defines the page size used by the Grid pager.
     */
    set pageSize(value) {
        this.grid.pageSize = this.state.take = value;
    }
    /**
     * The descriptors by which the data will be grouped.
     */
    set group(value) {
        this.grid.group = this.state.group = value;
    }
    /**
     * The array of data which will be used to populate the Grid.
     */
    set data(value) {
        this.originalData = value || [];
        if (this.localDataChangesService) {
            this.localDataChangesService.data = value;
        }
        this.dataChanged = true;
    }
    state = {
        skip: 0
    };
    originalData = [];
    dataChanged;
    stateChangeSubscription;
    dataChangedSubscription;
    rowReorderSubscription;
    constructor(grid, changeDetector, localDataChangesService, rowReorderService) {
        this.grid = grid;
        this.changeDetector = changeDetector;
        this.localDataChangesService = localDataChangesService;
        this.rowReorderService = rowReorderService;
        if (localDataChangesService) {
            this.dataChangedSubscription = this.localDataChangesService.changes.subscribe(this.rebind.bind(this));
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.applyState(this.state);
        this.stateChangeSubscription = this.grid
            .dataStateChange
            .subscribe(this.onStateChange.bind(this));
        if (this.rowReorderService) {
            this.rowReorderSubscription = this.grid
                .rowReorder
                .subscribe(this.onRowReorder.bind(this));
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.stateChangeSubscription) {
            this.stateChangeSubscription.unsubscribe();
        }
        if (this.dataChangedSubscription) {
            this.dataChangedSubscription.unsubscribe();
        }
        if (this.rowReorderSubscription) {
            this.rowReorderSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (anyChanged(["pageSize", "skip", "sort", "group", "filter"], changes)) {
            this.rebind();
        }
    }
    ngDoCheck() {
        if (this.dataChanged) {
            this.updateGridData();
        }
    }
    /**
     * @hidden
     */
    onStateChange(state) {
        this.applyState(state);
        this.rebind();
    }
    /**
     * @hidden
     */
    onRowReorder(ev) {
        this.rowReorderService.reorderRows(ev, this.originalData);
        this.rebind();
    }
    /**
     * @hidden
     */
    rebind() {
        this.data = this.originalData;
        this.updateGridData();
        this.notifyDataChange();
    }
    /**
     * Notifies the Grid that its data has changed.
     */
    notifyDataChange() {
        this.grid.onDataChange();
        if (this.changeDetector) {
            this.changeDetector.markForCheck();
        }
    }
    process(state) {
        return process(this.originalData, state);
    }
    applyState({ skip, take, sort, group, filter }) {
        this.skip = skip;
        this.pageSize = take;
        this.sort = sort;
        this.group = group;
        this.filter = filter;
    }
    updateGridData() {
        this.grid.data = this.process(this.state);
        this.grid.updateNavigationMetadata();
        this.dataChanged = false;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DataBindingDirective, deps: [{ token: GridComponent }, { token: i0.ChangeDetectorRef }, { token: LocalDataChangesService }, { token: RowReorderService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: DataBindingDirective, isStandalone: true, selector: "[kendoGridBinding]", inputs: { skip: "skip", sort: "sort", filter: "filter", pageSize: "pageSize", group: "group", data: ["kendoGridBinding", "data"] }, exportAs: ["kendoGridBinding"], usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DataBindingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridBinding]',
                    exportAs: 'kendoGridBinding',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: GridComponent }, { type: i0.ChangeDetectorRef }, { type: LocalDataChangesService }, { type: RowReorderService }]; }, propDecorators: { skip: [{
                type: Input
            }], sort: [{
                type: Input
            }], filter: [{
                type: Input
            }], pageSize: [{
                type: Input
            }], group: [{
                type: Input
            }], data: [{
                type: Input,
                args: ["kendoGridBinding"]
            }] } });

/**
 * A directive which stores the row selection state of the Grid in memory
 * ([see example]({% slug selection_grid %}#toc-toggling-the-selection-functionality)).
 */
class SelectionDirective extends Selection {
    ctx;
    constructor(ctx, cd) {
        super(ctx, cd);
        this.ctx = ctx;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this.ctx.grid.selectable === false) {
            this.ctx.grid.selectable = true;
        }
        this.ctx.grid.selectionDirective = this;
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        super.destroy();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SelectionDirective, deps: [{ token: ContextService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: SelectionDirective, isStandalone: true, selector: "[kendoGridSelectBy]", usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SelectionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridSelectBy]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ContextService }, { type: i0.ChangeDetectorRef }]; } });

/**
 * @hidden
 */
class LocalEditService {
    grid;
    localDataChangesService;
    constructor(grid, localDataChangesService) {
        this.grid = grid;
        this.localDataChangesService = localDataChangesService;
    }
    create(item) {
        if (this.hasLocalData && this.grid.skip) {
            this.localDataChangesService.data.splice(this.grid.skip, 0, item);
        }
        else {
            this.data.unshift(item);
        }
        this.dataChanged();
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    update(_item) { }
    remove(item) {
        const data = this.data;
        for (let idx = 0; idx < data.length; idx++) {
            if (item === data[idx]) {
                data.splice(idx, 1);
                this.dataChanged({ action: 'remove', item: item });
                break;
            }
        }
    }
    assignValues(target, source) {
        Object.assign(target, source);
    }
    dataChanged(args = {}) {
        if (this.hasLocalData) {
            this.localDataChangesService.changes.emit(args);
        }
    }
    get hasLocalData() {
        return Array.isArray(this.localDataChangesService.data);
    }
    get data() {
        if (this.hasLocalData) {
            return this.localDataChangesService.data;
        }
        const data = this.grid.data;
        if (Array.isArray(data)) {
            return data;
        }
        if (isDevMode()) {
            throw new Error(GridConfigurationErrorMessages.requiredEditService);
        }
        return [];
    }
}

/**
 * @hidden
 */
class EditingDirectiveBase {
    grid;
    localDataChangesService;
    // Consider adding support for the dependency injection of the service to allow for specifying a generic service without code.
    // The Input should still be kept.
    /**
     * The edit service that will handle the operations.
     */
    set editService(value) {
        this.userEditService = value;
    }
    get editService() {
        return this.userEditService || this.defaultEditService;
    }
    /**
     * A function that is called to confirm if the `dataItem` will be removed.
     */
    removeConfirmation;
    subscriptions = new Subscription();
    defaultEditService;
    userEditService;
    constructor(grid, localDataChangesService) {
        this.grid = grid;
        this.localDataChangesService = localDataChangesService;
        this.defaultEditService = this.createDefaultService();
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.subscriptions.add(this.grid.add.subscribe(this.addHandler.bind(this)));
        this.subscriptions.add(this.grid.remove.subscribe(this.removeHandler.bind(this)));
        this.subscriptions.add(this.grid.cancel.subscribe(this.cancelHandler.bind(this)));
        this.subscriptions.add(this.grid.save.subscribe(this.saveHandler.bind(this)));
        this.subscriptions.add(this.grid.dataStateChange.subscribe(this.onStateChange.bind(this)));
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    createDefaultService() {
        return new LocalEditService(this.grid, this.localDataChangesService);
    }
    addHandler() {
        this.grid.addRow(this.createModel({ isNew: true }));
    }
    saveHandler(args) {
        const item = this.saveModel(args);
        if (item) {
            if (args.isNew) {
                this.editService.create(item);
            }
            else {
                this.editService.update(item);
            }
        }
        this.grid.closeRow(args.rowIndex);
    }
    cancelHandler({ rowIndex }) {
        this.closeEditor(rowIndex);
    }
    removeHandler({ dataItem }) {
        const removeItem = (shouldRemove) => {
            if (shouldRemove) {
                this.editService.remove(dataItem);
            }
        };
        if (this.removeConfirmation) {
            const result = this.removeConfirmation(dataItem);
            if (result instanceof Promise) {
                result.then(removeItem);
            }
            else if (result instanceof Observable) {
                result.pipe(take(1)).subscribe(removeItem);
            }
            else {
                removeItem(result);
            }
        }
        else {
            removeItem(true);
        }
    }
    onStateChange() {
        this.closeEditor();
    }
    closeEditor(rowIndex) {
        this.grid.closeRow(rowIndex);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EditingDirectiveBase, deps: [{ token: GridComponent }, { token: LocalDataChangesService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: EditingDirectiveBase, selector: "[kendoGridEditingDirectiveBase]", inputs: { editService: "editService", removeConfirmation: "removeConfirmation" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EditingDirectiveBase, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridEditingDirectiveBase]'
                }]
        }], ctorParameters: function () { return [{ type: GridComponent }, { type: LocalDataChangesService }]; }, propDecorators: { editService: [{
                type: Input
            }], removeConfirmation: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class LocalRowEditService extends LocalEditService {
    update(_item) {
        this.dataChanged();
    }
}

/**
 * @hidden
 */
class RowEditingDirectiveBase extends EditingDirectiveBase {
    rowIndex;
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this.subscriptions
            .add(this.grid.edit.subscribe(this.editHandler.bind(this)));
    }
    createDefaultService() {
        return new LocalRowEditService(this.grid, this.localDataChangesService);
    }
    addHandler() {
        this.closeEditor();
        super.addHandler();
    }
    editHandler(args) {
        this.closeEditor();
        this.rowIndex = args.rowIndex;
        this.grid.editRow(args.rowIndex, this.createModel(args));
    }
    saveHandler(args) {
        super.saveHandler(args);
        this.clean();
    }
    closeEditor(rowIndex = this.rowIndex) {
        super.closeEditor(rowIndex);
        this.clean();
    }
    clean() {
        delete this.rowIndex;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: RowEditingDirectiveBase, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: RowEditingDirectiveBase, selector: "[kendoGridRowEditingDirectiveBase]", usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: RowEditingDirectiveBase, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridRowEditingDirectiveBase]'
                }]
        }] });

/**
 * A directive which encapsulates the editing operations of the Grid when using
 * the Template-Driven Angular Forms ([see example]({% slug editing_directives_grid %}#toc-template-editing-directive)).
 */
class TemplateEditingDirective extends RowEditingDirectiveBase {
    grid;
    localDataChangesService;
    /**
     * The function that creates the `dataItem` for the new rows.
     */
    createNewItem;
    dataItem;
    originalValues;
    constructor(grid, localDataChangesService) {
        super(grid, localDataChangesService);
        this.grid = grid;
        this.localDataChangesService = localDataChangesService;
    }
    editHandler(args) {
        super.editHandler(args);
        this.dataItem = args.dataItem;
        this.originalValues = {};
        this.editService.assignValues(this.originalValues, this.dataItem);
    }
    closeEditor(rowIndex) {
        if (this.dataItem) {
            this.editService.assignValues(this.dataItem, this.originalValues);
        }
        super.closeEditor(rowIndex);
    }
    createModel(args) {
        if (args.isNew) {
            return this.createNewItem();
        }
    }
    saveModel(args) {
        return args.dataItem;
    }
    clean() {
        super.clean();
        delete this.dataItem;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TemplateEditingDirective, deps: [{ token: GridComponent }, { token: LocalDataChangesService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: TemplateEditingDirective, isStandalone: true, selector: "[kendoGridTemplateEditing]", inputs: { createNewItem: ["kendoGridTemplateEditing", "createNewItem"] }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TemplateEditingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridTemplateEditing]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: GridComponent }, { type: LocalDataChangesService }]; }, propDecorators: { createNewItem: [{
                type: Input,
                args: ['kendoGridTemplateEditing']
            }] } });

/**
 * @hidden
 */
const markAllAsTouched = (control) => {
    control.markAsTouched();
    if (control.hasOwnProperty('controls')) {
        const controls = control.controls;
        for (const inner in controls) {
            if (controls.hasOwnProperty(inner)) {
                markAllAsTouched(controls[inner]);
            }
        }
    }
};

/**
 * A directive which encapsulates the editing operations of the Grid when using the
 * Reactive Forms ([see example](slug:editing_directives_grid#toc-reactive-editing-directive)).
 */
class ReactiveEditingDirective extends RowEditingDirectiveBase {
    grid;
    localDataChangesService;
    /**
     * The function that creates the `FormGroup` for the edited model.
     */
    createFormGroup;
    constructor(grid, localDataChangesService) {
        super(grid, localDataChangesService);
        this.grid = grid;
        this.localDataChangesService = localDataChangesService;
    }
    createModel(args) {
        return this.createFormGroup(args);
    }
    saveModel({ dataItem, formGroup, isNew }) {
        if (!formGroup.dirty && !isNew) {
            return;
        }
        if (formGroup.valid) {
            this.editService.assignValues(dataItem, formGroup.value);
            return dataItem;
        }
        markAllAsTouched(formGroup);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ReactiveEditingDirective, deps: [{ token: GridComponent }, { token: LocalDataChangesService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: ReactiveEditingDirective, isStandalone: true, selector: "[kendoGridReactiveEditing]", inputs: { createFormGroup: ["kendoGridReactiveEditing", "createFormGroup"] }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ReactiveEditingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridReactiveEditing]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: GridComponent }, { type: LocalDataChangesService }]; }, propDecorators: { createFormGroup: [{
                type: Input,
                args: ['kendoGridReactiveEditing']
            }] } });

/**
 * A directive which encapsulates the editing operations of the Grid when using the in-cell
 * editing with Reactive Forms ([see example]({% slug editing_directives_grid %}#toc-in-cell-editing)).
 */
class InCellEditingDirective extends EditingDirectiveBase {
    grid;
    localDataChangesService;
    cdr;
    /**
     * The function that creates the `FormGroup` for the edited model.
     */
    createFormGroup;
    constructor(grid, localDataChangesService, cdr) {
        super(grid, localDataChangesService);
        this.grid = grid;
        this.localDataChangesService = localDataChangesService;
        this.cdr = cdr;
    }
    // Need mixin
    createModel(args) {
        return this.createFormGroup(args);
    }
    saveModel({ dataItem, formGroup, isNew }) {
        if (!formGroup.dirty && !isNew) {
            return;
        }
        if (formGroup.valid) {
            this.editService.assignValues(dataItem, formGroup.value);
            return dataItem;
        }
        markAllAsTouched(formGroup);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this.subscriptions.add(this.grid.cellClick.subscribe(this.cellClickHandler.bind(this)));
        this.subscriptions.add(this.grid.cellClose.subscribe(this.cellCloseHandler.bind(this)));
    }
    removeHandler(args) {
        super.removeHandler(args);
        this.grid.cancelCell();
    }
    cellClickHandler(args) {
        if (!args.isEdited && args.type !== 'contextmenu') {
            this.grid.editCell(args.rowIndex, args.columnIndex, this.createFormGroup(args));
            this.cdr.markForCheck();
        }
    }
    cellCloseHandler(args) {
        const { formGroup, dataItem } = args;
        if (!formGroup.valid) {
            args.preventDefault();
        }
        else if (formGroup.dirty) {
            if (args.originalEvent && args.originalEvent.keyCode === Keys.Escape) {
                return;
            }
            this.editService.assignValues(dataItem, formGroup.value);
            this.editService.update(dataItem);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: InCellEditingDirective, deps: [{ token: GridComponent }, { token: LocalDataChangesService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: InCellEditingDirective, isStandalone: true, selector: "[kendoGridInCellEditing]", inputs: { createFormGroup: ["kendoGridInCellEditing", "createFormGroup"] }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: InCellEditingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridInCellEditing]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: GridComponent }, { type: LocalDataChangesService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { createFormGroup: [{
                type: Input,
                args: ['kendoGridInCellEditing']
            }] } });

/**
 * A directive which controls the expanded state of the master detail rows. ([see example](slug:master_detail_expanded_state_grid#toc-built-in-directive))
 */
class ExpandDetailsDirective {
    grid;
    /**
     * Fires when the expandedDetailKeys are changed.
     */
    expandedDetailKeysChange = new EventEmitter();
    /**
     * Defines the item key that will be stored in the `expandedDetailKeys` collection ([see example]({% slug master_detail_expanded_state_grid %}#toc-built-in-directive)).
     */
    get expandDetailsKey() {
        return this._expandBy;
    }
    set expandDetailsKey(key) {
        if (isString(key)) {
            this._expandBy = getter(key);
        }
        else {
            this._expandBy = key;
        }
    }
    /**
     *
     * @hidden
     * A deprecated alias for setting the `expandDetailsKey` property.
     */
    get expandDetailBy() {
        return this.expandDetailsKey;
    }
    set expandDetailBy(key) {
        this.expandDetailsKey = key;
    }
    /**
     * Defines the collection that will store the expanded keys.
     */
    expandedDetailKeys = [];
    /**
     * Specifies if the items should be initially expanded.
     * When set to `true` items added to the `expandedDetailKeys` collection will be collapsed, and items that are not present in it will be expanded.
     *
     * @default false
     */
    initiallyExpanded = false;
    expandedState = new Set();
    lastExpandedState;
    _expandBy;
    subscriptions = new Subscription();
    constructor(grid) {
        this.grid = grid;
        this.grid.isDetailExpanded = this.isExpanded.bind(this);
        this.subscriptions.add(merge(this.grid.detailExpand.pipe(map(e => ({ expand: true, ...e }))), this.grid.detailCollapse.pipe(map(e => ({ expand: false, ...e })))).subscribe(this.toggleState.bind(this)));
    }
    ngOnChanges(changes) {
        // skip reinitialization if the user data is the same as the last state change
        if (isPresent(changes['expandedDetailKeys']) && this.lastExpandedState !== this.expandedDetailKeys) {
            this.expandedState = new Set(this.expandedDetailKeys);
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    get keyGetter() {
        return this._expandBy || getter(undefined);
    }
    /**
     * @hidden
     */
    isExpanded(args) {
        const key = this.keyGetter(args.dataItem);
        const hasKey = this.expandedState.has(key);
        // when [initiallyExpanded]="true" a present key means the corresponding detail row is collapsed
        return this.initiallyExpanded ? !hasKey : hasKey;
    }
    toggleState(args) {
        const key = this.keyGetter(args.dataItem);
        if (Boolean(this.initiallyExpanded) !== args.expand) {
            this.expandedState.add(key);
        }
        else {
            this.expandedState.delete(key);
        }
        this.notifyChange();
    }
    notifyChange() {
        this.lastExpandedState = Array.from(this.expandedState);
        this.expandedDetailKeysChange.emit(this.lastExpandedState);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExpandDetailsDirective, deps: [{ token: GridComponent }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: ExpandDetailsDirective, isStandalone: true, selector: "[kendoGridExpandDetailsBy]", inputs: { expandDetailsKey: ["kendoGridExpandDetailsBy", "expandDetailsKey"], expandDetailBy: "expandDetailBy", expandedDetailKeys: "expandedDetailKeys", initiallyExpanded: "initiallyExpanded" }, outputs: { expandedDetailKeysChange: "expandedDetailKeysChange" }, exportAs: ["kendoGridExpandDetailsBy"], usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExpandDetailsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridExpandDetailsBy]',
                    exportAs: 'kendoGridExpandDetailsBy',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: GridComponent }]; }, propDecorators: { expandedDetailKeysChange: [{
                type: Output
            }], expandDetailsKey: [{
                type: Input,
                args: ['kendoGridExpandDetailsBy']
            }], expandDetailBy: [{
                type: Input
            }], expandedDetailKeys: [{
                type: Input
            }], initiallyExpanded: [{
                type: Input
            }] } });

const mapParentGroup = (parentGroup) => {
    const parentGroupKeys = [];
    while (parentGroup) {
        parentGroupKeys.push({ field: parentGroup.group.field, value: parentGroup.group.value });
        parentGroup = parentGroup.parentGroup;
    }
    return parentGroupKeys;
};
const DEFAULT_KEY_GETTER = (groupRowArgs) => ({
    field: groupRowArgs.group.field,
    value: groupRowArgs.group.value,
    parentGroupKeys: mapParentGroup(groupRowArgs.parentGroup)
});
/**
 * A directive which controls the expanded state of the group rows
 * ([see example]({% slug groups_expanded_state_grid %}#toc-built-in-directive)).
 */
class ExpandGroupDirective {
    grid;
    /**
     * Fires when the expandedGroupKeys are changed.
     */
    expandedGroupKeysChange = new EventEmitter();
    /**
     * Defines the item format that will be stored in the `expandedGroupKeys`
     * ([see example]({% slug groups_expanded_state_grid %}#toc-custom-group-key-format)).
     */
    get expandGroupBy() {
        return this._expandGroupBy;
    }
    set expandGroupBy(key) {
        if (typeof key === 'function') {
            this._expandGroupBy = key;
        }
    }
    /**
     * Defines the collection that will store the expanded group keys.
     */
    get expandedGroupKeys() {
        return this._expandedGroupKeys;
    }
    set expandedGroupKeys(expandedGroups) {
        this._expandedGroupKeys = (expandedGroups || []).slice();
    }
    /**
     * Specifies if the group items should be initially expanded.
     * @default false
     */
    groupsInitiallyExpanded = false;
    _expandGroupBy;
    _expandedGroupKeys;
    subscriptions = new Subscription();
    constructor(grid) {
        this.grid = grid;
        this.grid.isGroupExpanded = this.isExpanded.bind(this);
        this.subscriptions.add(merge(this.grid.groupExpand.pipe(map(e => ({ expand: true, ...e }))), this.grid.groupCollapse.pipe(map(e => ({ expand: false, ...e })))).subscribe(this.toggleState.bind(this)));
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    get keyGetter() {
        return this.expandGroupBy || DEFAULT_KEY_GETTER;
    }
    /**
     * @hidden
     */
    isExpanded(groupArgs) {
        const itemIndex = this.getItemIndex(groupArgs);
        return itemIndex > -1 ? !this.groupsInitiallyExpanded : this.groupsInitiallyExpanded;
    }
    getItemIndex(groupArgs) {
        if (this.expandGroupBy) {
            return this.expandedGroupKeys.indexOf(this.keyGetter(groupArgs));
        }
        return this.expandedGroupKeys.findIndex(item => {
            let index = 0;
            let parentGroup = groupArgs.parentGroup;
            while (isPresent(parentGroup)) {
                if (!isPresent(item.parentGroupKeys) || !isPresent(item.parentGroupKeys[index]) ||
                    parentGroup.group.value !== item.parentGroupKeys[index].value ||
                    parentGroup.group.field !== item.parentGroupKeys[index].field) {
                    return false;
                }
                parentGroup = parentGroup.parentGroup;
                index++;
            }
            return item.value === groupArgs.group.value && item.field === groupArgs.group.field;
        });
    }
    toggleState(groupArgs) {
        const key = this.keyGetter(groupArgs);
        if (Boolean(this.groupsInitiallyExpanded) !== groupArgs.expand) {
            this.expandedGroupKeys.push(key);
        }
        else {
            const index = this.expandedGroupKeys.findIndex(group => {
                if (this.expandGroupBy) {
                    return group === key;
                }
                else if (key.parentGroupKeys?.length === 0) {
                    return group.value === key.value;
                }
                return JSON.stringify(group) === JSON.stringify(key);
            });
            this.expandedGroupKeys.splice(index, 1);
        }
        this.expandedGroupKeysChange.emit(this.expandedGroupKeys.slice());
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExpandGroupDirective, deps: [{ token: GridComponent }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: ExpandGroupDirective, isStandalone: true, selector: "[kendoGridExpandGroupBy]", inputs: { expandGroupBy: ["kendoGridExpandGroupBy", "expandGroupBy"], expandedGroupKeys: "expandedGroupKeys", groupsInitiallyExpanded: "groupsInitiallyExpanded" }, outputs: { expandedGroupKeysChange: "expandedGroupKeysChange" }, exportAs: ["kendoGridExpandGroupBy"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExpandGroupDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridExpandGroupBy]',
                    exportAs: 'kendoGridExpandGroupBy',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: GridComponent }]; }, propDecorators: { expandedGroupKeysChange: [{
                type: Output
            }], expandGroupBy: [{
                type: Input,
                args: ['kendoGridExpandGroupBy']
            }], expandedGroupKeys: [{
                type: Input
            }], groupsInitiallyExpanded: [{
                type: Input
            }] } });

const hasGroups = (items) => items && items.length && items[0].field && items[0].items;
const groupDescriptorsPresent = (descriptors) => isPresent(descriptors) && descriptors.length > 0;
const processGroups = (data, state) => process(data, state).data;
const removeParentDescriptors = (parents, owner) => g => g.field !== owner.field && !parents.some(y => y.field === g.field);
const findGroup = (groupIndex, groups) => {
    const parents = [];
    return {
        group: groupIndex.split("_").reduce((acc, x) => {
            const idx = parseInt(x, 10);
            if (acc.items) {
                parents.push(acc);
                return acc.items[idx];
            }
            return isArray(acc) ? acc[idx] : acc;
        }, groups),
        parents
    };
};
const findChildren = (data, parents) => {
    const filters = parents.map(p => ({ field: p.field, operator: "eq", value: p.value }));
    return filterBy(data, {
        filters: filters,
        logic: "and"
    });
};
/**
 * @hidden
 */
const count = (groups, includeFooters = false) => (groups.reduce((acc, group) => {
    if (!group.skipHeader) {
        acc++;
    }
    if (group.items) {
        const children = count(group.items, includeFooters);
        if (includeFooters && children && !group.hideFooter) {
            acc++;
        }
        acc += children;
    }
    return acc;
}, 0));
/**
 * @hidden
 */
const noDescriptors = (descriptors) => !isPresent(descriptors) || !descriptors.length;
/**
 * @hidden
 */
const slice = (groups, skip, take, includeFooters = false) => {
    if (!isPresent(take)) {
        return groups;
    }
    const result = [];
    for (let idx = 0, length = groups.length; idx < length; idx++) {
        if (take <= 0) {
            break;
        }
        const group = groups[idx];
        const groupItems = group.items;
        let itemCount = count(groupItems, includeFooters);
        if (includeFooters && groupItems.length) {
            itemCount++;
        }
        const skipHeader = skip > 0;
        if (skip) {
            skip--;
            if (itemCount && skip >= itemCount) {
                skip -= itemCount;
                continue;
            }
        }
        if (!skipHeader || itemCount) {
            const items = [];
            let hideFooter = true;
            if (!skipHeader) {
                take--;
            }
            if (take) {
                if (hasGroups(groupItems)) {
                    const children = slice(groupItems, skip, take, includeFooters);
                    items.push(...children);
                    take -= count(children, includeFooters);
                }
                else {
                    items.push(...groupItems.slice(skip, Math.min(skip + take, groupItems.length)));
                    take -= items.length;
                }
                if (take && includeFooters) {
                    hideFooter = false;
                    take--;
                }
                skip = 0;
            }
            result.push({
                aggregates: group.aggregates,
                field: group.field,
                hideFooter,
                items,
                offset: idx,
                skipHeader,
                value: group.value
            });
        }
    }
    return result;
};
const skippedHeaders = (groupItem) => {
    let total = 0;
    while (groupItem) {
        if (groupItem.skipHeader) {
            total++;
        }
        groupItem = groupItem.items && groupItem.items[0] || null;
    }
    return total;
};
/**
 * A directive which encapsulates the in-memory handling of grouping with virtual scrolling.
 */
class GroupBindingDirective extends DataBindingDirective {
    groupsService;
    /**
     * The array of data which will be used to populate the Grid.
     */
    set kendoGridGroupBinding(value) {
        this.groups = null;
        this.grid.resetGroupsState();
        this.data = value;
    }
    /**
     * @hidden
     */
    set data(value) {
        this.originalData = value || [];
        this.dataChanged = true;
    }
    /**
     * Defines the descriptors by which the data will be sorted.
     */
    set sort(value) {
        const noCurrentDescriptors = noDescriptors(this.state.sort);
        const noIncomingDescriptors = noDescriptors(value);
        const clear = this.state.sort !== value && !(noCurrentDescriptors && noIncomingDescriptors);
        this.grid.sort = this.state.sort = value;
        if (clear) {
            this.groups = null;
            this.grid.resetGroupsState();
        }
    }
    /**
     * Defines the descriptor by which the data will be filtered.
     */
    set filter(value) {
        const clear = diffFilters(this.state.filter, value);
        if (clear) {
            this.state.filter = value;
            this.grid.filter = cloneFilters(value);
            this.groups = null;
            this.grid.resetGroupsState();
        }
    }
    /**
     * Defines the descriptors by which the data will be grouped.
     */
    set group(value) {
        // don't clear if no groups are present in previous and current value
        const groupsPresent = groupDescriptorsPresent(this.state.group) || groupDescriptorsPresent(value);
        const clear = this.state.group !== value && groupsPresent;
        this.grid.group = this.state.group = value;
        if (clear) {
            this.groups = null;
            this.grid.resetGroupsState();
            this.skip = 0;
        }
    }
    groups;
    gridSubs = new Subscription();
    constructor(changeDetector, localDataChangesService, ctxService, groupsService) {
        super(ctxService.grid, changeDetector, localDataChangesService);
        this.groupsService = groupsService;
        ctxService.groupBindingDirective = this;
    }
    ngOnInit() {
        super.ngOnInit();
        this.gridSubs.add(this.grid.groupExpand.subscribe(this.groupExpand.bind(this)));
        this.gridSubs.add(this.grid.groupCollapse.subscribe(this.groupCollapse.bind(this)));
    }
    ngAfterContentInit() {
        if (isDevMode() && this.grid.isGroupExpanded) {
            throw new Error(GridConfigurationErrorMessages.groupBindingDirectives);
        }
    }
    ngOnDestroy() {
        this.gridSubs.unsubscribe();
    }
    /**
     * @hidden
     */
    toggleAll(expand) {
        this.skip = 0;
        this.grid.scrollTo({ row: 0, column: 0 });
        this.groups.forEach((gr, idx) => {
            const expanded = this.groupsService.isExpanded({
                group: gr,
                groupIndex: idx.toString(),
                parentGroup: undefined
            });
            const performToggle = (expand && !expanded) || (!expand && expanded);
            if (performToggle) {
                this.grid.groupsService.toggleRow({
                    type: 'group',
                    data: gr,
                    index: idx.toString(),
                    level: 0,
                    parentGroup: undefined
                });
                this[expand ? 'groupExpand' : 'groupCollapse']({ groupIndex: idx.toString() });
            }
        });
    }
    /**
     * Collapses all expanded root level groups.
     */
    collapseAll() {
        this.toggleAll(false);
    }
    /**
     * Expands all expanded root level groups.
     */
    expandAll() {
        this.toggleAll(true);
    }
    /**
     * @hidden
     */
    groupExpand({ groupIndex }) {
        const { group, parents } = findGroup(groupIndex, this.groups);
        if (!group) {
            return;
        }
        this.groupsService.expandChildren(groupIndex);
        if (!group.items.length) {
            const descriptors = this.state.group.filter(removeParentDescriptors(parents, group));
            const children = findChildren(this.originalData, parents.concat(group));
            group.items = processGroups(children, {
                filter: this.state.filter,
                group: descriptors,
                sort: this.state.sort
            });
        }
        this.grid.data = this.dataResult(this.state.skip, this.state.take);
    }
    /**
     * @hidden
     */
    groupCollapse({ groupIndex }) {
        const { group } = findGroup(groupIndex, this.groups);
        if (group) {
            group.items = [];
        }
        else {
            return;
        }
        this.grid.data = this.dataResult(this.state.skip, this.state.take);
    }
    process(state) {
        if (state.group && state.group.length) {
            const groups = this.processGroups(state);
            this.grid.skip -= skippedHeaders(groups.data[0]);
            return groups;
        }
        else {
            this.groups = null;
        }
        return super.process(state);
    }
    processGroups(state) {
        if (!this.groups || !this.groups.length) {
            this.groups = processGroups(this.originalData, {
                filter: state.filter,
                group: state.group,
                sort: state.sort
            });
        }
        return this.dataResult(state.skip, state.take);
    }
    dataResult(skip, take) {
        const includeFooters = this.grid.showGroupFooters;
        return {
            data: slice(this.groups, skip, take, includeFooters),
            total: count(this.groups, includeFooters)
        };
    }
    applyState({ skip, take, sort, group, filter }) {
        this.skip = skip;
        this.state.take = take;
        // this.pageSize = take; // do need to update take as the process with slice correctly
        this.sort = sort;
        this.group = group;
        this.filter = filter;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GroupBindingDirective, deps: [{ token: i0.ChangeDetectorRef }, { token: LocalDataChangesService }, { token: ContextService }, { token: GroupsService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: GroupBindingDirective, isStandalone: true, selector: "[kendoGridGroupBinding]", inputs: { kendoGridGroupBinding: "kendoGridGroupBinding", sort: "sort", filter: "filter", group: "group" }, exportAs: ["kendoGridGroupBinding"], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GroupBindingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridGroupBinding]',
                    exportAs: 'kendoGridGroupBinding',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: LocalDataChangesService }, { type: ContextService }, { type: GroupsService }]; }, propDecorators: { kendoGridGroupBinding: [{
                type: Input,
                args: ["kendoGridGroupBinding"]
            }], sort: [{
                type: Input
            }], filter: [{
                type: Input
            }], group: [{
                type: Input
            }] } });

/**
 * Represents the Kendo UI GridSpacer component for Angular.
 * Used to give additional white space between the Pager inner elements,
 * and provides a way for customizing the spacer width.
 * It can also be used in any flex container within the Grid
 * ([see example](slug:toolbartemplate_grid#toc-defining-the-spacing-between-toolbar-elements)).
 */
class GridSpacerComponent {
    hostClass = true;
    get sizedClass() {
        return isPresent(this.width);
    }
    get flexBasisStyle() {
        return this.width;
    }
    /**
     * Specifies the width of the GridSpacer.
     * Accepts the [string values of the CSS `flex-basis` property](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-basis).
     *
     * If not set, the GridSpacer will take all the available space.
     */
    width;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridSpacerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: GridSpacerComponent, isStandalone: true, selector: "kendo-grid-spacer", inputs: { width: "width" }, host: { properties: { "class.k-spacer": "this.hostClass", "class.k-spacer-sized": "this.sizedClass", "style.flexBasis": "this.flexBasisStyle" } }, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridSpacerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-spacer',
                    template: ``,
                    standalone: true
                }]
        }], propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.k-spacer']
            }], sizedClass: [{
                type: HostBinding,
                args: ['class.k-spacer-sized']
            }], flexBasisStyle: [{
                type: HostBinding,
                args: ['style.flexBasis']
            }], width: [{
                type: Input
            }] } });

/**
 * A directive applied to all toolbar elements that need to be a part of the Grid
 * keyboard navigation.
 */
class GridToolbarFocusableDirective {
    host;
    ctx;
    /**
     * @hidden
     */
    get element() {
        return this.host.nativeElement;
    }
    /**
     * @hidden
     */
    get toolbarPosition() {
        return isDocumentAvailable() && this.host.nativeElement.closest('.k-toolbar')?.getAttribute('position');
    }
    constructor(host, ctx) {
        this.host = host;
        this.ctx = ctx;
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable() || !this.toolbarPosition) {
            return;
        }
        this.ctx[`${this.toolbarPosition}ToolbarNavigation`]?.navigableElements.push(this.element);
        this.ctx[`${this.toolbarPosition}ToolbarNavigation`]?.notify();
    }
    ngOnDestroy() {
        if (!isDocumentAvailable() || !this.toolbarPosition) {
            return;
        }
        const elements = this.ctx[`${this.toolbarPosition}ToolbarNavigation`].navigableElements;
        this.ctx[`${this.toolbarPosition}ToolbarNavigation`].navigableElements = elements.filter(el => el !== this.element);
        this.ctx[`${this.toolbarPosition}ToolbarNavigation`].notify();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridToolbarFocusableDirective, deps: [{ token: i0.ElementRef }, { token: ContextService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: GridToolbarFocusableDirective, isStandalone: true, selector: "\n        [kendoGridToolbarFocusable],\n        [kendoGridAddCommand],\n        [kendoGridCancelCommand],\n        [kendoGridEditCommand],\n        [kendoGridRemoveCommand],\n        [kendoGridSaveCommand],\n        [kendoGridExcelCommand],\n        [kendoGridPDFCommand]\n    ", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridToolbarFocusableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: `
        [kendoGridToolbarFocusable],
        [kendoGridAddCommand],
        [kendoGridCancelCommand],
        [kendoGridEditCommand],
        [kendoGridRemoveCommand],
        [kendoGridSaveCommand],
        [kendoGridExcelCommand],
        [kendoGridPDFCommand]
    `,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: ContextService }]; } });

/**
 * The directive that enables the Grid built-in clipboard support. Allows copy, cut, and paste interactions
 * with the Grid.
 */
class GridClipboardDirective {
    host;
    clipboardService;
    renderer;
    zone;
    /**
     * Determines the target of the clipboard operation ([see example]({% slug clipboard_grid %}#toc-clipboard-target)). The possible options are:
     * - `activeCell`
     * - `selection`
     *
     * @default 'selection'
     */
    set clipboardTarget(value) {
        if (isDevMode()) {
            this.zone.onStable.pipe(take(1)).subscribe(() => {
                if (value === 'activeCell' && !(this.host.navigable.length)) {
                    console.warn(ClipboardErrorMessages.clipboardTarget.activeCellNavigable);
                }
                else if (value === 'selection' && !(this.host.selectable || this.host.selectionDirective)) {
                    console.warn(ClipboardErrorMessages.selectionSelectable);
                }
            });
        }
        this._target = value;
    }
    get clipboardTarget() {
        return this._target;
    }
    /**
     * The `GridClipboardDirective` settings.
     *
     * @default { wholeRow: false, copyHeaders: false copy: true, cut: true, paste: true }
     */
    set clipboardSettings(value) {
        this._clipboardSettings = Object.assign({}, this._clipboardSettings, value);
    }
    get clipboardSettings() {
        return this._clipboardSettings;
    }
    /**
     * Fires when the user performs `cut`, `copy` or `paste` action within the Grid content area.
     */
    clipboard = new EventEmitter();
    _target = 'selection';
    _clipboardSettings = {
        wholeRow: false,
        copyHeaders: false,
        copy: true,
        cut: true,
        paste: true
    };
    subs = new Subscription();
    constructor(host, clipboardService, renderer, zone) {
        this.host = host;
        this.clipboardService = clipboardService;
        this.renderer = renderer;
        this.zone = zone;
    }
    ngAfterViewInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.clipboardTarget === 'selection' && !(this.host.selectable || this.host.selectionDirective)) {
            console.warn(ClipboardErrorMessages.selectionSelectable);
        }
        // needed due to the following issue in Chrome
        // https://bugs.chromium.org/p/chromium/issues/detail?id=1156117&q=focus%20programmatically%20paste&can=2
        this.zone.runOutsideAngular(() => {
            this.subs.add(this.renderer.listen(document, 'copy', (args) => this.onClipboard('copy', args)));
            this.subs.add(this.renderer.listen(document, 'cut', (args) => this.onClipboard('cut', args)));
            this.subs.add(this.renderer.listen(document, 'paste', (args) => this.onClipboard('paste', args)));
        });
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    onClipboard = (operationType, args) => {
        if (!this.clipboardSettings[operationType] || !this.inGrid(args)) {
            return;
        }
        const gridData = Array.isArray(this.host.data) ? this.host.data : this.host.data.data;
        const gridDataItems = gridData.flatMap(recursiveFlatMap);
        const selection = this.host.selection;
        const selectionDirective = this.host.selectionDirective;
        const targetType = this.clipboardTarget;
        const isCellSelection = (this.host.selectable?.cell || selectionDirective.isCellSelectionMode);
        let clipboardData = [];
        switch (targetType) {
            case 'activeCell':
                {
                    const targetCell = { ...this.host.activeCell };
                    clipboardData = targetCell && [{ dataItem: targetCell.dataItem, dataRowIndex: targetCell.dataRowIndex, colIndex: targetCell.colIndex }];
                }
                break;
            case 'selection':
                {
                    const identifier = selectionDirective.selectionKey;
                    clipboardData = gridDataItems.flatMap((item, index) => {
                        if (identifier) {
                            const key = typeof identifier === 'string' ? item[identifier] : identifier({ index: index + this.host.skip, dataItem: item });
                            return isCellSelection ?
                                selection.some(s => s.itemKey === key) ? [{ dataItem: item, dataRowIndex: index + this.host.skip }] : [] :
                                selection.indexOf(key) > -1 ? [{ dataItem: item, dataRowIndex: index + this.host.skip }] : [];
                        }
                        return isCellSelection ?
                            selection.some(s => s.itemKey === index + this.host.skip) ? [{ dataItem: item, dataRowIndex: index + this.host.skip }] : [] :
                            selection.indexOf(index + this.host.skip) > -1 ? [{ dataItem: item, dataRowIndex: index + this.host.skip }] : [];
                    });
                }
                break;
        }
        const isPaste = operationType === 'paste';
        const pastedData = args.clipboardData.getData('text');
        const visibleCols = this.host.columns.toArray().filter(c => c.isVisible);
        const data = isPaste ?
            {
                dataString: pastedData,
                gridItems: this.clipboardService.getGridData(pastedData, visibleCols, this.clipboardTarget, clipboardData[0]?.dataRowIndex, {
                    wholeRow: this.clipboardSettings.wholeRow,
                    isCellSelection
                })
            } :
            this.clipboardService.createClipboardData(clipboardData || [], visibleCols, {
                wholeRow: this.clipboardSettings.wholeRow || (this.clipboardTarget === 'selection' && !isCellSelection),
                target: this.clipboardTarget,
                copyHeaders: this.clipboardSettings.copyHeaders,
                operationType
            });
        !isPaste && navigator.clipboard.writeText(data.dataString);
        if (hasObservers(this.clipboard)) {
            this.zone.run(() => {
                this.clipboard.emit({
                    type: operationType,
                    originalEvent: args,
                    clipboardData: data.dataString,
                    gridData: data.gridItems,
                    target: {
                        dataRowIndex: this.clipboardService.targetRowIndex,
                        colField: this.clipboardService.targetColField,
                        dataItem: clipboardData.find(item => item.dataRowIndex === this.clipboardService.targetRowIndex)?.dataItem
                    }
                });
            });
        }
        this.clipboardService.targetColField = this.clipboardService.targetRowIndex = null;
    };
    inGrid = (args) => {
        const target = document.activeElement.matches('.k-table-td') ? document.activeElement : args.target;
        const inContentArea = closest(target, node => node.parentElement?.classList.contains('k-grid-container'));
        const inHost = contains$1(this.host.wrapper.nativeElement, target);
        return target && inHost && inContentArea;
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridClipboardDirective, deps: [{ token: GridComponent }, { token: ClipboardService }, { token: i0.Renderer2 }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: GridClipboardDirective, isStandalone: true, selector: "[kendoGridClipboard]", inputs: { clipboardTarget: "clipboardTarget", clipboardSettings: "clipboardSettings" }, outputs: { clipboard: "clipboard" }, providers: [ClipboardService], exportAs: ["kendoGridClipboard"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridClipboardDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridClipboard]',
                    exportAs: 'kendoGridClipboard',
                    providers: [ClipboardService],
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: GridComponent }, { type: ClipboardService }, { type: i0.Renderer2 }, { type: i0.NgZone }]; }, propDecorators: { clipboardTarget: [{
                type: Input
            }], clipboardSettings: [{
                type: Input
            }], clipboard: [{
                type: Output
            }] } });

/**
 * Represents the `export-to-PDF` toolbar tool of the Grid.
 * You can apply this directive to any `kendo-toolbar-button` element inside a
 * ToolbarComponent used in the Grid.
 *
 * When the user clicks the toolbar button that is associated with the directive, the
 * [pdfExport]({% slug api_grid_gridcomponent %}#toc-pdfexport) event
 * fires ([see example]({% slug pdfexport_grid %})).
 *
 * @example
 * ```html-no-run
 * <kendo-grid>
 *      <kendo-toolbar>
 *         <kendo-toolbar-button text="PDF Export" kendoGridPDFTool></kendo-toolbar-button>
 *      </kendo-toolbar>
 *      <kendo-grid-pdf fileName="Grid.pdf">
 *      </kendo-grid-pdf>
 * </kendo-grid>
 * ```
 */
class PDFCommandToolbarDirective {
    pdfService;
    host;
    clickSub = new Subscription();
    constructor(pdfService, host) {
        this.pdfService = pdfService;
        this.host = host;
    }
    ngOnInit() {
        this.clickSub = this.host.click.subscribe(e => this.onClick(e));
        this.host.className = 'k-grid-pdf';
        this.host.svgIcon = filePdfIcon;
        this.host.icon = 'file-pdf';
    }
    ngOnDestroy() {
        this.clickSub.unsubscribe();
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.pdfService.exportClick.emit();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PDFCommandToolbarDirective, deps: [{ token: PDFService }, { token: i43.ToolBarButtonComponent }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: PDFCommandToolbarDirective, isStandalone: true, selector: "[kendoGridPDFTool]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PDFCommandToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridPDFTool]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: PDFService }, { type: i43.ToolBarButtonComponent }]; } });

/**
 * Represents the `export-to-Excel` toolbar tool of the Grid.
 * You can apply this directive to any `kendo-toolbar-button` element inside a
 * ToolbarComponent used in the Grid.
 *
 * When the user clicks a button associated with the directive, the
 * [excelExport]({% slug api_grid_gridcomponent %}#toc-excelexport) event
 * fires ([see example]({% slug excelexport_grid %})).
 *
 * @example
 * ```html-no-run
 * <kendo-grid>
 *      <kendo-toolbar>
 *         <kendo-toolbar-button text="Excel Export" kendoGridExcelTool></kendo-toolbar-button>
 *      </kendo-toolbar>
 *      <kendo-grid-excel fileName="Grid.xlsx">
 *      </kendo-grid-excel>
 * </kendo-grid>
 * ```
 */
class ExcelCommandToolbarDirective {
    excelService;
    host;
    clickSub = new Subscription();
    constructor(excelService, host) {
        this.excelService = excelService;
        this.host = host;
    }
    ngOnInit() {
        this.clickSub = this.host.click.subscribe(e => this.onClick(e));
        this.host.className = 'k-grid-excel';
        this.host.svgIcon = fileExcelIcon;
        this.host.icon = 'file-excel';
    }
    ngOnDestroy() {
        this.clickSub.unsubscribe();
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.excelService.exportClick.emit();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExcelCommandToolbarDirective, deps: [{ token: ExcelService }, { token: i43.ToolBarButtonComponent }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: ExcelCommandToolbarDirective, isStandalone: true, selector: "[kendoGridExcelTool]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExcelCommandToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridExcelTool]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ExcelService }, { type: i43.ToolBarButtonComponent }]; } });

/**
 * Represents the command for adding a new item to the Grid.
 * You can apply this directive to any `kendo-toolbar-button` element inside a
 * ToolbarComponent used in the Grid.
 *
 * When the user clicks the toolbar button that is associated with the directive, , the
 * [add]({% slug api_grid_gridcomponent %}#toc-add) event is triggered
 * ([see example]({% slug basics_editing_grid %})).
 *
 * @example
 * ```html-no-run
 * <kendo-grid>
 *      <kendo-toolbar>
 *         <kendo-toolbar-button text="Add new" kendoGridAddTool></kendo-toolbar-button>
 *      </kendo-toolbar>
 * </kendo-grid>
 * ```
 */
class AddCommandToolbarDirective {
    editService;
    host;
    clickSub = new Subscription();
    constructor(editService, host) {
        this.editService = editService;
        this.host = host;
    }
    ngOnInit() {
        this.clickSub = this.host.click.subscribe(e => this.onClick(e));
        this.host.className = 'k-grid-add-command';
        this.host.svgIcon = plusIcon;
        this.host.icon = 'plus';
    }
    ngOnDestroy() {
        this.clickSub.unsubscribe();
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.editService.beginAdd();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AddCommandToolbarDirective, deps: [{ token: EditService }, { token: i43.ToolBarButtonComponent }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: AddCommandToolbarDirective, isStandalone: true, selector: "[kendoGridAddTool]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AddCommandToolbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoGridAddTool]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: EditService }, { type: i43.ToolBarButtonComponent }]; } });

// DRAGGABLE COLUMN
/**
 * @hidden
 *
 * Utility array that contains all column dragging components and directives
 */
const KENDO_GRID_COLUMN_DRAGANDDROP = [
    DraggableColumnDirective,
    DropTargetDirective
];
/**
 * @hidden
 *
 * Utility array that contains the former Shared module exports
 */
const KENDO_GRID_SHARED = [
    ColumnComponent,
    ColumnGroupComponent,
    LogicalCellDirective,
    LogicalRowDirective,
    FocusableDirective,
    FooterTemplateDirective,
    ColGroupComponent,
    ResizableContainerDirective,
    TemplateContextDirective,
    FieldAccessorPipe,
    DetailTemplateDirective,
    SpanColumnComponent,
    LoadingComponent,
    GridTableDirective
];
/**
 * @hidden
 *
 * Utility array that contains the former Group module exports
 */
const KENDO_GRID_GROUP_EXPORTS = [
    GroupHeaderTemplateDirective,
    GroupHeaderColumnTemplateDirective,
    GroupFooterTemplateDirective,
    GroupHeaderComponent,
    GroupPanelComponent,
];
/**
 * @hidden
 *
 * Utility array that contains the filter operator components
 */
const KENDO_GRID_FILTER_OPERATORS = [
    FilterCellOperatorsComponent,
    ContainsFilterOperatorComponent,
    DoesNotContainFilterOperatorComponent,
    EndsWithFilterOperatorComponent,
    EqualFilterOperatorComponent,
    IsEmptyFilterOperatorComponent,
    IsNotEmptyFilterOperatorComponent,
    IsNotNullFilterOperatorComponent,
    IsNullFilterOperatorComponent,
    NotEqualFilterOperatorComponent,
    StartsWithFilterOperatorComponent,
    GreaterFilterOperatorComponent,
    GreaterOrEqualToFilterOperatorComponent,
    LessFilterOperatorComponent,
    LessOrEqualToFilterOperatorComponent,
    AfterFilterOperatorComponent,
    AfterEqFilterOperatorComponent,
    BeforeEqFilterOperatorComponent,
    BeforeFilterOperatorComponent
];
/**
 * @hidden
 *
 * Utility array that contains the former SharedFilterModule exports
 */
const KENDO_GRID_FILTER_SHARED = [
    ...KENDO_GRID_SHARED,
    ...KENDO_GRID_FILTER_OPERATORS,
    FilterInputDirective,
];
/**
 * @hidden
 *
 * Utility array that contains the former FilterMenuModule declarations
 */
const KENDO_GRID_FILTER_MENU_EXPORTS = [
    FilterMenuComponent,
    FilterMenuContainerComponent,
    FilterMenuInputWrapperComponent,
    StringFilterMenuInputComponent,
    StringFilterMenuComponent,
    FilterMenuTemplateDirective,
    NumericFilterMenuComponent,
    NumericFilterMenuInputComponent,
    DateFilterMenuInputComponent,
    DateFilterMenuComponent,
    FilterMenuHostDirective,
    BooleanFilterMenuComponent,
    FilterMenuDropDownListDirective,
    BooleanFilterRadioButtonDirective
];
/**
 * @hidden
 *
 * Utility array that contains the former FilterMenuModule exports
 */
const KENDO_GRID_FILTER_MENU = [
    ...KENDO_GRID_FILTER_SHARED,
    ...KENDO_GRID_FILTER_MENU_EXPORTS
];
/**
 * @hidden
 *
 * Utility array that contains the former RowFilterModule declarations
 */
const KENDO_GRID_FILTER_ROW_EXPORTS = [
    FilterRowComponent,
    FilterCellComponent,
    FilterCellTemplateDirective,
    StringFilterCellComponent,
    NumericFilterCellComponent,
    AutoCompleteFilterCellComponent,
    BooleanFilterCellComponent,
    FilterCellHostDirective,
    FilterCellWrapperComponent,
    DateFilterCellComponent
];
/**
 * @hidden
 *
 * Utility array that contains the former RowFilterModule exports
 */
const KENDO_GRID_FILTER_ROW = [
    ...KENDO_GRID_FILTER_ROW_EXPORTS,
    ...KENDO_GRID_FILTER_SHARED
];
/**
 * @hidden
 *
 * Utility array that contains the former ColumnMenu module declarations
 */
const KENDO_GRID_COLUMN_MENU_DECLARATIONS = [
    ColumnMenuChooserItemCheckedDirective,
    ColumnListComponent,
    ColumnChooserComponent,
    ColumnMenuChooserComponent,
    ColumnMenuFilterComponent,
    ColumnMenuItemComponent,
    ColumnMenuItemContentTemplateDirective,
    ColumnMenuSortComponent,
    ColumnMenuComponent,
    ColumnMenuLockComponent,
    ColumnMenuTemplateDirective,
    ColumnMenuContainerComponent,
    ColumnMenuItemDirective,
    ColumnMenuStickComponent,
    ColumnMenuPositionComponent,
    ColumnMenuAutoSizeColumnComponent,
    ColumnMenuAutoSizeAllColumnsComponent
];
/**
 * @hidden
 *
 * Utility array that contains the former ColumnMenu module exports
 */
const KENDO_GRID_COLUMN_MENU_EXPORTS = [
    ColumnChooserComponent,
    ColumnMenuFilterComponent,
    ColumnMenuItemComponent,
    ColumnMenuItemContentTemplateDirective,
    ColumnMenuSortComponent,
    ColumnMenuLockComponent,
    ColumnMenuStickComponent,
    ColumnMenuPositionComponent,
    ColumnMenuChooserComponent,
    ColumnMenuTemplateDirective,
    ColumnMenuContainerComponent,
    ColumnMenuItemDirective,
    ColumnMenuComponent,
    ColumnMenuAutoSizeColumnComponent,
    ColumnMenuAutoSizeAllColumnsComponent
];
/**
 * @hidden
 */
const KENDO_GRID_HEADER_EXPORTS = [
    HeaderComponent,
    HeaderTemplateDirective,
    ColumnHandleDirective,
    SelectAllCheckboxDirective
];
/**
 * @hidden
 *
 * Utility array that contains the Footer module exports
 */
const KENDO_GRID_FOOTER_EXPORTS = [FooterComponent];
/**
 * @hidden
 *
 * Utility array that contains the Body module exports
 */
const KENDO_GRID_BODY_EXPORTS = [
    CommandColumnComponent,
    CheckboxColumnComponent,
    SelectionCheckboxDirective,
    CellTemplateDirective,
    EditTemplateDirective,
    TableBodyComponent,
    NoRecordsTemplateDirective,
    CellComponent,
    EditCommandDirective,
    CancelCommandDirective,
    SaveCommandDirective,
    RemoveCommandDirective,
    AddCommandDirective,
    AddCommandToolbarDirective,
    CellLoadingTemplateDirective,
    LoadingTemplateDirective,
    RowReorderColumnComponent
];
/**
 * @hidden
 *
 * Utility array that contains the Grid module declarations
 */
const KENDO_GRID_DECLARATIONS = [
    GridComponent,
    ListComponent,
    ToolbarComponent,
    LocalizedMessagesDirective,
    CustomMessagesComponent,
    DataBindingDirective,
    ToolbarTemplateDirective,
    SelectionDirective,
    TemplateEditingDirective,
    ReactiveEditingDirective,
    InCellEditingDirective,
    ExpandDetailsDirective,
    ExpandGroupDirective,
    GroupBindingDirective,
    GridMarqueeDirective,
    GridSpacerComponent,
    GridToolbarFocusableDirective,
    StatusBarComponent,
    StatusBarTemplateDirective,
    GridClipboardDirective
];
/**
 * @hidden
 *
 * Utility array that contains the Grid module exports
 */
const KENDO_GRID_EXPORTS = [
    GridComponent,
    ToolbarTemplateDirective,
    ToolbarComponent,
    GridSpacerComponent,
    StatusBarTemplateDirective,
    DataBindingDirective,
    SelectionDirective,
    CustomMessagesComponent,
    GroupBindingDirective,
    TemplateEditingDirective,
    ReactiveEditingDirective,
    InCellEditingDirective,
    ExpandDetailsDirective,
    ExpandGroupDirective,
    GridToolbarFocusableDirective,
    ...KENDO_GRID_GROUP_EXPORTS,
    ...KENDO_GRID_SHARED,
    ...KENDO_GRID_BODY_EXPORTS,
    ...KENDO_GRID_HEADER_EXPORTS,
    ...KENDO_GRID_FILTER_ROW_EXPORTS,
    ...KENDO_GRID_FILTER_OPERATORS,
    ...KENDO_GRID_FILTER_MENU_EXPORTS,
    ...KENDO_GRID_COLUMN_MENU_EXPORTS,
    GridClipboardDirective
];
/**
 * @hidden
 *
 * Utility array that contains the ExcelExport module exports
 */
const KENDO_GRID_EXCEL_EXPORT = [
    ExcelComponent,
    ExcelCommandDirective,
    ExcelCommandToolbarDirective
];
/**
 * @hidden
 *
 * Utility array that contains the PDFModule declarations and exports
 */
const KENDO_GRID_PDF_EXPORT = [
    PDFComponent,
    PDFMarginComponent,
    PDFCommandDirective,
    PDFTemplateDirective,
    PDFCommandToolbarDirective
];
/**
 * Utility array that contains all `Grid` related components and directives
 */
const KENDO_GRID = [
    ...KENDO_GRID_EXPORTS,
    ...KENDO_GRID_EXCEL_EXPORT,
    ...KENDO_GRID_PDF_EXPORT
];

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])
 * definition for the Grid component.
 *
 * @example
 *
 * ```ts
 * import { NgModule } from '@angular/core';
 * import { GridModule } from '@progress/kendo-angular-grid';
 * import { BrowserModule } from "@angular/platform-browser";
 * import { AppComponent } from './app.component';
 *
 * @NgModule({
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, GridModule],
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * ```
 */
class GridModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: GridModule, imports: [GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective, GroupFooterTemplateDirective, GroupHeaderComponent, GroupPanelComponent, ColumnComponent, ColumnGroupComponent, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective, ColGroupComponent, ResizableContainerDirective, i1$3.TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective, CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective, EditTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, AddCommandToolbarDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, RowReorderColumnComponent, HeaderComponent, HeaderTemplateDirective, ColumnHandleDirective, SelectAllCheckboxDirective, FooterComponent, i42.CustomMessagesComponent, i42.PagerFocusableDirective, i42.PagerInfoComponent, i42.PagerInputComponent, i42.PagerNextButtonsComponent, i42.PagerNumericButtonsComponent, i42.PagerPageSizesComponent, i42.PagerPrevButtonsComponent, i42.PagerTemplateDirective, i42.PagerComponent, i42.PagerSpacerComponent, i43.ToolBarComponent, i43.ToolbarCustomMessagesComponent, i43.ToolBarButtonComponent, i43.ToolBarButtonGroupComponent, i43.ToolBarDropDownButtonComponent, i43.ToolBarSeparatorComponent, i43.ToolBarSpacerComponent, i43.ToolBarSplitButtonComponent, i43.ToolBarToolComponent, FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent, ColumnComponent, ColumnGroupComponent, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective, ColGroupComponent, ResizableContainerDirective, i1$3.TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective, FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, FilterInputDirective, ColumnComponent, ColumnGroupComponent, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective, ColGroupComponent, ResizableContainerDirective, i1$3.TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective, FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, FilterInputDirective, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective, ColumnMenuChooserItemCheckedDirective, ColumnListComponent, ColumnChooserComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, GridComponent, ListComponent, ToolbarComponent, LocalizedMessagesDirective, CustomMessagesComponent, DataBindingDirective, ToolbarTemplateDirective, SelectionDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GroupBindingDirective, GridMarqueeDirective, GridSpacerComponent, GridToolbarFocusableDirective, StatusBarComponent, StatusBarTemplateDirective, GridClipboardDirective, i43.ToolBarComponent, i43.ToolbarCustomMessagesComponent, i43.ToolBarButtonComponent, i43.ToolBarButtonGroupComponent, i43.ToolBarDropDownButtonComponent, i43.ToolBarSeparatorComponent, i43.ToolBarSpacerComponent, i43.ToolBarSplitButtonComponent, i43.ToolBarToolComponent, TableDirective], exports: [GridComponent, ToolbarTemplateDirective, ToolbarComponent, GridSpacerComponent, StatusBarTemplateDirective, DataBindingDirective, SelectionDirective, CustomMessagesComponent, GroupBindingDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GridToolbarFocusableDirective, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective, GroupFooterTemplateDirective, GroupHeaderComponent, GroupPanelComponent, ColumnComponent, ColumnGroupComponent, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective, ColGroupComponent, ResizableContainerDirective, i1$3.TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective, CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective, EditTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, AddCommandToolbarDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, RowReorderColumnComponent, HeaderComponent, HeaderTemplateDirective, ColumnHandleDirective, SelectAllCheckboxDirective, FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent, FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective, ColumnChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, GridClipboardDirective, i43.ToolBarComponent, i43.ToolbarCustomMessagesComponent, i43.ToolBarButtonComponent, i43.ToolBarButtonGroupComponent, i43.ToolBarDropDownButtonComponent, i43.ToolBarSeparatorComponent, i43.ToolBarSpacerComponent, i43.ToolBarSplitButtonComponent, i43.ToolBarToolComponent, i42.CustomMessagesComponent, i42.PagerFocusableDirective, i42.PagerInfoComponent, i42.PagerInputComponent, i42.PagerNextButtonsComponent, i42.PagerNumericButtonsComponent, i42.PagerPageSizesComponent, i42.PagerPrevButtonsComponent, i42.PagerTemplateDirective, i42.PagerComponent, i42.PagerSpacerComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridModule, providers: [
            PopupService,
            ResizeBatchService,
            IconsService,
            DialogContainerService,
            DialogService,
            WindowService,
            WindowContainerService,
            CalendarDOMService,
            CenturyViewService,
            DecadeViewService,
            MonthViewService,
            YearViewService,
            NavigationService$1
        ], imports: [GroupHeaderComponent, GroupPanelComponent, TableBodyComponent, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, HeaderComponent, i42.CustomMessagesComponent, i42.PagerInfoComponent, i42.PagerInputComponent, i42.PagerNextButtonsComponent, i42.PagerNumericButtonsComponent, i42.PagerPageSizesComponent, i42.PagerPrevButtonsComponent, i42.PagerComponent, i42.PagerSpacerComponent, i43.ToolBarComponent, i43.ToolbarCustomMessagesComponent, i43.ToolBarButtonComponent, i43.ToolBarButtonGroupComponent, i43.ToolBarDropDownButtonComponent, i43.ToolBarSeparatorComponent, i43.ToolBarSpacerComponent, i43.ToolBarSplitButtonComponent, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellWrapperComponent, DateFilterCellComponent, FilterCellOperatorsComponent, FilterCellOperatorsComponent, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, BooleanFilterMenuComponent, ColumnListComponent, ColumnChooserComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, GridComponent, ListComponent, i43.ToolBarComponent, i43.ToolbarCustomMessagesComponent, i43.ToolBarButtonComponent, i43.ToolBarButtonGroupComponent, i43.ToolBarDropDownButtonComponent, i43.ToolBarSeparatorComponent, i43.ToolBarSpacerComponent, i43.ToolBarSplitButtonComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GridModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_GRID_EXPORTS, ...KENDO_TOOLBAR, ...KENDO_PAGER],
                    imports: [
                        ...KENDO_GRID_GROUP_EXPORTS,
                        ...KENDO_GRID_SHARED,
                        ...KENDO_GRID_BODY_EXPORTS,
                        ...KENDO_GRID_HEADER_EXPORTS,
                        ...KENDO_GRID_FOOTER_EXPORTS,
                        ...KENDO_PAGER,
                        ...KENDO_TOOLBAR,
                        ...KENDO_GRID_FILTER_ROW,
                        ...KENDO_GRID_FILTER_MENU,
                        ...KENDO_GRID_COLUMN_MENU_DECLARATIONS,
                        ...KENDO_GRID_DECLARATIONS,
                        ...KENDO_TOOLBAR,
                        TableDirective
                    ],
                    providers: [
                        PopupService,
                        ResizeBatchService,
                        IconsService,
                        DialogContainerService,
                        DialogService,
                        WindowService,
                        WindowContainerService,
                        CalendarDOMService,
                        CenturyViewService,
                        DecadeViewService,
                        MonthViewService,
                        YearViewService,
                        NavigationService$1
                    ]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])
 * definition for the Grid PDF component.
 *
 * @example
 *
 * ```ts
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from "@angular/platform-browser";
 * import { GridModule, PDFModule } from '@progress/kendo-angular-grid';
 * import { AppComponent } from './app.component';
 *
 * @NgModule({
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, GridModule, PDFModule],
 *     bootstrap:    [AppComponent]
 * })
 *
 * export class AppModule {}
 *
 * ```
 */
class PDFModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PDFModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: PDFModule, imports: [i1$1.IconComponent, i1$1.SVGIconComponent, PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective, PDFCommandToolbarDirective], exports: [PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective, PDFCommandToolbarDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PDFModule, providers: [IconsService], imports: [KENDO_ICONS, PDFCommandDirective] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PDFModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...KENDO_ICONS, ...KENDO_GRID_PDF_EXPORT],
                    exports: [...KENDO_GRID_PDF_EXPORT],
                    providers: [IconsService]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])
 * definition for the Excel component of the Grid.
 *
 * @example
 *
 * ```ts
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from "@angular/platform-browser";
 * import { GridModule, ExcelModule } from '@progress/kendo-angular-grid';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, GridModule, ExcelModule],
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * ```
 */
class ExcelModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExcelModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: ExcelModule, imports: [i1$1.IconComponent, i1$1.SVGIconComponent, ExcelComponent, ExcelCommandDirective, ExcelCommandToolbarDirective, i5$1.ExcelExportComponent, i5$1.ColumnComponent, i5$1.ColumnGroupComponent, i5$1.FooterTemplateDirective, i5$1.GroupFooterTemplateDirective, i5$1.GroupHeaderColumnTemplateDirective, i5$1.GroupHeaderTemplateDirective], exports: [ExcelComponent, ExcelCommandDirective, ExcelCommandToolbarDirective, i5$1.ExcelExportComponent, i5$1.ColumnComponent, i5$1.ColumnGroupComponent, i5$1.FooterTemplateDirective, i5$1.GroupFooterTemplateDirective, i5$1.GroupHeaderColumnTemplateDirective, i5$1.GroupHeaderTemplateDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExcelModule, providers: [IconsService], imports: [KENDO_ICONS, ExcelCommandDirective, i5$1.ExcelExportComponent, i5$1.ColumnComponent, i5$1.ColumnGroupComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExcelModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...KENDO_ICONS, ...KENDO_GRID_EXCEL_EXPORT, ...KENDO_EXCELEXPORT],
                    exports: [...KENDO_GRID_EXCEL_EXPORT, ...KENDO_EXCELEXPORT],
                    providers: [IconsService]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { AddCommandDirective, AddCommandToolbarDirective, AfterEqFilterOperatorComponent, AfterFilterOperatorComponent, AutoCompleteFilterCellComponent, BaseFilterCellComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, BooleanFilterCellComponent, BooleanFilterComponent, BooleanFilterMenuComponent, BooleanFilterRadioButtonDirective, BrowserSupportService, CELL_CONTEXT, CancelCommandDirective, CellCloseEvent, CellComponent, CellLoadingTemplateDirective, CellSelectionAggregateService, CellSelectionService, CellTemplateDirective, ChangeNotificationService, CheckboxColumnComponent, ColGroupComponent, ColumnBase, ColumnChooserComponent, ColumnComponent, ColumnGroupComponent, ColumnHandleDirective, ColumnInfoService, ColumnListComponent, ColumnLockedChangeEvent, ColumnMenuAutoSizeAllColumnsComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuChooserComponent, ColumnMenuComponent, ColumnMenuContainerComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuItemDirective, ColumnMenuLockComponent, ColumnMenuPositionComponent, ColumnMenuService, ColumnMenuSortComponent, ColumnMenuStickComponent, ColumnMenuTemplateDirective, ColumnReorderEvent, ColumnReorderService, ColumnResizingService, ColumnStickyChangeEvent, ColumnVisibilityChangeEvent, ColumnsContainer, CommandColumnComponent, ContainsFilterOperatorComponent, ContextService, CustomMessagesComponent, DEFAULT_SCROLLER_FACTORY, DataBindingDirective, DateFilterCellComponent, DateFilterComponent, DateFilterMenuComponent, DateFilterMenuInputComponent, DetailCollapseEvent, DetailExpandEvent, DetailTemplateDirective, DetailsService, DoesNotContainFilterOperatorComponent, DomEventsService, DragAndDropService, DragHintService, DropCueService, EditCommandDirective, EditTemplateDirective, EditingDirectiveBase, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, ExcelCommandDirective, ExcelCommandToolbarDirective, ExcelComponent, ExcelExportEvent, ExcelModule, ExcelService, ExpandDetailsDirective, ExpandGroupDirective, FieldAccessorPipe, FilterCellComponent, FilterCellHostDirective, FilterCellOperatorsComponent, FilterCellTemplateDirective, FilterCellWrapperComponent, FilterInputDirective, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuDropDownListDirective, FilterMenuHostDirective, FilterMenuInputWrapperComponent, FilterMenuTemplateDirective, FilterRowComponent, FilterService, FocusRoot, FocusableDirective, FooterComponent, FooterTemplateDirective, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, GridClipboardDirective, GridComponent, GridModule, GridSpacerComponent, GridTableDirective, GridToolbarFocusableDirective, GridToolbarNavigationService, GroupBindingDirective, GroupFooterTemplateDirective, GroupHeaderColumnTemplateDirective, GroupHeaderComponent, GroupHeaderTemplateDirective, GroupInfoService, GroupPanelComponent, GroupsService, HeaderComponent, HeaderTemplateDirective, IdService, InCellEditingDirective, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, KENDO_GRID, KENDO_GRID_BODY_EXPORTS, KENDO_GRID_COLUMN_DRAGANDDROP, KENDO_GRID_COLUMN_MENU_DECLARATIONS, KENDO_GRID_COLUMN_MENU_EXPORTS, KENDO_GRID_DECLARATIONS, KENDO_GRID_EXCEL_EXPORT, KENDO_GRID_EXPORTS, KENDO_GRID_FILTER_MENU, KENDO_GRID_FILTER_MENU_EXPORTS, KENDO_GRID_FILTER_OPERATORS, KENDO_GRID_FILTER_ROW, KENDO_GRID_FILTER_ROW_EXPORTS, KENDO_GRID_FILTER_SHARED, KENDO_GRID_FOOTER_EXPORTS, KENDO_GRID_GROUP_EXPORTS, KENDO_GRID_HEADER_EXPORTS, KENDO_GRID_PDF_EXPORT, KENDO_GRID_SHARED, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, ListComponent, LoadingComponent, LoadingTemplateDirective, LocalDataChangesService, LogicalCellDirective, LogicalRowDirective, MenuTabbingService, NavigationService, NoRecordsTemplateDirective, NotEqualFilterOperatorComponent, NumericFilterCellComponent, NumericFilterComponent, NumericFilterMenuComponent, NumericFilterMenuInputComponent, PDFCommandDirective, PDFCommandToolbarDirective, PDFComponent, PDFMarginComponent, PDFModule, PDFService, PDFTemplateDirective, PopupCloseEvent, ReactiveEditingDirective, RemoveCommandDirective, ResizableContainerDirective, ResizeService, ResponsiveService, RowEditingDirectiveBase, RowReorderColumnComponent, RowReorderService, SaveCommandDirective, ScrollRequestService, ScrollSyncService, SelectAllCheckboxDirective, SelectionCheckboxDirective, SelectionDirective, SelectionService, SinglePopupService, SizingOptionsService, Skip, SortService, SpanColumnComponent, StartsWithFilterOperatorComponent, StatusBarTemplateDirective, StringFilterCellComponent, StringFilterComponent, StringFilterMenuComponent, StringFilterMenuInputComponent, SuspendService, TableBodyComponent, TableDirective, TemplateEditingDirective, ToolbarComponent, ToolbarTemplateDirective, count, defaultTrackBy, hasFilterMenu, hasFilterRow, isFilterable, slice };

