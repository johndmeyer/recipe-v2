/**-----------------------------------------------------------------------------------------
* Copyright © 2024 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
/* eslint-disable no-case-declarations */
import { Component, HostBinding, ViewChild, TemplateRef, ElementRef, QueryList, ContentChildren, Input, HostListener, Output, EventEmitter, ViewContainerRef, NgZone, Renderer2, ChangeDetectorRef } from '@angular/core';
import { PopupService } from '@progress/kendo-angular-popup';
import { guid, ResizeSensorComponent } from '@progress/kendo-angular-common';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { validatePackage } from '@progress/kendo-licensing';
import { packageMetadata } from './package-metadata';
import { RefreshService } from './refresh.service';
import { NavigationService } from './navigation.service';
import { ToolBarToolComponent } from './tools/toolbar-tool.component';
import { innerWidth, closest, isPresent, getStylingClasses, SIZES } from './util';
import { Keys } from '@progress/kendo-angular-common';
import { PreventableEvent } from './common/preventable-event';
import { ToolBarRendererComponent } from './renderer.component';
import { Subscription, fromEvent, Subject, merge } from 'rxjs';
import { take, takeUntil } from 'rxjs/operators';
import { filter } from 'rxjs/operators';
import { isDocumentAvailable } from '@progress/kendo-angular-common';
import { moreVerticalIcon } from '@progress/kendo-svg-icons';
import { ButtonComponent } from '@progress/kendo-angular-buttons';
import { NgFor, NgIf, NgClass, NgTemplateOutlet } from '@angular/common';
import { LocalizedToolbarMessagesDirective } from './localization/localized-toolbar-messages.directive';
import { ToolbarToolsService } from './tools/tools.service';
import * as i0 from "@angular/core";
import * as i1 from "@progress/kendo-angular-l10n";
import * as i2 from "@progress/kendo-angular-popup";
import * as i3 from "./refresh.service";
import * as i4 from "./navigation.service";
import * as i5 from "./tools/tools.service";
const DEFAULT_SIZE = 'medium';
const DEFAULT_FILL_MODE = 'solid';
const immediateResizeThreshold = 300;
const getInitialPopupSettings = (isRtl) => ({
    animate: true,
    anchorAlign: { horizontal: isRtl ? 'left' : 'right', vertical: 'bottom' },
    popupAlign: { horizontal: isRtl ? 'left' : 'right', vertical: 'top' }
});
/**
 * Represents the [Kendo UI ToolBar component for Angular]({% slug overview_toolbar %}).
 */
export class ToolBarComponent {
    localization;
    popupService;
    refreshService;
    navigationService;
    element;
    zone;
    renderer;
    _cdr;
    toolsService;
    get overflowClass() {
        return `k-button-${SIZES[this.size]}`;
    }
    /**
     * Hides the overflowing tools in a popup.
     */
    overflow = false;
    /**
     * @hidden
     */
    set resizable(value) {
        this.overflow = value;
    }
    get resizable() {
        return this.overflow;
    }
    /**
     * Configures the popup of the ToolBar overflow button ([see example]({% slug responsive_toolbar %}#toc-popup-customization)).
     *
     * The available options are:
     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
     */
    set popupSettings(settings) {
        this._popupSettings = Object.assign({}, getInitialPopupSettings(this.localization.rtl), settings);
    }
    get popupSettings() {
        return this._popupSettings || getInitialPopupSettings(this.localization.rtl);
    }
    /**
     * The fillMode property specifies the background and border styles of the Toolbar
     * ([see example](slug:appearance_toolbar#toc-fill-mode)).
     *
     * @default 'solid'
     */
    set fillMode(fillMode) {
        const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;
        this.handleClasses(newFillMode, 'fillMode');
        this._fillMode = newFillMode;
    }
    get fillMode() {
        return this._fillMode;
    }
    /**
     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the ToolBar.
     */
    tabindex = 0;
    /**
     * Specifies the padding of all Toolbar elements.
     *
     * The possible values are:
     * * `small`
     * * `medium` (default)
     * * `large`
     * * `none`
     */
    set size(size) {
        const newSize = size ? size : DEFAULT_SIZE;
        this.handleClasses(newSize, 'size');
        this._size = newSize;
    }
    get size() {
        return this._size;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * Fires when the overflow popup of the ToolBar is opened.
     */
    open = new EventEmitter();
    /**
     * Fires when the overflow popup of the ToolBar is closed.
     */
    close = new EventEmitter();
    allTools;
    overflowButton;
    popupTemplate;
    resizeSensor;
    container;
    popupRef;
    direction;
    get appendTo() {
        const { appendTo } = this.popupSettings;
        if (!appendTo || appendTo === 'root') {
            return undefined;
        }
        return appendTo === 'component' ? this.container : appendTo;
    }
    set popupOpen(open) {
        if (this.popupOpen === open) {
            return;
        }
        const eventArgs = new PreventableEvent();
        if (open) {
            this.open.emit(eventArgs);
        }
        else {
            this.close.emit(eventArgs);
        }
        if (eventArgs.isDefaultPrevented()) {
            return;
        }
        this.toggle(open);
    }
    get popupOpen() {
        return this._open;
    }
    hostClass = true;
    _popupSettings;
    cachedOverflowAnchorWidth;
    _open;
    toolbarKeydownListener;
    overflowKeydownListener;
    cancelRenderedToolsSubscription$ = new Subject();
    cachedGap;
    _size = DEFAULT_SIZE;
    _fillMode = DEFAULT_FILL_MODE;
    overflowButtonClickedTime = null;
    subscriptions = new Subscription();
    popupSubs = new Subscription();
    /**
     * @hidden
     */
    onFocus(ev) {
        this.navigationService.resetNavigation();
        this.navigationService.focusFirst(ev);
        // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously
        this.element.nativeElement.setAttribute('tabindex', '-1');
    }
    /**
     * @hidden
     */
    onFocusOut(event) {
        // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously
        if (closest(event.relatedTarget, (el) => el === this.element.nativeElement)) {
            this.element.nativeElement.setAttribute('tabindex', '-1');
            return;
        }
        this.element.nativeElement.setAttribute('tabindex', this.tabindex.toString());
    }
    role = 'toolbar';
    get getDir() {
        return this.direction;
    }
    get resizableClass() {
        return this.overflow;
    }
    moreVerticalIcon = moreVerticalIcon;
    constructor(localization, popupService, refreshService, navigationService, 
    // Needs to be public as it is being accessed in the Editor component
    element, zone, renderer, _cdr, toolsService) {
        this.localization = localization;
        this.popupService = popupService;
        this.refreshService = refreshService;
        this.navigationService = navigationService;
        this.element = element;
        this.zone = zone;
        this.renderer = renderer;
        this._cdr = _cdr;
        this.toolsService = toolsService;
        validatePackage(packageMetadata);
        this.direction = localization.rtl ? 'rtl' : 'ltr';
    }
    ngAfterContentInit() {
        this.toolsService.allTools = this.allTools.toArray();
        this.subscriptions.add(this.allTools.changes.subscribe(changes => {
            this.toolsService.allTools = this.allTools.toArray();
            this.zone.onStable.pipe(take(1)).subscribe(() => this.onResize());
        }));
    }
    ngAfterViewInit() {
        this.toolsService.renderedToolsChange.next(this.toolsService.renderedTools);
        this.toolsService.overflowToolsChange.next(this.toolsService.overflowTools);
        const element = this.element.nativeElement;
        if (!element.getAttribute('tabindex')) {
            this.element.nativeElement.setAttribute('tabindex', '0');
        }
        this.zone.runOutsideAngular(() => {
            this.toolbarKeydownListener = this.renderer.listen(this.element.nativeElement, 'keydown', (ev) => {
                switch (ev.keyCode) {
                    case Keys.ArrowLeft:
                        this.zone.run(() => {
                            ev.preventDefault();
                            if (this.direction === 'ltr') {
                                this.navigationService.focusPrev(ev);
                            }
                            else {
                                this.navigationService.focusNext(ev);
                            }
                            // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously
                            this.element.nativeElement.setAttribute('tabindex', '-1');
                        });
                        break;
                    case Keys.ArrowRight:
                        this.zone.run(() => {
                            ev.preventDefault();
                            if (this.direction === 'ltr') {
                                this.navigationService.focusNext(ev);
                            }
                            else {
                                this.navigationService.focusPrev(ev);
                            }
                            // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously
                            this.element.nativeElement.setAttribute('tabindex', '-1');
                        });
                        break;
                    case Keys.Tab:
                        this.zone.run(() => this.navigationService.resetNavigation());
                        break;
                    case Keys.Escape:
                        this.zone.run(() => this.toggle(false));
                        break;
                    case Keys.Home:
                        this.zone.run(() => this.navigationService.focusFirst(ev));
                        break;
                    case Keys.End:
                        this.zone.run(() => this.navigationService.focusLast(ev));
                        break;
                    default:
                        break;
                }
            });
        });
        if (this.overflow) {
            this.subscriptions.add(merge(this.resizeSensor.resize, this.toolsService.renderedToolsChange).subscribe(() => this.onResize()));
            this.navigationService.overflowButton = this.overflowButton;
            // because of https://github.com/telerik/kendo-angular-buttons/pull/276
            // button icons are not rendered until onResize() is called
            this.zone.runOutsideAngular(() => {
                setTimeout(() => {
                    this.zone.run(() => {
                        this.onResize();
                    });
                });
            });
        }
        this.navigationService.setRenderedTools(this.toolsService.renderedTools);
        const stylingOptions = ['size', 'fillMode'];
        stylingOptions.forEach(option => {
            this.handleClasses(this[option], option);
        });
    }
    ngOnInit() {
        this.subscriptions.add(this.localization.changes.subscribe(({ rtl }) => (this.direction = rtl ? 'rtl' : 'ltr')));
        this.zone.onStable.pipe(take(1)).subscribe(() => this.onResize());
        if (isDocumentAvailable()) {
            this.zone.runOutsideAngular(() => this.subscriptions.add(fromEvent(document, 'click')
                .pipe(filter(() => !!this.popupRef), filter((ev) => !this.popupRef.popup.instance.container.nativeElement.contains(ev.target)), filter((ev) => !this.overflowButton.nativeElement.contains(ev.target)))
                .subscribe(() => {
                this.zone.run(() => {
                    this.popupOpen = false;
                });
            })));
        }
    }
    ngOnChanges(changes) {
        if (changes['tabindex']) {
            // prevents ExpressionChangedAfterItHasBeenCheckedError when tools with popup are opened/closed asynchronously
            this.element.nativeElement.setAttribute('tabindex', changes['tabindex'].currentValue.toString());
        }
    }
    ngOnDestroy() {
        this.destroyPopup();
        if (this.toolbarKeydownListener) {
            this.toolbarKeydownListener();
        }
        this.cancelRenderedToolsSubscription$.next();
        this.subscriptions.unsubscribe();
    }
    /**
     * @hidden
     */
    get moreToolsTitle() {
        return this.localization.get('moreToolsTitle');
    }
    /**
     * @hidden
     */
    get cdr() {
        return this._cdr;
    }
    /**
     * @hidden
     */
    onRendererClick(data) {
        this.navigationService.click(data);
        this.element.nativeElement.setAttribute('tabindex', '-1');
    }
    /**
     * @hidden
     */
    showPopup() {
        this.popupOpen = !this.popupOpen;
        this.navigationService.click({ context: undefined, event: undefined });
        this.overflowButtonClickedTime = Date.now();
    }
    /**
     * Toggles the visibility of the overflow popup.
     */
    toggle(popupOpen) {
        this._open = popupOpen !== undefined ? popupOpen : !this.popupOpen;
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
        if (this.popupOpen) {
            this.popupRef = this.popupService.open({
                anchor: this.overflowButton,
                anchorAlign: this.popupSettings.anchorAlign,
                popupAlign: this.popupSettings.popupAlign,
                content: this.popupTemplate,
                appendTo: this.appendTo,
                animate: this.popupSettings.animate,
                popupClass: this.normalizePopupClasses(this.popupSettings.popupClass),
                positionMode: 'absolute'
            });
            this.setPopupContentDimensions();
            this.popupSubs.add(this.popupRef.popupOpen.subscribe(this.onPopupOpen.bind(this)));
            this.popupSubs.add(this.popupRef.popupClose.subscribe(this.onPopupClose.bind(this)));
        }
    }
    /**
     * @hidden
     */
    onResize() {
        if (isDocumentAvailable()) {
            const containerWidth = innerWidth(this.element.nativeElement) - this.overflowAnchorWidth;
            this.shrink(containerWidth, this.childrenWidth);
            this.stretch(containerWidth, this.childrenWidth);
            this.displayAnchor();
            this.resizeSensor?.acceptSize();
            const isImmediateResize = (Date.now() - this.overflowButtonClickedTime) < immediateResizeThreshold;
            if (this.popupOpen && !isImmediateResize) {
                this.toggle();
            }
        }
    }
    /**
     * @hidden
     */
    onPopupOpen() {
        this.zone.runOutsideAngular(() => {
            this.overflowKeydownListener = this.renderer.listen(this.popupRef.popupElement, 'keydown', (ev) => {
                switch (ev.keyCode) {
                    case Keys.ArrowUp:
                        this.zone.run(() => {
                            ev.preventDefault();
                            this.navigationService.focusPrev(ev);
                        });
                        break;
                    case Keys.ArrowDown:
                        this.zone.run(() => {
                            ev.preventDefault();
                            this.navigationService.focusNext(ev);
                        });
                        break;
                    case Keys.Escape:
                        this.zone.run(() => this.toggle(false));
                        const eventArgs = new PreventableEvent();
                        this.close.emit(eventArgs);
                        break;
                    case Keys.Tab:
                        this.zone.run(() => {
                            this.toggle(false);
                            this.navigationService.resetNavigation();
                        });
                        break;
                    case Keys.Enter:
                    case Keys.Space:
                        this.zone.run(() => {
                            if (ev.target.closest('.k-menu-item')) {
                                ev.preventDefault();
                                ev.target.click();
                                ev.target.focus();
                            }
                        });
                        break;
                    default:
                        break;
                }
            });
        });
        this.cancelRenderedToolsSubscription$.next();
        this.navigationService.setRenderedTools(this.toolsService.overflowTools);
        this.navigationService.moveFocusToPopup();
        this.toolsService.overflowToolsChange
            .pipe(takeUntil(this.cancelRenderedToolsSubscription$))
            .subscribe((rts) => this.navigationService.setRenderedTools(rts));
        this.renderer.setAttribute(this.overflowButton.nativeElement, 'aria-controls', this.popupId);
    }
    /**
     * @hidden
     */
    onPopupClose() {
        this.cancelRenderedToolsSubscription$.next();
        this.navigationService.setRenderedTools(this.toolsService.renderedTools);
        this.toolsService.renderedToolsChange
            .pipe(takeUntil(this.cancelRenderedToolsSubscription$))
            .subscribe((rts) => this.navigationService.setRenderedTools(rts));
        this.navigationService.moveFocusToToolBar();
        if (this.overflowKeydownListener) {
            this.overflowKeydownListener();
        }
        this.renderer.removeAttribute(this.overflowButton.nativeElement, 'aria-controls');
    }
    /**
     * @hidden
     */
    overflowBtnId = guid();
    /**
     * @hidden
     */
    popupId = guid();
    displayAnchor() {
        const visibility = this.allTools.filter(t => t.overflows && t.responsive).length > 0 ? 'visible' : 'hidden';
        this.overflowButton && this.renderer.setStyle(this.overflowButton.nativeElement, 'visibility', visibility);
    }
    get popupWidth() {
        if (!this.popupSettings || !this.popupSettings.width) {
            return 'auto';
        }
        return isNaN(this.popupSettings.width) ? this.popupSettings.width : `${this.popupSettings.width}px`;
    }
    get popupHeight() {
        if (!this.popupSettings || !this.popupSettings.height) {
            return;
        }
        return isNaN(this.popupSettings.height) ? this.popupSettings.height : `${this.popupSettings.height}px`;
    }
    get overflowAnchorWidth() {
        if (!this.overflow) {
            return 0;
        }
        if (!this.cachedOverflowAnchorWidth) {
            this.cachedOverflowAnchorWidth = this.overflowButton.nativeElement.offsetWidth;
        }
        return this.cachedOverflowAnchorWidth;
    }
    get gap() {
        if (isPresent(this.cachedGap)) {
            return this.cachedGap;
        }
        const computedGap = getComputedStyle(this.element.nativeElement).gap;
        this.cachedGap = isPresent(computedGap) ? parseInt(computedGap, 10) : 0;
        return this.cachedGap;
    }
    get childrenWidth() {
        const width = this.toolsService.renderedTools.reduce((totalWidth, tool) => tool.width + totalWidth + (tool.isDisplayed() ? this.gap : 0), 0);
        return Math.ceil(width);
    }
    get visibleTools() {
        return this.allTools.filter((tool) => {
            return tool.overflows === false;
        });
    }
    get overflowTools() {
        return this.allTools.filter((tool) => {
            return tool.overflows === true;
        });
    }
    shrink(containerWidth, childrenWidth) {
        let width;
        if (containerWidth < childrenWidth) {
            for (let i = this.visibleTools.length - 1; i >= 0; i--) {
                if (containerWidth > childrenWidth) {
                    break;
                }
                else {
                    width = this.hideLastVisibleTool();
                    childrenWidth -= width;
                }
            }
        }
    }
    stretch(containerWidth, childrenWidth) {
        let width;
        if (containerWidth > childrenWidth) {
            for (let i = this.overflowTools.length - 1; i >= 0; i--) {
                width = this.showFirstHiddenTool(containerWidth, childrenWidth);
                if (width) {
                    childrenWidth += width + this.gap;
                }
                else {
                    break;
                }
            }
        }
    }
    hideLastVisibleTool() {
        const tool = this.visibleTools[this.visibleTools.length - 1];
        if (!tool) {
            return null;
        }
        const renderedElement = this.toolsService.renderedTools.find((r) => {
            return r.tool === tool;
        });
        const width = renderedElement.width;
        tool.overflows = this.overflow;
        this.refreshService.refresh(tool);
        return width;
    }
    showFirstHiddenTool(containerWidth, childrenWidth) {
        const tool = this.overflowTools[0];
        if (!tool) {
            return null;
        }
        const renderedElement = this.toolsService.renderedTools.find((r) => r.tool === tool);
        tool.overflows = false;
        tool.visibility = 'hidden';
        this.refreshService.refresh(tool);
        if (containerWidth > childrenWidth + renderedElement.width) {
            tool.visibility = 'visible';
        }
        else {
            tool.overflows = true;
        }
        this.refreshService.refresh(tool);
        return renderedElement.width; // returns 0 if `overflows` is true
    }
    setPopupContentDimensions() {
        const popupContentContainer = this.popupRef.popup.instance.contentContainer.nativeElement;
        popupContentContainer.style.width = this.popupWidth;
        popupContentContainer.style.height = this.popupHeight;
        popupContentContainer.style.overflow = 'auto';
    }
    destroyPopup() {
        if (this.popupRef) {
            this.popupSubs.unsubscribe();
            this.popupRef.close();
            this.popupRef = null;
        }
    }
    handleClasses(value, input) {
        const elem = this.element.nativeElement;
        const classes = getStylingClasses('toolbar', input, this[input], value);
        if (classes.toRemove) {
            this.renderer.removeClass(elem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(elem, classes.toAdd);
        }
    }
    normalizePopupClasses(classList) {
        let classes = ['k-menu-popup', 'k-toolbar-popup'];
        if (!classList) {
            return classes;
        }
        if (typeof classList === 'string') {
            classes.push(...classList.split(' '));
        }
        else if (Array.isArray(classList)) {
            classes = [...classes, ...classList];
        }
        else {
            for (const cl in classList) {
                classes.push(classList[cl]);
            }
        }
        return classes;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ToolBarComponent, deps: [{ token: i1.LocalizationService }, { token: i2.PopupService }, { token: i3.RefreshService }, { token: i4.NavigationService }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: i5.ToolbarToolsService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ToolBarComponent, isStandalone: true, selector: "kendo-toolbar", inputs: { overflow: "overflow", resizable: "resizable", popupSettings: "popupSettings", fillMode: "fillMode", tabindex: "tabindex", size: "size", tabIndex: "tabIndex" }, outputs: { open: "open", close: "close" }, host: { listeners: { "focus": "onFocus($event)", "focusout": "onFocusOut($event)" }, properties: { "class.k-toolbar": "this.hostClass", "attr.role": "this.role", "attr.dir": "this.getDir", "class.k-toolbar-resizable": "this.resizableClass" } }, providers: [
            RefreshService,
            NavigationService,
            LocalizationService,
            ToolbarToolsService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.toolbar'
            }
        ], queries: [{ propertyName: "allTools", predicate: ToolBarToolComponent }], viewQueries: [{ propertyName: "overflowButton", first: true, predicate: ["overflowButton"], descendants: true, read: ElementRef }, { propertyName: "popupTemplate", first: true, predicate: ["popupTemplate"], descendants: true, static: true }, { propertyName: "resizeSensor", first: true, predicate: ["resizeSensor"], descendants: true }, { propertyName: "container", first: true, predicate: ["container"], descendants: true, read: ViewContainerRef, static: true }], exportAs: ["kendoToolBar"], usesOnChanges: true, ngImport: i0, template: `
        <ng-container kendoToolbarLocalizedMessages
        i18n-moreToolsTitle="kendo.toolbar.moreToolsTitle|The title of the **more tools** button in a responsive ToolBar"
        moreToolsTitle="More tools"
        >
        </ng-container>
        <ng-container *ngFor="let tool of allTools; let index = index"
            kendoToolbarRenderer
            [tool]="tool"
            location="toolbar"
            [resizable]="overflow"
            (rendererClick)="onRendererClick($event)"
            [ngTemplateOutlet]="tool.isBuiltInTool ? tool.toolbarTemplate : wrapper">
            <ng-template #wrapper>
                <div class="k-toolbar-item">
                    <ng-container [ngTemplateOutlet]="tool.toolbarTemplate"></ng-container>
                </div>
            </ng-template>
        </ng-container>
        <button
            kendoButton
            fillMode="flat"
            #overflowButton
            type="button"
            icon="more-vertical"
            [svgIcon]="moreVerticalIcon"
            tabindex="-1"
            [title]="moreToolsTitle"
            [attr.aria-label]="moreToolsTitle"
            [attr.aria-expanded]="popupOpen"
            [id]="overflowBtnId"
            aria-haspopup="menu"
            *ngIf="overflow"
            [style.visibility]="'hidden'"
            [style.position]="'relative'"
            [style.margin-inline-start]="'auto'"
            class="k-toolbar-overflow-button"
            [ngClass]="overflowClass"
            (click)="showPopup()"
        >
        </button>
        <ng-template #popupTemplate>
            <div
                class="k-menu-group k-menu-group-md"
                role="menu"
                [id]="popupId"
                [attr.aria-labelledby]="overflowBtnId">
                <ng-container *ngFor="let tool of overflowTools; let index = index">
                    <ng-template 
                        *ngIf="tool.popupTemplate"
                        kendoToolbarRenderer
                        [tool]="tool"
                        location="overflow"
                        [resizable]="overflow"
                        (rendererClick)="onRendererClick($event)"
                        [ngTemplateOutlet]="tool.isBuiltInTool ? tool.popupTemplate : popupWrapper"></ng-template>
                    <ng-template #popupWrapper>
                        <div role="menuitem" tabindex="-1" class="k-item k-menu-item">
                            <ng-container [ngTemplateOutlet]="tool.popupTemplate"></ng-container>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
        </ng-template>
        <ng-container #container></ng-container>
        <kendo-resize-sensor *ngIf="overflow" #resizeSensor></kendo-resize-sensor>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: LocalizedToolbarMessagesDirective, selector: "[kendoToolbarLocalizedMessages]" }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: ToolBarRendererComponent, selector: "[kendoToolbarRenderer]", inputs: ["tool", "location", "resizable"], outputs: ["rendererClick"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton]", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ToolBarComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoToolBar',
                    providers: [
                        RefreshService,
                        NavigationService,
                        LocalizationService,
                        ToolbarToolsService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.toolbar'
                        }
                    ],
                    selector: 'kendo-toolbar',
                    template: `
        <ng-container kendoToolbarLocalizedMessages
        i18n-moreToolsTitle="kendo.toolbar.moreToolsTitle|The title of the **more tools** button in a responsive ToolBar"
        moreToolsTitle="More tools"
        >
        </ng-container>
        <ng-container *ngFor="let tool of allTools; let index = index"
            kendoToolbarRenderer
            [tool]="tool"
            location="toolbar"
            [resizable]="overflow"
            (rendererClick)="onRendererClick($event)"
            [ngTemplateOutlet]="tool.isBuiltInTool ? tool.toolbarTemplate : wrapper">
            <ng-template #wrapper>
                <div class="k-toolbar-item">
                    <ng-container [ngTemplateOutlet]="tool.toolbarTemplate"></ng-container>
                </div>
            </ng-template>
        </ng-container>
        <button
            kendoButton
            fillMode="flat"
            #overflowButton
            type="button"
            icon="more-vertical"
            [svgIcon]="moreVerticalIcon"
            tabindex="-1"
            [title]="moreToolsTitle"
            [attr.aria-label]="moreToolsTitle"
            [attr.aria-expanded]="popupOpen"
            [id]="overflowBtnId"
            aria-haspopup="menu"
            *ngIf="overflow"
            [style.visibility]="'hidden'"
            [style.position]="'relative'"
            [style.margin-inline-start]="'auto'"
            class="k-toolbar-overflow-button"
            [ngClass]="overflowClass"
            (click)="showPopup()"
        >
        </button>
        <ng-template #popupTemplate>
            <div
                class="k-menu-group k-menu-group-md"
                role="menu"
                [id]="popupId"
                [attr.aria-labelledby]="overflowBtnId">
                <ng-container *ngFor="let tool of overflowTools; let index = index">
                    <ng-template 
                        *ngIf="tool.popupTemplate"
                        kendoToolbarRenderer
                        [tool]="tool"
                        location="overflow"
                        [resizable]="overflow"
                        (rendererClick)="onRendererClick($event)"
                        [ngTemplateOutlet]="tool.isBuiltInTool ? tool.popupTemplate : popupWrapper"></ng-template>
                    <ng-template #popupWrapper>
                        <div role="menuitem" tabindex="-1" class="k-item k-menu-item">
                            <ng-container [ngTemplateOutlet]="tool.popupTemplate"></ng-container>
                        </div>
                    </ng-template>
                </ng-container>
            </div>
        </ng-template>
        <ng-container #container></ng-container>
        <kendo-resize-sensor *ngIf="overflow" #resizeSensor></kendo-resize-sensor>
    `,
                    standalone: true,
                    imports: [NgTemplateOutlet, LocalizedToolbarMessagesDirective, NgFor, ToolBarRendererComponent, NgIf, ButtonComponent, NgClass, ResizeSensorComponent]
                }]
        }], ctorParameters: function () { return [{ type: i1.LocalizationService }, { type: i2.PopupService }, { type: i3.RefreshService }, { type: i4.NavigationService }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i5.ToolbarToolsService }]; }, propDecorators: { overflow: [{
                type: Input
            }], resizable: [{
                type: Input
            }], popupSettings: [{
                type: Input
            }], fillMode: [{
                type: Input
            }], tabindex: [{
                type: Input
            }], size: [{
                type: Input
            }], tabIndex: [{
                type: Input,
                args: ['tabIndex']
            }], open: [{
                type: Output
            }], close: [{
                type: Output
            }], allTools: [{
                type: ContentChildren,
                args: [ToolBarToolComponent]
            }], overflowButton: [{
                type: ViewChild,
                args: ['overflowButton', { static: false, read: ElementRef }]
            }], popupTemplate: [{
                type: ViewChild,
                args: ['popupTemplate', { static: true }]
            }], resizeSensor: [{
                type: ViewChild,
                args: ['resizeSensor', { static: false }]
            }], container: [{
                type: ViewChild,
                args: ['container', { read: ViewContainerRef, static: true }]
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-toolbar']
            }], onFocus: [{
                type: HostListener,
                args: ['focus', ['$event']]
            }], onFocusOut: [{
                type: HostListener,
                args: ['focusout', ['$event']]
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], getDir: [{
                type: HostBinding,
                args: ['attr.dir']
            }], resizableClass: [{
                type: HostBinding,
                args: ['class.k-toolbar-resizable']
            }] } });
